This file is a merged representation of a subset of the codebase, containing files not matching ignore patterns, combined into a single document by Repomix.

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of a subset of the repository's contents that is considered the most important context.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files (if enabled)
5. Multiple file entries, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching these patterns are excluded: ./**/*.md
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Files are sorted by Git change count (files with more changes are at the bottom)
</notes>

</file_summary>

<directory_structure>
.ruler/
  ruler.toml
.vooster/
  project.json
  rules.json
  vooster.json
e2e/
  example.spec.ts
scripts/
  check-env.ts
  test-env-check.sh
src/
  app/
    (protected)/
      account/
        page.tsx
      articles/
        [id]/
          edit/
            page.tsx
      dashboard/
        page.tsx
      new-article/
        page.tsx
      style-guide/
        page.tsx
      style-guides/
        [id]/
          edit/
            page.tsx
        new/
          page.tsx
      layout.tsx
    (public)/
      layout.tsx
      page.tsx
    api/
      [[...hono]]/
        route.ts
      articles/
        generate/
          route.ts
    auth/
      after/
        page.tsx
      onboarding/
        _actions.ts
        page.tsx
      layout.tsx
    example/
      page.tsx
    login/
      page.tsx
    sign-in/
      [[...sign-in]]/
        layout.tsx
        page.tsx
    sign-up/
      [[...sign-up]]/
        layout.tsx
        page.tsx
    signup/
      page.tsx
    globals.css
    layout.tsx
    providers.tsx
  backend/
    config/
      index.ts
    hono/
      app.ts
      context.ts
    http/
      response.ts
    middleware/
      context.ts
      error.ts
      supabase.ts
    supabase/
      client.ts
  components/
    brand/
      logo.tsx
    dashboard/
      activity-chart.tsx
      recent-articles-list.tsx
      stats-cards.tsx
      welcome-banner.tsx
      welcome-header.tsx
    layout/
      header.tsx
      sidebar.tsx
    ui/
      accordion.tsx
      alert.tsx
      avatar.tsx
      badge.tsx
      button.tsx
      card.tsx
      checkbox.tsx
      dialog.tsx
      dropdown-menu.tsx
      file-upload.tsx
      form.tsx
      input.tsx
      label.tsx
      progress.tsx
      select.tsx
      separator.tsx
      sheet.tsx
      skeleton.tsx
      sonner.tsx
      table.tsx
      tabs.tsx
      textarea.tsx
      toast.tsx
      toaster.tsx
  constants/
    auth.ts
    env.ts
  features/
    articles/
      actions/
        article-actions.ts
      backend/
        ai-service.ts
        error.ts
        quota-service.ts
        route.ts
        schema.ts
        service.ts
      components/
        article-form.tsx
        article-preview.tsx
        auto-save-indicator.tsx
        generation-form.tsx
        generation-progress.tsx
        markdown-preview.tsx
        seo-panel.tsx
        table-of-contents.tsx
      hooks/
        useArticle.ts
        useAutoSave.ts
        useCreateArticle.ts
        useGenerateArticle.ts
        useStyleGuide.ts
        useUpdateArticle.ts
      lib/
        article-form-schema.ts
        article-schema.ts
        dto.ts
        markdown-utils.ts
    auth/
      context/
        current-user-context.tsx
      hooks/
        useCurrentUser.ts
      server/
        load-current-user.ts
      types.ts
    example/
      backend/
        error.ts
        route.ts
        schema.ts
        service.ts
      components/
        example-status.test.tsx
        example-status.tsx
      hooks/
        useExampleQuery.ts
      lib/
        dto.test.ts
        dto.ts
    landing/
      components/
        features-section.tsx
        final-cta-section.tsx
        hero-section.tsx
        how-it-works-section.tsx
        pricing-section.tsx
        use-cases-section.tsx
    onboarding/
      actions/
        complete-onboarding.ts
        create-style-guide.ts
      backend/
        error.ts
        route.ts
        schema.ts
        service.ts
      components/
        onboarding-wizard.tsx
        preview-panel.tsx
        step-audience.tsx
        step-brand-voice.tsx
        step-indicator.tsx
        step-language.tsx
        step-review.tsx
        step-style.tsx
        style-guide-card.tsx
        style-guide-preview-modal.tsx
      lib/
        constants.ts
        onboarding-schema.ts
  hooks/
    use-toast.ts
  lib/
    remote/
      api-client.ts
    supabase/
      browser-client.ts
      client.ts
      server-client.ts
      server.ts
      types.ts
    clerk-theme.ts
    slug.ts
    utils.ts
  types/
    globals.d.ts
  middleware.ts
supabase/
  migrations/
    0001_create_example_table.sql
    0002_create_style_guides_table.sql
    0003_create_articles_table.sql
    0004_create_generation_quota_table.sql
    0005_add_onboarding_completed_to_style_guides.sql
.cursorignore
.env.example
.env.test
.gitignore
components.json
eslint.config.mjs
next.config.ts
package.json
playwright.config.ts
postcss.config.mjs
tailwind.config.ts
tsconfig.json
vitest.config.ts
vitest.d.ts
vitest.setup.ts
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path=".vooster/rules.json">
{
  "rules": [
    {
      "type": "prd",
      "content": "# 제품 요구사항 문서(PRD)\n\n## 1. 제품 한줄 요약\n인디해커가 키워드만 입력하면 영어·한국어 블로그 글, SEO 메타데이터, 브랜드 톤까지 5분 내 완성되는 AI 콘텐츠 생성 SaaS.\n\n## 2. 비전 & 목표\n- 작은 팀·솔로 창업자가 콘텐츠 마케팅보다 제품 개발에 집중할 수 있도록 글 작성 시간을 90% 이상 단축한다.\n- 사용자가 ‘월간 완성 글 수’를 꾸준히 늘려 사업 성장을 체감하도록 한다.\n\n## 3. 핵심 사용자(Persona)\n| 구분 | 특징 |\n|------|------|\n| Indie Hacker Sam | 1인 SaaS 창업자, 연 매출 $1~50K, 블로그는 WordPress 또는 Notion으로 운영, 글쓰기·SEO 경험 부족, 월 $50 이하 툴 사용 예산 |\n\n## 4. 주요 Use Case\n1. Sam이 제품 키워드와 간단한 설명을 입력한다.\n2. 서비스가 브랜드 보이스 위저드를 통해 톤·길이·독자 수준을 설정한다.\n3. 5분 내 초안, 제목, H 태그 구조, 메타디스크립션을 생성한다.\n4. Sam은 원스크린 편집기에서 문단별 재생성을 하고 실시간 SEO 체크를 확인한다.\n5. 마크다운으로 내보내어 노션 블로그에 붙여넣고 발행한다.\n6. 대시보드에서 월간 완성 글 수와 누적 시간 절약을 확인한다.\n\n## 5. 핵심 기능 (MVP)\n1. AI 주제 기반 글 자동 생성 (1,500~2,500단어)\n2. SEO 키워드 & 메타데이터 자동 삽입\n3. 스타일 가이드(브랜드 보이스) 저장·관리\n4. 온보딩 위저드(5문항)\n5. 원스크린 글 생성·수정 편집기 + 실시간 SEO 점검\n6. 시간 절약 현황판 & 월간 완성 글 수 그래프\n7. Markdown 내보내기 (외부 API 연동 없음)\n\n## 6. 비MVP / 향후 기능\n- 자동 이미지 삽입, WordPress 1-click 발행, 키워드 성과 대시보드, 콘텐츠 캘린더, 팀 협업, 다국어 5개 이상 지원\n\n## 7. 성공 지표(KPI)\n- 활성 사용자당 월간 완성 글 수 ≥ 4편\n- 글 3편 무료 체험 후 유료 전환율 ≥ 25%\n- NPS ≥ 40\n- 글 작성 소요 시간 평균 5분 이하\n\n## 8. 가격 정책\n- 무료: 글 3편 생성까지, 기능 전체 사용 가능\n- 프로 플랜: 월 $19, 글 무제한, 스타일 가이드 3개, 향후 기능 우선 접근\n\n## 9. 기술 스택(기본)\nNext.js 15, Hono.js, Supabase(PostgreSQL), TypeScript, TailwindCSS, shadcn, lucide-react, @tanstack/react-query, OpenAI GPT-4o API\n\n## 10. 개발 전략\n- 방식: MVP → 사용자 피드백 기반 애자일 개선\n- 일정: 8주 내 베타, Product Hunt 런칭\n- 팀: 2인(풀스택 1, SEO/PM 1)\n\n## 11. 제약 사항\n- 반응형 웹 필수(모바일 ≥ 320px)\n- 영어·한국어 고품질 출력 확보\n- 일 10만 단어까지 AI API 비용 $200/월 이내 유지\n\n## 12. 위험 & 대응\n| 리스크 | 대응 |\n|---------|------|\n| AI 모델 평준화 | 스타일 가이드 USP 고도화, 편집 UX 최적화 |\n| 사용자 이탈 | 시간 절약 현황판·성과 알림으로 지속 가치 제공 |\n| 비용 초과 | 단어 수 하드쿼터, Prompt 최적화 |\n\n## 13. 향후 로드맵(12개월)\n- M0-2: MVP 개발, 폐쇄 베타 100명\n- M3: Product Hunt 공개, 유료 전환 시작\n- M4-6: 콘텐츠 캘린더, 워드프레스 발행\n- M7-12: 성과 대시보드, 이미지 AI, 팀 협업, 다국어 확대\n\n## 14. 운영 & 지원\n- Discord 커뮤니티로 사용자 지원\n- 주 1회 제품 업데이트 로그 게시\n\n---\n이 문서는 제품 정의 완료 버전입니다.",
      "writedAt": "2025-11-08T10:13:52.019Z"
    },
    {
      "type": "architecture",
      "content": "Of course. As a senior technical architect, my goal is to distill the technical requirements into a pragmatic blueprint that accelerates development and eliminates unnecessary complexity.\n\nThis refined TRD is focused on what the two-person team needs to build the MVP in 8 weeks, prioritizing clarity, speed, and direct alignment with the PRD.\n\n---\n\n# **Technical Requirements Document (TRD) - AI Content SaaS MVP**\n\n## 1. Guiding Principles\n\n*   **Simplicity First:** The architecture must be the simplest possible to meet the MVP requirements. We will avoid premature optimization and complex patterns.\n*   **Leverage the Stack:** Fully utilize the features of Next.js, Supabase, and Vercel to minimize boilerplate and infrastructure management.\n*   **Developer Velocity:** The structure should enable a single full-stack developer to move quickly without significant context switching.\n\n## 2. Core Technology Stack\n\n| Component           | Technology                | Role & Rationale                                                                        |\n| ------------------- | ------------------------- | --------------------------------------------------------------------------------------- |\n| **Web Framework**   | Next.js 15 (App Router)   | Handles frontend rendering, server components, and API routes. Ideal for rapid development. |\n| **API Layer**       | Hono.js                   | Integrated within Next.js API Routes for fast, lightweight backend logic.                 |\n| **Database & Auth** | Supabase (PostgreSQL)     | Provides database, user authentication, and object storage. The integrated solution simplifies the stack. |\n| **AI Model**        | OpenAI GPT-4o API         | Core engine for all text generation tasks.                                              |\n| **UI Components**   | TailwindCSS + shadcn/ui   | For rapid, consistent, and accessible UI development.                                   |\n| **State Management**| @tanstack/react-query     | Manages all server state, caching, and data fetching. Client state will use React hooks (`useState`, `useContext`). |\n| **Payments**        | TossPayments SDK          | To be integrated post-beta for the Pro Plan upgrade flow. Not a blocker for MVP launch. |\n\n## 3. System Architecture & Directory Structure\n\nWe will adopt a feature-centric, co-located structure. This is lean and scales well for a small team. The overly-nested structure from the initial draft is flattened to improve velocity.\n\n```\n/\n├── public/                     # Static assets (images, fonts)\n├── supabase/migrations/        # Database schema migrations\n└── src/\n    ├── app/                    # Next.js App Router\n    │   ├── (auth)/             # Routes for auth pages (login, signup)\n    │   │   └── page.tsx\n    │   ├── (main)/             # Main application routes (protected)\n    │   │   ├── dashboard/      # Dashboard page\n    │   │   └── editor/[id]/    # Article editor page\n    │   ├── api/[[...route]]/   # Hono.js entrypoint for all API calls\n    │   └── layout.tsx\n    ├── components/\n    │   └── ui/                 # Auto-generated shadcn/ui components\n    ├── features/               # Core application logic modules\n    │   ├── article-editor/     # All logic for the editor feature\n    │   │   ├── components/     # React components specific to the editor\n    │   │   ├── editor-actions.ts # Server Actions for saving, regenerating\n    │   │   └── seo-checker.ts  # Client-side SEO scoring logic\n    │   ├── dashboard/          # Dashboard feature\n    │   └── style-guide/        # Style guide (brand voice) feature\n    └── lib/\n        ├── supabase/           # Supabase client setup (client & server)\n        ├── openai.ts           # OpenAI API client wrapper\n        └── utils.ts            # Shared utility functions (e.g., cn)\n```\n\n## 4. Data Model (Supabase PostgreSQL Schema)\n\nThis schema is the minimum required for the MVP. We will use Supabase's built-in `auth.users` table for user management.\n\n```sql\n-- Users are handled by Supabase Auth. We reference them via UUID.\n\n-- Table to store user-defined style guides (brand voice)\nCREATE TABLE style_guides (\n    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),\n    user_id UUID REFERENCES auth.users(id) ON DELETE CASCADE NOT NULL,\n    guide_name TEXT NOT NULL,\n    brand_voice TEXT NOT NULL, -- e.g., \"Witty and Casual\", \"Formal and Authoritative\"\n    target_audience TEXT NOT NULL, -- e.g., \"Beginner developers\", \"Marketing managers\"\n    language VARCHAR(2) NOT NULL, -- 'en' or 'ko'\n    created_at TIMESTAMPTZ DEFAULT now()\n);\n\n-- Table to store generated articles\nCREATE TABLE articles (\n    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),\n    user_id UUID REFERENCES auth.users(id) ON DELETE CASCADE NOT NULL,\n    style_guide_id UUID REFERENCES style_guides(id) ON DELETE SET NULL,\n    status VARCHAR(20) NOT NULL DEFAULT 'draft', -- 'draft', 'completed'\n    keyword TEXT NOT NULL,\n    title TEXT,\n    content_markdown TEXT,\n    meta_description TEXT,\n    seo_score INT DEFAULT 0,\n    time_saved_minutes INT DEFAULT 0, -- Estimated time saved\n    created_at TIMESTAMPTZ DEFAULT now(),\n    updated_at TIMESTAMPTZ DEFAULT now()\n);\n\n-- Enable Row Level Security (RLS) for all tables\nALTER TABLE style_guides ENABLE ROW LEVEL SECURITY;\nALTER TABLE articles ENABLE ROW LEVEL SECURITY;\n\n-- Policies to ensure users can only access their own data\nCREATE POLICY \"user_can_access_own_guides\" ON style_guides FOR ALL USING (auth.uid() = user_id);\nCREATE POLICY \"user_can_access_own_articles\" ON articles FOR ALL USING (auth.uid() = user_id);\n```\n\n## 5. Core Logic & API Endpoints\n\nAuthentication is managed by Supabase Auth middleware on protected routes. API logic will be centralized through Hono.\n\n**API Endpoint:** `POST /api/articles/generate`\n\n**Request Body:**\n```json\n{\n  \"keyword\": \"How to start a SaaS business\",\n  \"styleGuideId\": \"uuid-of-the-style-guide\"\n}\n```\n\n**Generation Flow:**\n\n1.  **Client Request:** The user clicks \"Generate\" in the UI, triggering the API call.\n2.  **API Route (Hono):**\n    *   Authenticates the user via Supabase session.\n    *   Retrieves the specified `style_guide` from the database.\n    *   Checks the user's article count against the free tier limit (3 articles).\n3.  **Prompt Engineering:**\n    *   Constructs a single, comprehensive prompt for GPT-4o. The prompt will request a JSON object containing: `title`, `meta_description`, and `article_body` (as a Markdown string with H2/H3 tags).\n    *   The prompt will incorporate the user's keyword and all parameters from their `style_guide` (voice, audience, language).\n4.  **OpenAI API Call:**\n    *   Calls the GPT-4o API with the engineered prompt. Using streaming is **not** required for the MVP to keep the initial implementation simple. The process should complete within the 5-minute target.\n5.  **Database Insert:**\n    *   Parses the JSON response from OpenAI.\n    *   Creates a new record in the `articles` table with the generated content and `status = 'draft'`.\n    *   Calculates an estimated `time_saved_minutes` (e.g., constant value of 120 minutes).\n6.  **API Response:** Returns the `id` of the newly created article. The client then redirects to the editor page (`/editor/{id}`).\n\n## 6. Key Implementation Details\n\n*   **Onboarding Wizard:** A simple multi-step client-side component that collects data for the user's first `style_guide` and saves it to the database upon completion.\n*   **One-Screen Editor:**\n    *   The editor will be a single React component that fetches the article data using `@tanstack/react-query`.\n    *   It will use a standard textarea for Markdown editing. No complex rich-text editor is needed for the MVP.\n    *   \"Regenerate Paragraph\" will be a Server Action that takes the paragraph's context and re-runs a targeted, smaller prompt through the OpenAI API, updating the content in-place.\n*   **Real-time SEO Check:** A client-side utility function (`/features/article-editor/seo-checker.ts`). It will perform simple, non-blocking checks on the `content_markdown` state for:\n    *   Keyword presence in title and H-tags.\n    *   Word count.\n    *   Meta description length.\n*   **Cost Management:**\n    *   The generation prompt will explicitly request an article length between 1,500-2,500 words to control token usage.\n    *   The backend will enforce a hard limit: free users can only call the `POST /api/articles/generate` endpoint 3 times. This is tracked by counting rows in the `articles` table for the user.",
      "writedAt": "2025-11-08T10:13:52.019Z"
    },
    {
      "type": "guideline",
      "content": "\n    # Senior Developer Guidelines\n    \n    ## Must\n    \n    - always use client component for all components. (use `use client` directive)\n    - always use promise for page.tsx params props.\n    - use valid picsum.photos stock image for placeholder image\n    \n    ## Library\n    \n    use following libraries for specific functionalities:\n    \n    1. `date-fns`: For efficient date and time handling.\n    2. `ts-pattern`: For clean and type-safe branching logic.\n    3. `@tanstack/react-query`: For server state management.\n    4. `zustand`: For lightweight global state management.\n    5. `react-use`: For commonly needed React hooks.\n    6. `es-toolkit`: For robust utility functions.\n    7. `lucide-react`: For customizable icons.\n    8. `zod`: For schema validation and data integrity.\n    9. `shadcn-ui`: For pre-built accessible UI components.\n    10. `tailwindcss`: For utility-first CSS styling.\n    11. `supabase`: For a backend-as-a-service solution.\n    12. `react-hook-form`: For form validation and state management.\n    \n    ## Directory Structure\n    \n    - src\n    - src/app: Next.js App Routers\n    - src/components/ui: shadcn-ui components\n    - src/constants: Common constants\n    - src/hooks: Common hooks\n    - src/lib: utility functions\n    - src/remote: http client\n    - src/features/[featureName]/components/*: Components for specific feature\n    - src/features/[featureName]/constants/*\n    - src/features/[featureName]/hooks/*\n    - src/features/[featureName]/lib/*\n    - src/features/[featureName]/api.ts: api fetch functions\n    \n    ## Solution Process:\n    \n    1. Rephrase Input: Transform to clear, professional prompt.\n    2. Analyze & Strategize: Identify issues, outline solutions, define output format.\n    3. Develop Solution:\n       - \"As a senior-level developer, I need to [rephrased prompt]. To accomplish this, I need to:\"\n       - List steps numerically.\n       - \"To resolve these steps, I need the following solutions:\"\n       - List solutions with bullet points.\n    4. Validate Solution: Review, refine, test against edge cases.\n    5. Evaluate Progress:\n       - If incomplete: Pause, inform user, await input.\n       - If satisfactory: Proceed to final output.\n    6. Prepare Final Output:\n       - ASCII title\n       - Problem summary and approach\n       - Step-by-step solution with relevant code snippets\n       - Format code changes:\n        ```language:path/to/file\n         // ... existing code ...\n         function exampleFunction() {\n             // Modified or new code here\n         }\n         // ... existing code ...\n         ```\n       - Use appropriate formatting\n       - Describe modifications\n       - Conclude with potential improvements\n    \n    ## Key Mindsets:\n    \n    1. Simplicity\n    2. Readability\n    3. Maintainability\n    4. Testability\n    5. Reusability\n    6. Functional Paradigm\n    7. Pragmatism\n    \n    ## Code Guidelines:\n    \n    1. Early Returns\n    2. Conditional Classes over ternary\n    3. Descriptive Names\n    4. Constants > Functions\n    5. DRY\n    6. Functional & Immutable\n    7. Minimal Changes\n    8. Pure Functions\n    9. Composition over inheritance\n    \n    ## Functional Programming:\n    \n    - Avoid Mutation\n    - Use Map, Filter, Reduce\n    - Currying and Partial Application\n    - Immutability\n    \n    ## Code-Style Guidelines\n    \n    - Use TypeScript for type safety.\n    - Follow the coding standards defined in the ESLint configuration.\n    - Ensure all components are responsive and accessible.\n    - Use Tailwind CSS for styling, adhering to the defined color palette.\n    - When generating code, prioritize TypeScript and React best practices.\n    - Ensure that any new components are reusable and follow the existing design patterns.\n    - Minimize the use of AI generated comments, instead use clearly named variables and functions.\n    - Always validate user inputs and handle errors gracefully.\n    - Use the existing components and pages as a reference for the new components and pages.\n    \n    ## Performance:\n    \n    - Avoid Premature Optimization\n    - Profile Before Optimizing\n    - Optimize Judiciously\n    - Document Optimizations\n    \n    ## Comments & Documentation:\n    \n    - Comment function purpose\n    - Use JSDoc for JS\n    - Document \"why\" not \"what\"\n    \n    ## Function Ordering:\n    \n    - Higher-order functionality first\n    - Group related functions\n    \n    ## Handling Bugs:\n    \n    - Use TODO: and FIXME: comments\n    \n    ## Error Handling:\n    \n    - Use appropriate techniques\n    - Prefer returning errors over exceptions\n    \n    ## Testing:\n    \n    - Unit tests for core functionality\n    - Consider integration and end-to-end tests\n    \n    ## Next.js\n    \n    - you must use promise for page.tsx params props.\n    \n    ## Shadcn-ui\n    \n    - if you need to add new component, please show me the installation instructions. I'll paste it into terminal.\n    - example\n      ```\n      $ npx shadcn@latest add card\n      $ npx shadcn@latest add textarea\n      $ npx shadcn@latest add dialog\n      ```\n    \n    ## Supabase\n    \n    - if you need to add new table, please create migration. I'll paste it into supabase.\n    - do not run supabase locally\n    - store migration query for `.sql` file. in /supabase/migrations/\n    \n    ## Package Manager\n    \n    - use npm as package manager.\n    \n    ## Korean Text\n    \n    - 코드를 생성한 후에 utf-8 기준으로 깨지는 한글이 있는지 확인해주세요. 만약 있다면 수정해주세요.\n    \n    You are a senior full-stack developer, one of those rare 10x devs. Your focus: clean, maintainable, high-quality code.\n    Apply these principles judiciously, considering project and team needs.\n      ",
      "writedAt": "2025-11-08T10:13:52.019Z"
    },
    {
      "type": "design-guide",
      "content": "# ContentCraft AI Design Guide\n\n## 1. Overall Mood (전체적인 무드)\n\nContentCraft AI는 **신뢰할 수 있고 전문적인(Trustworthy & Professional)** 무드를 지향합니다. 인디해커와 솔로 창업자들이 콘텐츠 생성에 집중할 수 있도록 깔끔하고 직관적인 인터페이스를 제공합니다. \n\n핵심 디자인 철학:\n- **미니멀리즘**: 불필요한 요소를 제거하고 콘텐츠에 집중\n- **신뢰성**: 쿨톤과 저채도로 안정감과 전문성 표현\n- **효율성**: 사용자의 작업 흐름을 방해하지 않는 직관적 레이아웃\n- **접근성**: 초보자와 전문가 모두 사용할 수 있는 유연한 인터페이스\n\n## 2. Reference Service (참조 서비스)\n\n- **Name**: Notion\n- **Description**: 올인원 워크스페이스 및 노트 테이킹 도구\n- **Design Mood**: 깔끔하고 모노톤적이며 콘텐츠 중심의 미니멀 디자인\n- **Primary Color**: #2F3437 (다크 그레이)\n- **Secondary Color**: #F7F6F3 (오프 화이트)\n\nNotion의 콘텐츠 중심적 접근법과 깔끔한 타이포그래피, 직관적인 블록 편집 시스템을 벤치마킹하여 글쓰기에 최적화된 환경을 구현합니다.\n\n## 3. Color & Gradient (색상 & 그라데이션)\n\n### 메인 컬러 팔레트\n- **Primary Color**: #1E2A38 (Navy) - 메인 브랜드 컬러, 신뢰성과 전문성 표현\n- **Secondary Color**: #F5F7FA (Soft Gray) - 배경 및 카드 컬러\n- **Accent Color**: #3BA2F8 (Sky Blue) - CTA 버튼, 링크, 강조 요소\n- **Background**: #FCFCFD (Off-White) - 메인 배경\n- **Border**: #E1E5EA (Light Gray) - 구분선 및 테두리\n\n### 보조 컬러\n- **Success**: #10B981 (Emerald)\n- **Warning**: #F59E0B (Amber)\n- **Error**: #EF4444 (Red)\n- **Info**: #3B82F6 (Blue)\n\n### 그레이스케일\n- **Gray 900**: #111827\n- **Gray 700**: #374151\n- **Gray 500**: #6B7280\n- **Gray 300**: #D1D5DB\n- **Gray 100**: #F3F4F6\n\n### Mood\n- **톤**: 쿨톤 (Cool Tone)\n- **채도**: 저채도 (Low Saturation)\n\n### Color Usage\n1. **최우선**: Primary Navy (#1E2A38) - 네비게이션, 메인 헤더\n2. **강조**: Accent Sky Blue (#3BA2F8) - CTA 버튼, 활성 상태\n3. **배경**: Soft Gray (#F5F7FA) - 카드, 사이드바\n4. **텍스트**: Gray 900 (#111827) - 본문, Gray 700 (#374151) - 보조 텍스트\n\n## 4. Typography & Font (타이포그래피 & 폰트)\n\n### 폰트 패밀리\n- **영문**: Inter (Google Fonts)\n- **한글**: Pretendard (시스템 폰트 대체)\n- **모노스페이스**: JetBrains Mono (코드 블록용)\n\n### 타이포그래피 스케일\n- **Heading 1**: 32px, Bold (700), Letter-spacing: -0.025em\n- **Heading 2**: 24px, Semibold (600), Letter-spacing: -0.025em\n- **Heading 3**: 20px, Semibold (600)\n- **Body Large**: 18px, Regular (400), Line-height: 1.7\n- **Body**: 16px, Regular (400), Line-height: 1.6\n- **Body Small**: 14px, Regular (400), Line-height: 1.5\n- **Caption**: 12px, Medium (500), Line-height: 1.4\n\n### 텍스트 컬러\n- **Primary**: Gray 900 (#111827)\n- **Secondary**: Gray 700 (#374151)\n- **Muted**: Gray 500 (#6B7280)\n- **Placeholder**: Gray 300 (#D1D5DB)\n\n## 5. Layout & Structure (레이아웃 & 구조)\n\n### 그리드 시스템\n- **Container Max Width**: 1440px\n- **Breakpoints**: \n  - Mobile: <640px\n  - Tablet: 640px-1024px  \n  - Desktop: >1024px\n- **Spacing Scale**: 4px 기본 단위 (4, 8, 12, 16, 20, 24, 32, 40, 48, 64px)\n\n### 메인 레이아웃 구조\n```\n┌─────────────────────────────────────────┐\n│ Topbar (64px height)                    │\n├───────────┬─────────────────────────────┤\n│ Sidebar   │ Main Content Area           │\n│ (280px)   │                             │\n│           │ ┌─────┬─────────┬─────────┐ │\n│           │ │Input│Preview  │SEO Panel│ │\n│           │ │     │         │         │ │\n│           │ └─────┴─────────┴─────────┘ │\n└───────────┴─────────────────────────────┘\n```\n\n### 3-Column 콘텐츠 레이아웃\n- **입력 영역**: 360px (최소 320px)\n- **미리보기**: 가변 (최소 480px)\n- **SEO 패널**: 320px (콜랩서블)\n\n### 반응형 규칙\n- **Mobile (<640px)**: 사이드바 숨김, 1-Column 스택, 플로팅 FAB\n- **Tablet (640-1024px)**: 2-Column (입력+미리보기), SEO 패널 하단\n- **Desktop (>1024px)**: 3-Column 전체 표시\n\n## 6. Visual Style (비주얼 스타일)\n\n### 아이콘 시스템\n- **라이브러리**: Lucide React\n- **스타일**: 선형 아이콘 (Line Icons)\n- **Stroke Width**: 1.5px\n- **크기**: 16px (Small), 20px (Medium), 24px (Large)\n\n### 이미지 가이드라인\n- **종횡비**: 16:9 (히어로), 1:1 (프로필), 4:3 (카드)\n- **코너 반경**: 8px (카드), 12px (대형 이미지)\n- **오버레이**: rgba(30, 42, 56, 0.6) 텍스트 가독성 확보\n\n### 일러스트레이션\n- **스타일**: 미니멀 선형 일러스트\n- **컬러**: 브랜드 컬러 팔레트 내에서 2-3색 사용\n- **용도**: 온보딩, 빈 상태(Empty State), 에러 페이지\n\n### 그림자 시스템\n- **Small**: 0 1px 3px rgba(0, 0, 0, 0.1)\n- **Medium**: 0 4px 6px rgba(0, 0, 0, 0.07)\n- **Large**: 0 10px 15px rgba(0, 0, 0, 0.1)\n- **XL**: 0 20px 25px rgba(0, 0, 0, 0.1)\n\n## 7. UX Guide (UX 가이드)\n\n### 타겟 사용자 접근법\n**Both (전문가 + 초보자)** 지원을 위한 적응형 인터페이스\n\n### 초보자를 위한 UX\n- **온보딩**: 첫 방문 시 3-Step 코치마크 튜토리얼\n- **기본값 최적화**: 가장 일반적인 설정을 기본값으로 제공\n- **도움말 시스템**: 컨텍스트 툴팁, 인라인 가이드\n- **프로그레스 표시**: 단계별 진행률, 완료 상태 명확히 표시\n\n### 전문가를 위한 UX\n- **고급 옵션**: 토글로 숨김/표시 가능한 세부 설정\n- **단축키 지원**: Cmd/Ctrl + 키 조합으로 빠른 작업\n- **배치 작업**: 여러 글 동시 처리 기능\n- **커스터마이제이션**: 작업 공간 레이아웃 조정\n\n### 핵심 UX 원칙\n1. **즉시성**: 5분 내 글 생성 완료, 실시간 피드백\n2. **투명성**: 진행 상황, 비용, 제한사항 명확히 표시  \n3. **제어감**: 문단별 재생성, 실시간 편집 가능\n4. **성취감**: 시간 절약, 완성 글 수 등 가시적 성과 표시\n\n### 마이크로카피 가이드라인\n- **톤**: 격식 있으나 친근함\n- **길이**: 6단어 이하 간결함\n- **유머**: 지나친 유머 지양, 전문성 유지\n- **예시**: \"글 생성 중...\" → \"AI가 작성 중입니다\" (X) → \"생성 중\" (O)\n\n## 8. UI Component Guide (UI 컴포넌트 가이드)\n\n### 버튼 시스템\n\n#### Primary Button\n- **배경**: Accent Blue (#3BA2F8)\n- **텍스트**: White\n- **높이**: 40px (Medium), 48px (Large)\n- **패딩**: 16px 24px\n- **코너**: 8px 반경\n- **호버**: 배경 20% 어둡게\n- **예시**: \"글 생성하기\", \"저장하기\"\n\n#### Secondary Button  \n- **배경**: Transparent\n- **테두리**: 1px solid Gray 300\n- **텍스트**: Gray 700\n- **호버**: 배경 Gray 50\n- **예시**: \"취소\", \"다시 생성\"\n\n#### Ghost Button\n- **배경**: Transparent  \n- **텍스트**: Accent Blue\n- **호버**: 배경 Blue 50\n- **예시**: \"더 보기\", \"편집\"\n\n### 입력 필드 (Input Fields)\n\n#### Text Input\n- **높이**: 40px\n- **패딩**: 12px 16px\n- **테두리**: 1px solid Gray 300\n- **코너**: 6px 반경\n- **포커스**: 테두리 Accent Blue, 그림자 추가\n- **플레이스홀더**: Gray 400\n\n#### Textarea\n- **최소 높이**: 120px\n- **리사이즈**: 세로만 가능\n- **라인 높이**: 1.5\n\n#### Select Dropdown\n- **높이**: 40px\n- **아이콘**: Chevron Down (Lucide)\n- **옵션**: 최대 높이 200px, 스크롤\n\n### 카드 시스템\n\n#### Content Card\n- **배경**: White\n- **테두리**: 1px solid Gray 200\n- **코너**: 12px 반경\n- **패딩**: 24px\n- **그림자**: Medium Shadow\n- **호버**: 그림자 증가\n\n#### Stats Card\n- **배경**: Gradient (White → Gray 50)\n- **아이콘**: 20px, Accent Blue\n- **제목**: 14px Medium\n- **수치**: 24px Bold\n\n### 네비게이션\n\n#### Top Navigation\n- **높이**: 64px\n- **배경**: White\n- **테두리**: 하단 1px solid Gray 200\n- **로고**: 좌측, 32px 높이\n- **메뉴**: 우측, 사용자 아바타 포함\n\n#### Sidebar\n- **너비**: 280px (콜랩서블)\n- **배경**: Gray 50\n- **메뉴 아이템**: 40px 높이, 12px 패딩\n- **활성 상태**: Accent Blue 배경, White 텍스트\n\n### 피드백 컴포넌트\n\n#### Progress Bar (SEO 점수용)\n- **높이**: 8px\n- **배경**: Gray 200\n- **진행**: Accent Blue → Success Green\n- **코너**: 4px 반경\n- **레이블**: 상단 우측 표시\n\n#### Toast Notification\n- **위치**: 우측 상단\n- **너비**: 360px\n- **자동 닫힘**: 4초\n- **타입별 컬러**: Success, Warning, Error\n\n#### Loading States\n- **스켈레톤**: Gray 200 배경, 애니메이션\n- **스피너**: Accent Blue, 24px\n- **진행률**: 카운트다운 타이머 포함\n\n### 데이터 시각화\n\n#### Dashboard Cards\n- **시간 절약**: 큰 숫자 + 단위, Success Green\n- **완성 글 수**: 월간 그래프, Accent Blue\n- **SEO 점수**: 원형 프로그레스, 그라데이션\n\n#### Charts\n- **라이브러리**: Recharts\n- **컬러**: 브랜드 팔레트 순서대로\n- **그리드**: Gray 100, 미세한 선\n\n### 애니메이션 가이드\n\n#### 전환 효과\n- **지속시간**: 150-250ms\n- **이징**: ease-out\n- **타입**: fade, slide, scale\n\n#### 로딩 애니메이션  \n- **스켈레톤**: 좌우 이동 그라데이션\n- **펄스**: 투명도 변화\n- **스피너**: 회전\n\n### 접근성 (Accessibility)\n\n#### 컬러 대비\n- **최소 기준**: WCAG AA (4.5:1)\n- **텍스트**: Gray 900 on White (15.6:1)\n- **링크**: Accent Blue on White (8.2:1)\n\n#### 키보드 네비게이션\n- **Tab 순서**: 논리적 흐름\n- **포커스 표시**: 2px Accent Blue 아웃라인\n- **단축키**: Cmd/Ctrl 조합\n\n#### 스크린 리더\n- **aria-label**: 모든 인터랙티브 요소\n- **role 속성**: 적절한 시맨틱 역할\n- **alt 텍스트**: 의미있는 이미지 설명\n\n### 반응형 컴포넌트 규칙\n\n#### 모바일 (<640px)\n- **버튼**: 전체 너비, 48px 높이\n- **입력 필드**: 전체 너비\n- **카드**: 16px 패딩\n- **네비게이션**: 햄버거 메뉴\n\n#### 태블릿 (640-1024px)  \n- **그리드**: 2-Column 레이아웃\n- **사이드바**: 오버레이 모드\n- **카드**: 20px 패딩\n\n#### 데스크톱 (>1024px)\n- **그리드**: 3-Column 전체 표시\n- **호버 상태**: 모든 인터랙티브 요소\n- **툴팁**: 마우스 오버 시 표시",
      "writedAt": "2025-11-08T10:13:52.019Z"
    },
    {
      "type": "ia",
      "content": "# ContentCraft AI 정보 아키텍처 (IA)\n\n## 1. 사이트맵 (사이트맵)\n\n```\nContentCraft AI\n├── / (홈페이지)\n├── /auth\n│   ├── /auth/login (로그인)\n│   ├── /auth/signup (회원가입)\n│   └── /auth/onboarding (온보딩 위저드)\n├── /dashboard (대시보드) [인증 필요]\n│   ├── /dashboard/stats (통계 현황)\n│   └── /dashboard/history (작성 이력)\n├── /new (새 글 작성) [인증 필요]\n│   ├── /new/setup (주제 설정)\n│   ├── /new/generate (AI 생성)\n│   └── /new/edit (편집 및 완성)\n├── /style-guides (스타일 가이드 관리) [인증 필요]\n│   ├── /style-guides/list (가이드 목록)\n│   ├── /style-guides/new (새 가이드 생성)\n│   └── /style-guides/:id/edit (가이드 편집)\n├── /account (계정 관리) [인증 필요]\n│   ├── /account/profile (프로필 설정)\n│   ├── /account/billing (결제 및 구독)\n│   └── /account/usage (사용량 현황)\n├── /docs (도움말)\n│   ├── /docs/getting-started (시작 가이드)\n│   ├── /docs/features (기능 설명)\n│   └── /docs/faq (자주 묻는 질문)\n└── /pricing (가격 정책)\n```\n\n## 2. 사용자 흐름 (사용자 흐름)\n\n### **핵심 작업 1: 신규 사용자 온보딩**\n1. 사용자가 홈페이지(/)에서 \"무료로 시작하기\" 버튼 클릭\n2. 회원가입 페이지(/auth/signup)로 이동\n3. 이메일, 패스워드 입력 후 계정 생성\n4. 온보딩 위저드(/auth/onboarding)로 자동 이동\n5. 5문항 브랜드 보이스 설정 완료\n6. 대시보드(/dashboard)로 이동하여 첫 글 작성 유도\n\n### **핵심 작업 2: AI 글 생성 및 편집**\n1. 대시보드에서 \"새 글 작성\" 버튼 클릭\n2. 새 글 작성 페이지(/new)로 이동\n3. 주제 키워드와 간단한 설명 입력\n4. 스타일 가이드 선택 (기본값 적용)\n5. \"생성하기\" 버튼 클릭하여 AI 생성 시작\n6. 5분 내 초안, 제목, SEO 메타데이터 자동 생성\n7. 원스크린 편집기에서 문단별 재생성 및 수정\n8. 실시간 SEO 점수 확인 및 최적화\n9. 마크다운으로 다운로드 또는 클립보드 복사\n10. 대시보드에서 완성 글 수 및 시간 절약 현황 확인\n\n### **핵심 작업 3: 유료 전환**\n1. 무료 3편 완성 후 새 글 작성 시도\n2. 제한 도달 모달 팝업 표시\n3. 프로 플랜($19/월) 혜택 및 비교표 확인\n4. \"구독하기\" 버튼 클릭\n5. 결제 정보 입력(/account/billing)\n6. 결제 완료 후 무제한 글 생성 가능\n\n## 3. 네비게이션 구조 (네비게이션 구조)\n\n### **글로벌 네비게이션 바 (GNB)**\n- **위치**: 상단 고정 (64px 높이)\n- **좌측**: ContentCraft AI 로고 (홈페이지 링크)\n- **우측**: 사용자 아바타 드롭다운 메뉴\n  - 내 계정(/account/profile)\n  - 결제 관리(/account/billing)\n  - 도움말(/docs)\n  - 로그아웃\n\n### **사이드 네비게이션 (Sidebar)**\n- **위치**: 좌측 고정 (280px 너비, 모바일에서 콜랩서블)\n- **메뉴 구조**:\n  - 대시보드 (/dashboard) - 홈 아이콘\n  - 새 글 작성 (/new) - 펜 아이콘\n  - 스타일 가이드 (/style-guides) - 팔레트 아이콘\n  - 계정 관리 (/account) - 설정 아이콘\n  - 도움말 (/docs) - 물음표 아이콘\n\n### **브레드크럼 네비게이션**\n- **표시 위치**: /new 페이지 내 상단\n- **구조**: 대시보드 > 새 글 작성 > [현재 단계]\n- **단계별**: 주제 설정 → AI 생성 → 편집 완성\n\n### **푸터 네비게이션**\n- **위치**: 페이지 하단 (인증 불필요 페이지만)\n- **메뉴**: 개인정보처리방침, 이용약관, 고객지원, 회사 소개\n\n## 4. 페이지 계층 구조 (페이지 계층 구조)\n\n```\n/ (Depth 1 - 루트)\n├── /auth (Depth 1 - 인증)\n│   ├── /auth/login (Depth 2)\n│   ├── /auth/signup (Depth 2)\n│   └── /auth/onboarding (Depth 2)\n├── /dashboard (Depth 1 - 메인 앱)\n│   ├── /dashboard/stats (Depth 2)\n│   └── /dashboard/history (Depth 2)\n├── /new (Depth 1 - 글 작성)\n│   ├── /new/setup (Depth 2)\n│   ├── /new/generate (Depth 2)\n│   └── /new/edit (Depth 2)\n├── /style-guides (Depth 1 - 스타일 관리)\n│   ├── /style-guides/list (Depth 2)\n│   ├── /style-guides/new (Depth 2)\n│   └── /style-guides/:id/edit (Depth 3)\n├── /account (Depth 1 - 계정)\n│   ├── /account/profile (Depth 2)\n│   ├── /account/billing (Depth 2)\n│   └── /account/usage (Depth 2)\n├── /docs (Depth 1 - 도움말)\n│   ├── /docs/getting-started (Depth 2)\n│   ├── /docs/features (Depth 2)\n│   └── /docs/faq (Depth 2)\n└── /pricing (Depth 1 - 가격)\n```\n\n## 5. 콘텐츠 구성 (콘텐츠 구성)\n\n| 페이지 | 핵심 콘텐츠 요소 |\n|--------|------------------|\n| 홈페이지(/) | 히어로 섹션, 핵심 가치 제안, 데모 영상, 기능 소개, 가격 정보, 사용자 후기, CTA 버튼 |\n| 대시보드(/dashboard) | 환영 메시지, 통계 카드(완성 글 수, 시간 절약), 월간 그래프, 최근 작성 이력, 새 글 작성 CTA |\n| 새 글 작성(/new) | 3컬럼 레이아웃: 입력 폼(키워드, 설명, 스타일 가이드), 실시간 미리보기, SEO 점검 패널 |\n| 스타일 가이드(/style-guides) | 가이드 카드 목록, 새 가이드 생성 버튼, 편집/삭제 액션, 미리보기 기능 |\n| 계정 관리(/account) | 탭 네비게이션(프로필/결제/사용량), 폼 필드, 구독 상태, 사용량 차트 |\n| 온보딩(/auth/onboarding) | 진행률 표시, 5단계 위저드, 브랜드 보이스 설정 폼, 실시간 미리보기 |\n\n## 6. 인터랙션 패턴 (인터랙션 패턴)\n\n### **모달 사용 패턴**\n- **확인 모달**: 삭제, 구독 취소 등 중요한 액션\n- **업그레이드 모달**: 무료 한도 초과 시 프로 플랜 안내\n- **설정 모달**: 계정 설정, 스타일 가이드 빠른 편집\n\n### **툴팁 패턴**\n- **도움말 툴팁**: 복잡한 기능 설명 (SEO 점수, 브랜드 보이스)\n- **상태 툴팁**: 진행 상황, 오류 메시지\n- **단축키 툴팁**: 키보드 단축키 안내\n\n### **인라인 편집 패턴**\n- **문단별 재생성**: 각 문단에 재생성 버튼\n- **제목 편집**: 클릭하여 즉시 편집 모드\n- **실시간 저장**: 변경사항 자동 저장\n\n### **피드백 패턴**\n- **토스트 알림**: 성공/오류 메시지, 4초 자동 닫힘\n- **프로그레스 바**: AI 생성 진행률, SEO 점수\n- **스켈레톤 로딩**: 콘텐츠 로딩 중 레이아웃 유지\n\n### **리스트 인터랙션**\n- **무한 스크롤**: 작성 이력, 스타일 가이드 목록\n- **필터링**: 날짜별, 상태별 필터\n- **검색**: 실시간 검색 결과\n\n## 7. URL 구조 (URL 구조)\n\n### **URL 명명 규칙**\n- **일반 리소스**: `/resource-name` (소문자, 하이픈 구분)\n- **상세 페이지**: `/resource-name/:id`\n- **편집 페이지**: `/resource-name/:id/edit`\n- **중첩 리소스**: `/parent/child`\n\n### **구체적 URL 구조**\n```\n/ - 홈페이지\n/auth/login - 로그인\n/auth/signup - 회원가입\n/auth/onboarding - 온보딩\n\n/dashboard - 대시보드 메인\n/dashboard/stats - 통계 상세\n/dashboard/history - 작성 이력\n\n/new - 새 글 작성 (단일 페이지, 단계별 UI)\n/new?step=setup - 주제 설정 단계\n/new?step=generate - 생성 단계  \n/new?step=edit - 편집 단계\n\n/style-guides - 스타일 가이드 목록\n/style-guides/new - 새 가이드 생성\n/style-guides/[id] - 가이드 상세보기\n/style-guides/[id]/edit - 가이드 편집\n\n/account - 계정 관리 메인\n/account/profile - 프로필 설정\n/account/billing - 결제 관리\n/account/usage - 사용량 현황\n\n/docs - 도움말 메인\n/docs/getting-started - 시작 가이드\n/docs/features - 기능 설명\n/docs/faq - 자주 묻는 질문\n\n/pricing - 가격 정책\n```\n\n### **SEO 최적화**\n- **의미있는 URL**: 기능과 내용을 명확히 표현\n- **일관성**: 동일한 패턴 유지\n- **계층 구조**: 논리적 깊이 관계\n\n## 8. 컴포넌트 계층 구조 (컴포넌트 계층 구조)\n\n### **글로벌 컴포넌트**\n- **Layout**\n  - `TopNavigation` - 상단 네비게이션 바\n  - `Sidebar` - 좌측 사이드바 메뉴\n  - `Footer` - 하단 푸터 (퍼블릭 페이지만)\n- **UI 기본 컴포넌트**\n  - `Button` - Primary, Secondary, Ghost 버튼\n  - `Input` - 텍스트 입력, 텍스트에리어, 셀렉트\n  - `Card` - 콘텐츠 카드, 통계 카드\n  - `Modal` - 확인, 업그레이드, 설정 모달\n  - `Toast` - 알림 메시지\n  - `Tooltip` - 도움말 툴팁\n\n### **페이지별 특화 컴포넌트**\n\n#### **대시보드 컴포넌트**\n- `StatsCard` - 완성 글 수, 시간 절약 통계\n- `ActivityChart` - 월간 활동 그래프\n- `RecentPosts` - 최근 작성 글 목록\n- `QuickActions` - 빠른 작업 버튼들\n\n#### **글 작성 컴포넌트**\n- `ContentEditor` - 3컬럼 편집기 레이아웃\n  - `InputPanel` - 키워드, 설명 입력 영역\n  - `PreviewPanel` - 실시간 미리보기\n  - `SEOPanel` - SEO 점검 및 최적화 도구\n- `ParagraphRegenerate` - 문단별 재생성 버튼\n- `ProgressTracker` - 생성 진행률 표시\n- `ExportOptions` - 마크다운 다운로드/복사\n\n#### **스타일 가이드 컴포넌트**\n- `StyleGuideCard` - 가이드 카드 아이템\n- `StyleGuideForm` - 가이드 생성/편집 폼\n- `BrandVoicePreview` - 브랜드 보이스 미리보기\n- `GuideTemplates` - 템플릿 선택기\n\n#### **온보딩 컴포넌트**\n- `OnboardingWizard` - 5단계 위저드 컨테이너\n- `StepIndicator` - 진행률 표시\n- `BrandVoiceForm` - 브랜드 보이스 설정 폼\n- `PreviewGenerator` - 실시간 샘플 생성\n\n#### **계정 관리 컴포넌트**\n- `ProfileForm` - 프로필 정보 편집\n- `BillingCard` - 구독 정보 및 결제 관리\n- `UsageChart` - 사용량 현황 차트\n- `PlanComparison` - 플랜 비교 테이블\n\n### **상태 관리 컴포넌트**\n- `LoadingSpinner` - 로딩 스피너\n- `SkeletonLoader` - 스켈레톤 로딩 UI\n- `EmptyState` - 빈 상태 일러스트레이션\n- `ErrorBoundary` - 오류 처리 경계\n\n### **반응형 컴포넌트**\n- `MobileNavigation` - 모바일 햄버거 메뉴\n- `ResponsiveLayout` - 화면 크기별 레이아웃 전환\n- `CollapsibleSidebar` - 접을 수 있는 사이드바\n- `TabletOptimized` - 태블릿 최적화 컴포넌트\n\n### **접근성 컴포넌트**\n- `SkipLink` - 키보드 네비게이션용 스킵 링크\n- `FocusTrap` - 모달 내 포커스 트랩\n- `ScreenReaderOnly` - 스크린 리더 전용 텍스트\n- `KeyboardShortcuts` - 단축키 처리\n\n이 정보 아키텍처는 MVP 출시를 위한 핵심 구조를 정의하며, 사용자 경험을 최적화하고 개발 효율성을 높이는 것을 목표로 합니다.",
      "writedAt": "2025-11-08T10:13:52.019Z"
    },
    {
      "type": "step-by-step",
      "content": "\n## Core Directive\nYou are a senior software engineer AI assistant. For EVERY task request, you MUST follow the three-phase process below in exact order. Each phase must be completed with expert-level precision and detail.\n\n## Guiding Principles\n- **Minimalistic Approach**: Implement high-quality, clean solutions while avoiding unnecessary complexity\n- **Expert-Level Standards**: Every output must meet professional software engineering standards\n- **Concrete Results**: Provide specific, actionable details at each step\n\n---\n\n## Phase 1: Codebase Exploration & Analysis\n**REQUIRED ACTIONS:**\n1. **Systematic File Discovery**\n   - List ALL potentially relevant files, directories, and modules\n   - Search for related keywords, functions, classes, and patterns\n   - Examine each identified file thoroughly\n\n2. **Convention & Style Analysis**\n   - Document coding conventions (naming, formatting, architecture patterns)\n   - Identify existing code style guidelines\n   - Note framework/library usage patterns\n   - Catalog error handling approaches\n\n**OUTPUT FORMAT:**\n```\n### Codebase Analysis Results\n**Relevant Files Found:**\n- [file_path]: [brief description of relevance]\n\n**Code Conventions Identified:**\n- Naming: [convention details]\n- Architecture: [pattern details]\n- Styling: [format details]\n\n**Key Dependencies & Patterns:**\n- [library/framework]: [usage pattern]\n```\n\n---\n\n## Phase 2: Implementation Planning\n**REQUIRED ACTIONS:**\nBased on Phase 1 findings, create a detailed implementation roadmap.\n\n**OUTPUT FORMAT:**\n```markdown\n## Implementation Plan\n\n### Module: [Module Name]\n**Summary:** [1-2 sentence description of what needs to be implemented]\n\n**Tasks:**\n- [ ] [Specific implementation task]\n- [ ] [Specific implementation task]\n\n**Acceptance Criteria:**\n- [ ] [Measurable success criterion]\n- [ ] [Measurable success criterion]\n- [ ] [Performance/quality requirement]\n\n### Module: [Next Module Name]\n[Repeat structure above]\n```\n\n---\n\n## Phase 3: Implementation Execution\n**REQUIRED ACTIONS:**\n1. Implement each module following the plan from Phase 2\n2. Verify ALL acceptance criteria are met before proceeding\n3. Ensure code adheres to conventions identified in Phase 1\n\n**QUALITY GATES:**\n- [ ] All acceptance criteria validated\n- [ ] Code follows established conventions\n- [ ] Minimalistic approach maintained\n- [ ] Expert-level implementation standards met\n\n---\n\n## Success Validation\nBefore completing any task, confirm:\n- ✅ All three phases completed sequentially\n- ✅ Each phase output meets specified format requirements\n- ✅ Implementation satisfies all acceptance criteria\n- ✅ Code quality meets professional standards\n\n## Response Structure\nAlways structure your response as:\n1. **Phase 1 Results**: [Codebase analysis findings]\n2. **Phase 2 Plan**: [Implementation roadmap]  \n3. **Phase 3 Implementation**: [Actual code with validation]\n",
      "writedAt": "2025-11-08T10:13:52.019Z"
    },
    {
      "type": "clean-code",
      "content": "\n# Clean Code Guidelines\n\nYou are an expert software engineer focused on writing clean, maintainable code. Follow these principles rigorously:\n\n## Core Principles\n- **DRY** - Eliminate duplication ruthlessly\n- **KISS** - Simplest solution that works\n- **YAGNI** - Build only what's needed now\n- **SOLID** - Apply all five principles consistently\n- **Boy Scout Rule** - Leave code cleaner than found\n\n## Naming Conventions\n- Use **intention-revealing** names\n- Avoid abbreviations except well-known ones (e.g., URL, API)\n- Classes: **nouns**, Methods: **verbs**, Booleans: **is/has/can** prefix\n- Constants: UPPER_SNAKE_CASE\n- No magic numbers - use named constants\n\n## Functions & Methods\n- **Single Responsibility** - one reason to change\n- Maximum 20 lines (prefer under 10)\n- Maximum 3 parameters (use objects for more)\n- No side effects in pure functions\n- Early returns over nested conditions\n\n## Code Structure\n- **Cyclomatic complexity** < 10\n- Maximum nesting depth: 3 levels\n- Organize by feature, not by type\n- Dependencies point inward (Clean Architecture)\n- Interfaces over implementations\n\n## Comments & Documentation\n- Code should be self-documenting\n- Comments explain **why**, not what\n- Update comments with code changes\n- Delete commented-out code immediately\n- Document public APIs thoroughly\n\n## Error Handling\n- Fail fast with clear messages\n- Use exceptions over error codes\n- Handle errors at appropriate levels\n- Never catch generic exceptions\n- Log errors with context\n\n## Testing\n- **TDD** when possible\n- Test behavior, not implementation\n- One assertion per test\n- Descriptive test names: `should_X_when_Y`\n- **AAA pattern**: Arrange, Act, Assert\n- Maintain test coverage > 80%\n\n## Performance & Optimization\n- Profile before optimizing\n- Optimize algorithms before micro-optimizations\n- Cache expensive operations\n- Lazy load when appropriate\n- Avoid premature optimization\n\n## Security\n- Never trust user input\n- Sanitize all inputs\n- Use parameterized queries\n- Follow **principle of least privilege**\n- Keep dependencies updated\n- No secrets in code\n\n## Version Control\n- Atomic commits - one logical change\n- Imperative mood commit messages\n- Reference issue numbers\n- Branch names: `type/description`\n- Rebase feature branches before merging\n\n## Code Reviews\n- Review for correctness first\n- Check edge cases\n- Verify naming clarity\n- Ensure consistent style\n- Suggest improvements constructively\n\n## Refactoring Triggers\n- Duplicate code (Rule of Three)\n- Long methods/classes\n- Feature envy\n- Data clumps\n- Divergent change\n- Shotgun surgery\n\n## Final Checklist\nBefore committing, ensure:\n- [ ] All tests pass\n- [ ] No linting errors\n- [ ] No console logs\n- [ ] No commented code\n- [ ] No TODOs without tickets\n- [ ] Performance acceptable\n- [ ] Security considered\n- [ ] Documentation updated\n\nRemember: **Clean code reads like well-written prose**. Optimize for readability and maintainability over cleverness.\n",
      "writedAt": "2025-11-08T10:13:52.019Z"
    }
  ]
}
</file>

<file path=".vooster/vooster.json">
{
  "apiKey": "ak_brgywk8cnw7tdfpmh9ui45yl",
  "email": "lead@awesome.dev",
  "savedAt": "2025-11-08T10:13:51.791Z"
}
</file>

<file path="e2e/example.spec.ts">
import { test, expect } from '@playwright/test';

test.describe('Example Feature', () => {
  test.beforeEach(async ({ page }) => {
    await page.goto('/example');
  });

  test('should render the example page correctly', async ({ page }) => {
    // 페이지 제목 확인
    await expect(page.getByRole('heading', { name: /Backend Health Check/i })).toBeVisible();

    // 설명 텍스트 확인
    await expect(page.getByText(/예시 API/i)).toBeVisible();

    // 입력 필드 확인
    const input = page.getByPlaceholder(/00000000-0000-0000-0000-000000000000/i);
    await expect(input).toBeVisible();

    // 조회 버튼 확인
    const button = page.getByRole('button', { name: /조회하기/i });
    await expect(button).toBeVisible();

    // 초기 상태는 Idle
    await expect(page.getByText(/Idle/i)).toBeVisible();
  });

  test('should show idle message when no ID is provided', async ({ page }) => {
    // 초기 상태 메시지 확인
    await expect(page.getByText(/UUID를 입력하고 조회하기 버튼을 누르면/i)).toBeVisible();

    // Idle 상태 뱃지 확인
    await expect(page.getByText(/Idle/i)).toBeVisible();
  });

  test('should clear results when empty input is submitted', async ({ page }) => {
    const input = page.getByPlaceholder(/00000000-0000-0000-0000-000000000000/i);
    const button = page.getByRole('button', { name: /조회하기/i });

    // 빈 문자열 입력
    await input.fill('   ');
    await button.click();

    // Idle 상태로 돌아가는지 확인
    await expect(page.getByText(/Idle/i)).toBeVisible();
    await expect(page.getByText(/UUID를 입력하고 조회하기 버튼을 누르면/i)).toBeVisible();
  });

  test('should show error for invalid UUID', async ({ page }) => {
    const input = page.getByPlaceholder(/00000000-0000-0000-0000-000000000000/i);
    const button = page.getByRole('button', { name: /조회하기/i });

    // 잘못된 UUID 입력
    await input.fill('invalid-uuid-format');
    await button.click();

    // Error 상태 뱃지 확인
    await expect(page.getByText(/Error/i).first()).toBeVisible({ timeout: 10000 });

    // 에러 메시지 확인
    await expect(page.getByText(/요청 실패/i)).toBeVisible();
  });

  test('should handle loading state', async ({ page }) => {
    const input = page.getByPlaceholder(/00000000-0000-0000-0000-000000000000/i);
    const button = page.getByRole('button', { name: /조회하기/i });

    // 임의의 UUID 입력 (느린 응답을 시뮬레이션하기 위해)
    await input.fill('00000000-0000-0000-0000-000000000001');
    await button.click();

    // Fetching 상태가 나타나는지 확인 (빠르게 지나갈 수 있음)
    const fetchingOrError = page.getByText(/Fetching|Error/i).first();
    await expect(fetchingOrError).toBeVisible({ timeout: 10000 });
  });

  test('should allow refetch with same ID', async ({ page }) => {
    const input = page.getByPlaceholder(/00000000-0000-0000-0000-000000000000/i);
    const button = page.getByRole('button', { name: /조회하기/i });

    const testId = 'test-id-12345';

    // 첫 번째 조회
    await input.fill(testId);
    await button.click();

    // 결과 대기
    await expect(page.getByText(/Error|Success/i).first()).toBeVisible({ timeout: 10000 });

    // 같은 ID로 다시 조회
    await button.click();

    // 다시 Fetching 상태가 되는지 확인
    await expect(page.getByText(/Fetching|Error|Success/i).first()).toBeVisible({ timeout: 10000 });
  });

  test('should display result sections correctly', async ({ page }) => {
    // 현재 상태 섹션 확인
    await expect(page.getByRole('heading', { name: /현재 상태/i })).toBeVisible();

    // 결과 표시 영역이 존재하는지 확인
    const resultSection = page.locator('article').filter({ hasText: /현재 상태/ });
    await expect(resultSection).toBeVisible();
  });
});
</file>

<file path="scripts/check-env.ts">
import 'dotenv/config';

async function checkEnv() {
  try {
    // Import env.ts to trigger validation
    await import('../src/constants/env.js');
    console.log('✅ Environment variables are valid!');
    process.exit(0);
  } catch (error) {
    console.error('❌ Environment validation failed:');
    if (error instanceof Error) {
      console.error(error.message);
    } else {
      console.error(error);
    }
    process.exit(1);
  }
}

checkEnv();
</file>

<file path="scripts/test-env-check.sh">
#!/bin/bash

echo "🧪 Running Acceptance Tests for env:check"
echo ""

# Setup
BACKUP_FILE=".env.local.backup"
[ -f .env.local ] && cp .env.local $BACKUP_FILE

PASS_COUNT=0
FAIL_COUNT=0

# Test 1: Valid env
echo "Test 1: Valid environment variables"
cat > .env.local << EOF
NEXT_PUBLIC_SUPABASE_URL=https://test.supabase.co
NEXT_PUBLIC_SUPABASE_ANON_KEY=eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.test
SUPABASE_URL=https://test.supabase.co
SUPABASE_SERVICE_ROLE_KEY=eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.service
EOF

if npm run env:check > /dev/null 2>&1; then
  echo "✅ PASS: Valid env detected"
  ((PASS_COUNT++))
else
  echo "❌ FAIL: Valid env should pass"
  ((FAIL_COUNT++))
fi
echo ""

# Test 2: Missing vars
echo "Test 2: Missing environment variables"
cat > .env.local << EOF
NEXT_PUBLIC_SUPABASE_URL=https://test.supabase.co
EOF

if npm run env:check > /dev/null 2>&1; then
  echo "❌ FAIL: Missing vars should fail"
  ((FAIL_COUNT++))
else
  echo "✅ PASS: Missing vars detected"
  ((PASS_COUNT++))
fi
echo ""

# Test 3: No file
echo "Test 3: No .env.local file"
rm -f .env.local

if npm run env:check > /dev/null 2>&1; then
  echo "❌ FAIL: No file should fail"
  ((FAIL_COUNT++))
else
  echo "✅ PASS: No file detected"
  ((PASS_COUNT++))
fi
echo ""

# Test 4: Invalid URL format
echo "Test 4: Invalid URL format"
cat > .env.local << EOF
NEXT_PUBLIC_SUPABASE_URL=not-a-valid-url
NEXT_PUBLIC_SUPABASE_ANON_KEY=eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.test
SUPABASE_URL=not-a-valid-url
SUPABASE_SERVICE_ROLE_KEY=eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.service
EOF

if npm run env:check > /dev/null 2>&1; then
  echo "❌ FAIL: Invalid URL should fail"
  ((FAIL_COUNT++))
else
  echo "✅ PASS: Invalid URL detected"
  ((PASS_COUNT++))
fi
echo ""

# Cleanup
[ -f $BACKUP_FILE ] && mv $BACKUP_FILE .env.local || rm -f .env.local

echo "━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━"
echo "🎉 Acceptance tests complete!"
echo "   Passed: $PASS_COUNT"
echo "   Failed: $FAIL_COUNT"
echo "━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━"

if [ $FAIL_COUNT -eq 0 ]; then
  exit 0
else
  exit 1
fi
</file>

<file path="src/app/(protected)/account/page.tsx">
"use client";

type AccountPageProps = {
  params: Promise<Record<string, never>>;
};

export default function AccountPage({ params }: AccountPageProps) {
  void params;

  return (
    <div className="flex flex-col gap-4">
      <h1 className="text-3xl font-bold">계정 관리</h1>
      <p className="text-muted-foreground">
        이 페이지는 추후 구현될 예정입니다.
      </p>
    </div>
  );
}
</file>

<file path="src/app/(protected)/style-guides/[id]/edit/page.tsx">
"use client";

import { use } from "react";
import { useRouter } from "next/navigation";
import { useQuery } from "@tanstack/react-query";
import { Button } from "@/components/ui/button";
import { ArrowLeft, Loader2 } from "lucide-react";
import { useToast } from "@/hooks/use-toast";
import { OnboardingWizard } from "@/features/onboarding/components/onboarding-wizard";
import { updateStyleGuideAction } from "@/features/articles/actions/article-actions";
import type { StyleGuideResponse } from "@/features/onboarding/backend/schema";
import type { OnboardingFormData } from "@/features/onboarding/lib/onboarding-schema";
import { getUserStyleGuide } from "@/features/articles/actions/article-actions";

type EditStyleGuidePageProps = {
  params: Promise<{ id: string }>;
};

export default function EditStyleGuidePage({
  params,
}: EditStyleGuidePageProps) {
  const resolvedParams = use(params);
  const guideId = resolvedParams.id;
  const router = useRouter();
  const { toast } = useToast();

  // Fetch current style guide
  const { data: guide, isLoading, isError } = useQuery<StyleGuideResponse | null>({
    queryKey: ["userStyleGuide", guideId],
    queryFn: getUserStyleGuide,
    retry: false,
  });

  const handleComplete = async (data: OnboardingFormData) => {
    try {
      await updateStyleGuideAction(guideId, data);

      toast({
        title: "성공",
        description: "스타일 가이드가 업데이트되었습니다.",
      });

      // Redirect to style guides page
      router.push("/style-guides");
    } catch (error) {
      console.error("Failed to update style guide:", error);
      toast({
        title: "오류",
        description:
          error instanceof Error
            ? error.message
            : "스타일 가이드 업데이트에 실패했습니다.",
        variant: "destructive",
      });
    }
  };

  if (isLoading) {
    return (
      <div className="min-h-screen" style={{ backgroundColor: "#FCFCFD" }}>
        <div className="container mx-auto max-w-4xl px-4 py-8">
          <div className="flex items-center justify-center min-h-[400px]">
            <div className="flex flex-col items-center gap-4">
              <Loader2 className="h-8 w-8 animate-spin text-primary" />
              <p className="text-muted-foreground">로딩 중...</p>
            </div>
          </div>
        </div>
      </div>
    );
  }

  if (isError || !guide) {
    return (
      <div className="min-h-screen" style={{ backgroundColor: "#FCFCFD" }}>
        <div className="container mx-auto max-w-4xl px-4 py-8">
          <div className="flex flex-col items-center justify-center min-h-[400px] gap-4">
            <p className="text-red-500">스타일 가이드를 불러오는 데 실패했습니다.</p>
            <Button onClick={() => router.back()}>뒤로</Button>
          </div>
        </div>
      </div>
    );
  }

  // Prepare initial values from fetched guide
  const initialValues: OnboardingFormData = {
    brandName: guide.brandName,
    brandDescription: guide.brandDescription,
    personality: guide.personality || [],
    formality: guide.formality,
    targetAudience: guide.targetAudience,
    painPoints: guide.painPoints,
    language: guide.language,
    tone: guide.tone,
    contentLength: guide.contentLength,
    readingLevel: guide.readingLevel,
    notes: guide.notes || "",
  };

  return (
    <div className="min-h-screen" style={{ backgroundColor: "#FCFCFD" }}>
      {/* 뒤로 버튼 */}
      <div className="container mx-auto max-w-4xl px-4 py-4">
        <Button
          variant="ghost"
          onClick={() => router.back()}
          className="mb-6"
        >
          <ArrowLeft className="mr-2 h-4 w-4" />
          뒤로
        </Button>
      </div>

      {/* 마법사 - 수정 모드 */}
      {/* 마법사 컴포넌트는 수정 모드에서 initialValues를 지원하지 않으므로
          여기서는 간단한 메시지를 표시합니다 */}
      <div className="container mx-auto max-w-4xl px-4 py-8">
        <div className="rounded-lg border p-6" style={{ borderColor: "#E1E5EA" }}>
          <h1 className="text-2xl font-bold mb-4" style={{ color: "#1F2937" }}>
            스타일 가이드 편집
          </h1>
          <p className="text-muted-foreground mb-6">
            현재 스타일 가이드를 다시 생성하려면 새 가이드 생성 페이지로 이동하세요.
          </p>
          <div className="flex gap-2">
            <Button onClick={() => router.push("/style-guides/new")}>
              새 가이드 생성
            </Button>
            <Button variant="outline" onClick={() => router.back()}>
              취소
            </Button>
          </div>
        </div>
      </div>
    </div>
  );
}
</file>

<file path="src/app/(protected)/style-guides/new/page.tsx">
"use client";

import { useRouter } from "next/navigation";
import { useToast } from "@/hooks/use-toast";
import { Button } from "@/components/ui/button";
import { ArrowLeft } from "lucide-react";
import { OnboardingWizard } from "@/features/onboarding/components/onboarding-wizard";
import { createStyleGuide } from "@/features/onboarding/actions/create-style-guide";
import type { OnboardingFormData } from "@/features/onboarding/lib/onboarding-schema";

type NewStyleGuidePageProps = {
  params: Promise<Record<string, never>>;
};

export default function NewStyleGuidePage({
  params,
}: NewStyleGuidePageProps) {
  void params;
  const router = useRouter();
  const { toast } = useToast();

  const handleComplete = async (data: OnboardingFormData) => {
    try {
      const result = await createStyleGuide(data);

      toast({
        title: "성공",
        description: "스타일 가이드가 생성되었습니다.",
      });

      // Redirect to style guides page
      router.push("/style-guides");
    } catch (error) {
      console.error("Failed to create style guide:", error);
      toast({
        title: "오류",
        description:
          error instanceof Error
            ? error.message
            : "스타일 가이드 생성에 실패했습니다.",
        variant: "destructive",
      });
    }
  };

  return (
    <div className="min-h-screen" style={{ backgroundColor: "#FCFCFD" }}>
      {/* 뒤로 버튼 */}
      <div className="container mx-auto max-w-4xl px-4 py-4">
        <Button
          variant="ghost"
          onClick={() => router.back()}
          className="mb-6"
        >
          <ArrowLeft className="mr-2 h-4 w-4" />
          뒤로
        </Button>
      </div>

      {/* 마법사 */}
      <OnboardingWizard onComplete={handleComplete} />
    </div>
  );
}
</file>

<file path="src/app/(public)/layout.tsx">
import { ClerkProvider } from "@clerk/nextjs";
import { loadCurrentUser } from "@/features/auth/server/load-current-user";
import { CurrentUserProvider } from "@/features/auth/context/current-user-context";

/**
 * Public Layout
 *
 * This layout wraps public pages (like homepage) with optional authentication.
 * Unlike protected routes, these pages can be accessed without authentication,
 * but still provide user context if the user is logged in.
 */
export default async function PublicLayout({
  children,
}: {
  children: React.ReactNode;
}) {
  // Load current user (will return unauthenticated if not logged in)
  const currentUser = await loadCurrentUser();

  return (
    <ClerkProvider>
      <CurrentUserProvider initialState={currentUser}>
        {children}
      </CurrentUserProvider>
    </ClerkProvider>
  );
}
</file>

<file path="src/app/api/[[...hono]]/route.ts">
import { handle } from 'hono/vercel';
import { createHonoApp } from '@/backend/hono/app';

const app = createHonoApp();

export const GET = handle(app);
export const POST = handle(app);
export const PUT = handle(app);
export const PATCH = handle(app);
export const DELETE = handle(app);
export const OPTIONS = handle(app);

export const runtime = 'nodejs';
</file>

<file path="src/app/auth/onboarding/_actions.ts">
"use server";

import { auth, clerkClient } from "@clerk/nextjs/server";

/**
 * 온보딩 완료 처리 서버 액션
 * 사용자의 publicMetadata에 onboardingCompleted를 true로 설정
 */
export async function completeOnboarding() {
  try {
    const { userId } = await auth();

    if (!userId) {
      return {
        success: false,
        error: "인증되지 않은 사용자입니다.",
      };
    }

    // Clerk 클라이언트를 사용하여 사용자 메타데이터 업데이트
    const client = await clerkClient();
    await client.users.updateUser(userId, {
      publicMetadata: {
        onboardingCompleted: true,
      },
    });

    return {
      success: true,
      message: "온보딩이 완료되었습니다.",
    };
  } catch (error) {
    console.error("온보딩 완료 처리 중 오류:", error);
    return {
      success: false,
      error: "온보딩 완료 처리 중 오류가 발생했습니다.",
    };
  }
}
</file>

<file path="src/app/auth/layout.tsx">
import { ClerkProvider } from "@clerk/nextjs";

/**
 * Auth Layout
 *
 * Wraps all auth-related pages with ClerkProvider.
 * Includes: /auth/onboarding, /auth/after, etc.
 */
export default function AuthLayout({
  children,
}: {
  children: React.ReactNode;
}) {
  return <ClerkProvider>{children}</ClerkProvider>;
}
</file>

<file path="src/app/example/page.tsx">
'use client';

import { ExampleStatus } from '@/features/example/components/example-status';

export default function ExamplePage() {
  return (
    <div className="min-h-screen bg-gradient-to-b from-slate-950 via-slate-900 to-slate-950 px-6 py-16 text-slate-100">
      <ExampleStatus />
    </div>
  );
}
</file>

<file path="src/app/sign-in/[[...sign-in]]/layout.tsx">
import { ClerkProvider } from "@clerk/nextjs";

/**
 * Sign In Layout
 *
 * Wraps the sign-in page with ClerkProvider.
 */
export default function SignInLayout({
  children,
}: {
  children: React.ReactNode;
}) {
  return <ClerkProvider>{children}</ClerkProvider>;
}
</file>

<file path="src/app/sign-up/[[...sign-up]]/layout.tsx">
import { ClerkProvider } from "@clerk/nextjs";

/**
 * Sign Up Layout
 *
 * Wraps the sign-up page with ClerkProvider.
 */
export default function SignUpLayout({
  children,
}: {
  children: React.ReactNode;
}) {
  return <ClerkProvider>{children}</ClerkProvider>;
}
</file>

<file path="src/backend/http/response.ts">
import type { ContentfulStatusCode } from 'hono/utils/http-status';
import type { AppContext } from '@/backend/hono/context';

export type SuccessResult<TData> = {
  ok: true;
  status: ContentfulStatusCode;
  data: TData;
};

export type ErrorResult<TCode extends string, TDetails = unknown> = {
  ok: false;
  status: ContentfulStatusCode;
  error: {
    code: TCode;
    message: string;
    details?: TDetails;
  };
};

export type HandlerResult<TData, TCode extends string, TDetails = unknown> =
  | SuccessResult<TData>
  | ErrorResult<TCode, TDetails>;

export const success = <TData>(
  data: TData,
  status: ContentfulStatusCode = 200,
): SuccessResult<TData> => ({
  ok: true,
  status,
  data,
});

export const failure = <TCode extends string, TDetails = unknown>(
  status: ContentfulStatusCode,
  code: TCode,
  message: string,
  details?: TDetails,
): ErrorResult<TCode, TDetails> => ({
  ok: false,
  status,
  error: {
    code,
    message,
    ...(details === undefined ? {} : { details }),
  },
});

export const respond = <TData, TCode extends string, TDetails = unknown>(
  c: AppContext,
  result: HandlerResult<TData, TCode, TDetails>,
) => {
  if (result.ok) {
    return c.json(result.data, result.status);
  }

  const errorResult = result as ErrorResult<TCode, TDetails>;

  return c.json(
    {
      error: errorResult.error,
    },
    errorResult.status,
  );
};
</file>

<file path="src/backend/middleware/context.ts">
import { createMiddleware } from 'hono/factory';
import { getAppConfig } from '@/backend/config';
import {
  contextKeys,
  type AppEnv,
  type AppLogger,
} from '@/backend/hono/context';

const logger: AppLogger = {
  info: (...args) => console.info(...args),
  error: (...args) => console.error(...args),
  warn: (...args) => console.warn(...args),
  debug: (...args) => console.debug(...args),
};

export const withAppContext = () => {
  const config = getAppConfig();

  return createMiddleware<AppEnv>(async (c, next) => {
    c.set(contextKeys.logger, logger);
    c.set(contextKeys.config, config);

    await next();
  });
};
</file>

<file path="src/backend/middleware/error.ts">
import { createMiddleware } from 'hono/factory';
import { match, P } from 'ts-pattern';
import {
  contextKeys,
  type AppEnv,
  type AppLogger,
} from '@/backend/hono/context';

export const errorBoundary = () =>
  createMiddleware<AppEnv>(async (c, next) => {
    try {
      await next();
    } catch (error) {
      const logger = c.get(contextKeys.logger) as AppLogger | undefined;
      const message = match(error)
        .with(P.instanceOf(Error), (err) => err.message)
        .otherwise(() => 'Unexpected error');

      logger?.error?.(error);

      return c.json(
        {
          error: {
            code: 'INTERNAL_SERVER_ERROR',
            message,
          },
        },
        500,
      );
    }
  });
</file>

<file path="src/backend/middleware/supabase.ts">
import { createMiddleware } from 'hono/factory';
import {
  contextKeys,
  type AppEnv,
} from '@/backend/hono/context';
import { createServiceClient } from '@/backend/supabase/client';

export const withSupabase = () =>
  createMiddleware<AppEnv>(async (c, next) => {
    const config = c.get(
      contextKeys.config,
    ) as AppEnv['Variables']['config'] | undefined;

    if (!config) {
      throw new Error('Application configuration is not available.');
    }

    const client = createServiceClient(config.supabase);

    c.set(contextKeys.supabase, client);

    await next();
  });
</file>

<file path="src/backend/supabase/client.ts">
import { createClient } from '@supabase/supabase-js';
import type { SupabaseClient } from '@supabase/supabase-js';

export type ServiceClientConfig = {
  url: string;
  serviceRoleKey: string;
};

export const createServiceClient = ({
  url,
  serviceRoleKey,
}: ServiceClientConfig): SupabaseClient =>
  createClient(url, serviceRoleKey, {
    auth: {
      persistSession: false,
    },
  });
</file>

<file path="src/components/brand/logo.tsx">
import Link from "next/link";

type LogoProps = {
  className?: string;
  showText?: boolean;
};

export function Logo({ className = "", showText = true }: LogoProps) {
  return (
    <Link href="/" className={`flex items-center gap-2 ${className}`}>
      <div className="flex h-8 w-8 items-center justify-center rounded-lg bg-gradient-to-br from-[#3BA2F8] to-[#2680D0]">
        <span className="text-lg font-bold text-white">C</span>
      </div>
      {showText && (
        <span className="text-xl font-bold text-gray-900">ContentCraft AI</span>
      )}
    </Link>
  );
}
</file>

<file path="src/components/dashboard/activity-chart.tsx">
"use client";

import { Card, CardContent, CardHeader, CardTitle } from "@/components/ui/card";

export function ActivityChart() {
  return (
    <Card>
      <CardHeader>
        <CardTitle>월간 활동 그래프</CardTitle>
      </CardHeader>
      <CardContent>
        <div className="flex h-64 items-center justify-center rounded-lg border-2 border-dashed border-muted-foreground/25">
          <p className="text-sm text-muted-foreground">
            차트 라이브러리(예: Recharts)가 여기에 표시됩니다
          </p>
        </div>
      </CardContent>
    </Card>
  );
}
</file>

<file path="src/components/dashboard/recent-articles-list.tsx">
"use client";

import { Card, CardContent, CardHeader, CardTitle } from "@/components/ui/card";
import {
  Table,
  TableBody,
  TableCell,
  TableHead,
  TableHeader,
  TableRow,
} from "@/components/ui/table";
import { Badge } from "@/components/ui/badge";
import { Button } from "@/components/ui/button";
import { Eye, Pencil } from "lucide-react";

type Article = {
  id: string;
  title: string;
  status: "완료" | "작성중";
  createdAt: string;
};

const dummyArticles: Article[] = [
  {
    id: "1",
    title: "Next.js 15의 새로운 기능 살펴보기",
    status: "완료",
    createdAt: "2025-11-05",
  },
  {
    id: "2",
    title: "AI를 활용한 콘텐츠 마케팅 전략",
    status: "완료",
    createdAt: "2025-11-03",
  },
  {
    id: "3",
    title: "인디해커를 위한 SEO 최적화 가이드",
    status: "완료",
    createdAt: "2025-11-01",
  },
  {
    id: "4",
    title: "SaaS 제품의 성장 해킹 전략",
    status: "작성중",
    createdAt: "2025-10-28",
  },
];

export function RecentArticlesList() {
  return (
    <Card>
      <CardHeader>
        <CardTitle>최근 작성한 글</CardTitle>
      </CardHeader>
      <CardContent>
        <Table>
          <TableHeader>
            <TableRow>
              <TableHead>상태</TableHead>
              <TableHead>제목</TableHead>
              <TableHead>생성일</TableHead>
              <TableHead className="text-right">액션</TableHead>
            </TableRow>
          </TableHeader>
          <TableBody>
            {dummyArticles.map((article) => (
              <TableRow key={article.id}>
                <TableCell>
                  <Badge
                    variant={
                      article.status === "완료" ? "default" : "secondary"
                    }
                  >
                    {article.status}
                  </Badge>
                </TableCell>
                <TableCell className="font-medium">{article.title}</TableCell>
                <TableCell>{article.createdAt}</TableCell>
                <TableCell className="text-right">
                  <div className="flex justify-end gap-2">
                    <Button variant="ghost" size="icon">
                      <Eye className="h-4 w-4" />
                    </Button>
                    <Button variant="ghost" size="icon">
                      <Pencil className="h-4 w-4" />
                    </Button>
                  </div>
                </TableCell>
              </TableRow>
            ))}
          </TableBody>
        </Table>
      </CardContent>
    </Card>
  );
}
</file>

<file path="src/components/dashboard/stats-cards.tsx">
"use client";

import {
  Card,
  CardContent,
  CardDescription,
  CardHeader,
  CardTitle,
} from "@/components/ui/card";
import { FileText, Clock } from "lucide-react";

type StatsCardsProps = {
  monthlyArticles?: number;
  monthlyGoal?: number;
  savedHours?: number;
};

export function StatsCards({
  monthlyArticles = 4,
  monthlyGoal = 10,
  savedHours = 8,
}: StatsCardsProps) {
  const achievementRate = Math.round((monthlyArticles / monthlyGoal) * 100);

  return (
    <div className="grid grid-cols-1 gap-4 md:grid-cols-2">
      <Card>
        <CardHeader className="flex flex-row items-center justify-between space-y-0 pb-2">
          <CardTitle className="text-sm font-medium">월간 완성 글 수</CardTitle>
          <FileText className="h-4 w-4 text-muted-foreground" />
        </CardHeader>
        <CardContent>
          <div className="text-2xl font-bold">
            {monthlyArticles} / {monthlyGoal}편
          </div>
          <CardDescription className="mt-1">
            목표의 {achievementRate}%를 달성했어요!
          </CardDescription>
        </CardContent>
      </Card>

      <Card>
        <CardHeader className="flex flex-row items-center justify-between space-y-0 pb-2">
          <CardTitle className="text-sm font-medium">누적 절약 시간</CardTitle>
          <Clock className="h-4 w-4 text-muted-foreground" />
        </CardHeader>
        <CardContent>
          <div className="text-2xl font-bold">{savedHours} 시간</div>
          <CardDescription className="mt-1">
            이번 달에 절약한 시간
          </CardDescription>
        </CardContent>
      </Card>
    </div>
  );
}
</file>

<file path="src/components/dashboard/welcome-banner.tsx">
"use client";

import { useState, useEffect } from "react";
import { X, Sparkles } from "lucide-react";
import { useRouter } from "next/navigation";

interface WelcomeBannerProps {
  onDismiss?: () => void;
}

export function WelcomeBanner({ onDismiss }: WelcomeBannerProps) {
  const [isVisible, setIsVisible] = useState(false);
  const router = useRouter();

  // Mount animation
  useEffect(() => {
    setIsVisible(true);

    // Auto-dismiss after 10 seconds
    const timer = setTimeout(() => {
      handleDismiss();
    }, 10000);

    return () => clearTimeout(timer);
  }, []);

  // Handle ESC key for accessibility
  useEffect(() => {
    const handleKeyDown = (e: KeyboardEvent) => {
      if (e.key === "Escape") {
        handleDismiss();
      }
    };

    window.addEventListener("keydown", handleKeyDown);
    return () => window.removeEventListener("keydown", handleKeyDown);
  }, []);

  const handleDismiss = () => {
    setIsVisible(false);
    setTimeout(() => {
      onDismiss?.();
    }, 250); // Wait for animation to complete
  };

  const handleCTAClick = () => {
    router.push("/new-article");
  };

  return (
    <div
      role="status"
      aria-live="polite"
      className={`
        transition-all duration-250 ease-out
        ${isVisible ? "opacity-100 translate-y-0" : "opacity-0 -translate-y-4"}
      `}
    >
      <div
        className="
          bg-[#F0F9FF]
          border-l-4 border-[#3BA2F8]
          rounded-[12px]
          p-4 md:p-6
          shadow-sm
        "
      >
        <div className="flex flex-col md:flex-row md:items-center md:justify-between gap-4">
          {/* Content */}
          <div className="flex items-start gap-3 flex-1">
            <div className="flex-shrink-0 mt-0.5">
              <Sparkles className="w-5 h-5 text-[#3BA2F8]" aria-hidden="true" />
            </div>
            <div className="flex-1">
              <h3 className="text-[16px] font-semibold text-[#1E2A38] mb-1">
                환영합니다! 🎉
              </h3>
              <p className="text-[14px] text-[#374151] leading-[1.5]">
                모든 설정이 완료되었습니다. 이제 AI로 첫 콘텐츠를 생성해보세요!
              </p>
            </div>
          </div>

          {/* Actions */}
          <div className="flex items-center gap-3 md:flex-shrink-0">
            <button
              onClick={handleCTAClick}
              className="
                bg-[#3BA2F8]
                text-white
                px-6
                py-2.5
                rounded-lg
                text-[14px]
                font-medium
                hover:bg-[#2d8fd9]
                transition-colors
                focus:outline-none
                focus:ring-2
                focus:ring-[#3BA2F8]
                focus:ring-offset-2
                h-[40px]
              "
              aria-label="첫 글 작성하러 가기"
            >
              첫 글 작성
            </button>
            <button
              onClick={handleDismiss}
              className="
                p-2
                text-[#6B7280]
                hover:text-[#374151]
                hover:bg-white/50
                rounded-lg
                transition-colors
                focus:outline-none
                focus:ring-2
                focus:ring-[#3BA2F8]
                focus:ring-offset-2
              "
              aria-label="환영 메시지 닫기"
            >
              <X className="w-5 h-5" aria-hidden="true" />
            </button>
          </div>
        </div>
      </div>
    </div>
  );
}
</file>

<file path="src/components/dashboard/welcome-header.tsx">
"use client";

import { Button } from "@/components/ui/button";
import { Plus } from "lucide-react";

type WelcomeHeaderProps = {
  userName?: string;
};

export function WelcomeHeader({ userName = "Sam" }: WelcomeHeaderProps) {
  return (
    <div className="flex flex-col gap-4 sm:flex-row sm:items-center sm:justify-between">
      <div>
        <h1 className="text-3xl font-bold text-foreground">
          안녕하세요, {userName}님!
        </h1>
        <p className="mt-1 text-muted-foreground">
          오늘도 멋진 콘텐츠를 만들어 보세요.
        </p>
      </div>
      <Button size="lg" className="sm:ml-auto">
        새 글 작성
        <Plus className="ml-2 h-4 w-4" />
      </Button>
    </div>
  );
}
</file>

<file path="src/components/layout/sidebar.tsx">
"use client";

import Link from "next/link";
import { usePathname } from "next/navigation";
import { LayoutDashboard, PenTool, FileText, User, Menu } from "lucide-react";
import { cn } from "@/lib/utils";
import { Button } from "@/components/ui/button";
import { Sheet, SheetContent, SheetTrigger } from "@/components/ui/sheet";

const menuItems = [
  {
    icon: LayoutDashboard,
    label: "대시보드",
    href: "/dashboard",
  },
  {
    icon: PenTool,
    label: "새 글 작성",
    href: "/new-article",
  },
  {
    icon: FileText,
    label: "스타일 가이드",
    href: "/style-guide",
  },
  {
    icon: User,
    label: "계정 관리",
    href: "/account",
  },
];

function SidebarContent() {
  const pathname = usePathname();

  return (
    <div className="flex h-full flex-col gap-4 p-4">
      <div className="mb-4">
        <h1 className="text-2xl font-bold text-primary">콘텐츠메이커</h1>
      </div>
      <nav className="flex flex-col gap-2">
        {menuItems.map((item) => {
          const Icon = item.icon;
          const isActive = pathname === item.href;
          return (
            <Link key={item.href} href={item.href}>
              <Button
                variant={isActive ? "secondary" : "ghost"}
                className={cn(
                  "w-full justify-start gap-3",
                  isActive && "bg-secondary",
                )}
              >
                <Icon className="h-5 w-5" />
                <span>{item.label}</span>
              </Button>
            </Link>
          );
        })}
      </nav>
    </div>
  );
}

export function Sidebar() {
  return (
    <>
      {/* Mobile Sidebar */}
      <div className="md:hidden">
        <Sheet>
          <SheetTrigger asChild>
            <Button variant="ghost" size="icon" className="md:hidden">
              <Menu className="h-6 w-6" />
            </Button>
          </SheetTrigger>
          <SheetContent side="left" className="w-64 p-0">
            <SidebarContent />
          </SheetContent>
        </Sheet>
      </div>

      {/* Desktop Sidebar */}
      <aside className="hidden w-64 border-r bg-background md:block">
        <SidebarContent />
      </aside>
    </>
  );
}
</file>

<file path="src/components/ui/accordion.tsx">
"use client"

import * as React from "react"
import * as AccordionPrimitive from "@radix-ui/react-accordion"
import { ChevronDown } from "lucide-react"

import { cn } from "@/lib/utils"

const Accordion = AccordionPrimitive.Root

const AccordionItem = React.forwardRef<
  React.ElementRef<typeof AccordionPrimitive.Item>,
  React.ComponentPropsWithoutRef<typeof AccordionPrimitive.Item>
>(({ className, ...props }, ref) => (
  <AccordionPrimitive.Item
    ref={ref}
    className={cn("border-b", className)}
    {...props}
  />
))
AccordionItem.displayName = "AccordionItem"

const AccordionTrigger = React.forwardRef<
  React.ElementRef<typeof AccordionPrimitive.Trigger>,
  React.ComponentPropsWithoutRef<typeof AccordionPrimitive.Trigger>
>(({ className, children, ...props }, ref) => (
  <AccordionPrimitive.Header className="flex">
    <AccordionPrimitive.Trigger
      ref={ref}
      className={cn(
        "flex flex-1 items-center justify-between py-4 font-medium transition-all hover:underline [&[data-state=open]>svg]:rotate-180",
        className
      )}
      {...props}
    >
      {children}
      <ChevronDown className="h-4 w-4 shrink-0 transition-transform duration-200" />
    </AccordionPrimitive.Trigger>
  </AccordionPrimitive.Header>
))
AccordionTrigger.displayName = AccordionPrimitive.Trigger.displayName

const AccordionContent = React.forwardRef<
  React.ElementRef<typeof AccordionPrimitive.Content>,
  React.ComponentPropsWithoutRef<typeof AccordionPrimitive.Content>
>(({ className, children, ...props }, ref) => (
  <AccordionPrimitive.Content
    ref={ref}
    className="overflow-hidden text-sm transition-all data-[state=closed]:animate-accordion-up data-[state=open]:animate-accordion-down"
    {...props}
  >
    <div className={cn("pb-4 pt-0", className)}>{children}</div>
  </AccordionPrimitive.Content>
))

AccordionContent.displayName = AccordionPrimitive.Content.displayName

export { Accordion, AccordionItem, AccordionTrigger, AccordionContent }
</file>

<file path="src/components/ui/alert.tsx">
"use client"

import * as React from "react"
import { cva, type VariantProps } from "class-variance-authority"

import { cn } from "@/lib/utils"

const alertVariants = cva(
  "relative w-full rounded-lg border p-4 [&>svg~*]:pl-7 [&>svg+div]:translate-y-[-3px] [&>svg]:absolute [&>svg]:left-4 [&>svg]:top-4 [&>svg]:text-foreground",
  {
    variants: {
      variant: {
        default: "bg-background text-foreground",
        destructive:
          "border-destructive/50 text-destructive dark:border-destructive [&>svg]:text-destructive",
      },
    },
    defaultVariants: {
      variant: "default",
    },
  }
)

const Alert = React.forwardRef<
  HTMLDivElement,
  React.HTMLAttributes<HTMLDivElement> & VariantProps<typeof alertVariants>
>(({ className, variant, ...props }, ref) => (
  <div
    ref={ref}
    role="alert"
    className={cn(alertVariants({ variant }), className)}
    {...props}
  />
))
Alert.displayName = "Alert"

const AlertTitle = React.forwardRef<
  HTMLParagraphElement,
  React.HTMLAttributes<HTMLHeadingElement>
>(({ className, ...props }, ref) => (
  <h5
    ref={ref}
    className={cn("mb-1 font-medium leading-none tracking-tight", className)}
    {...props}
  />
))
AlertTitle.displayName = "AlertTitle"

const AlertDescription = React.forwardRef<
  HTMLParagraphElement,
  React.HTMLAttributes<HTMLParagraphElement>
>(({ className, ...props }, ref) => (
  <div
    ref={ref}
    className={cn("text-sm [&_p]:leading-relaxed", className)}
    {...props}
  />
))
AlertDescription.displayName = "AlertDescription"

export { Alert, AlertTitle, AlertDescription }
</file>

<file path="src/components/ui/avatar.tsx">
"use client"

import * as React from "react"
import * as AvatarPrimitive from "@radix-ui/react-avatar"

import { cn } from "@/lib/utils"

const Avatar = React.forwardRef<
  React.ElementRef<typeof AvatarPrimitive.Root>,
  React.ComponentPropsWithoutRef<typeof AvatarPrimitive.Root>
>(({ className, ...props }, ref) => (
  <AvatarPrimitive.Root
    ref={ref}
    className={cn(
      "relative flex h-10 w-10 shrink-0 overflow-hidden rounded-full",
      className
    )}
    {...props}
  />
))
Avatar.displayName = AvatarPrimitive.Root.displayName

const AvatarImage = React.forwardRef<
  React.ElementRef<typeof AvatarPrimitive.Image>,
  React.ComponentPropsWithoutRef<typeof AvatarPrimitive.Image>
>(({ className, ...props }, ref) => (
  <AvatarPrimitive.Image
    ref={ref}
    className={cn("aspect-square h-full w-full", className)}
    {...props}
  />
))
AvatarImage.displayName = AvatarPrimitive.Image.displayName

const AvatarFallback = React.forwardRef<
  React.ElementRef<typeof AvatarPrimitive.Fallback>,
  React.ComponentPropsWithoutRef<typeof AvatarPrimitive.Fallback>
>(({ className, ...props }, ref) => (
  <AvatarPrimitive.Fallback
    ref={ref}
    className={cn(
      "flex h-full w-full items-center justify-center rounded-full bg-muted",
      className
    )}
    {...props}
  />
))
AvatarFallback.displayName = AvatarPrimitive.Fallback.displayName

export { Avatar, AvatarImage, AvatarFallback }
</file>

<file path="src/components/ui/badge.tsx">
import * as React from "react";
import { cva, type VariantProps } from "class-variance-authority";

import { cn } from "@/lib/utils";

const badgeVariants = cva(
  "inline-flex items-center rounded-full border px-2.5 py-0.5 text-xs font-semibold transition-colors focus:outline-hidden focus:ring-2 focus:ring-ring focus:ring-offset-2",
  {
    variants: {
      variant: {
        default:
          "border-transparent bg-primary text-primary-foreground hover:bg-primary/80",
        secondary:
          "border-transparent bg-secondary text-secondary-foreground hover:bg-secondary/80",
        destructive:
          "border-transparent bg-destructive text-destructive-foreground hover:bg-destructive/80",
        outline: "text-foreground",
      },
    },
    defaultVariants: {
      variant: "default",
    },
  },
);

export interface BadgeProps
  extends React.HTMLAttributes<HTMLDivElement>,
    VariantProps<typeof badgeVariants> {}

function Badge({ className, variant, ...props }: BadgeProps) {
  return (
    <div className={cn(badgeVariants({ variant }), className)} {...props} />
  );
}

export { Badge, badgeVariants };
</file>

<file path="src/components/ui/button.tsx">
import * as React from "react";
import { Slot } from "@radix-ui/react-slot";
import { cva, type VariantProps } from "class-variance-authority";

import { cn } from "@/lib/utils";

const buttonVariants = cva(
  "inline-flex items-center justify-center whitespace-nowrap rounded-md text-sm font-medium ring-offset-background transition-colors focus-visible:outline-hidden focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:pointer-events-none disabled:opacity-50",
  {
    variants: {
      variant: {
        default: "bg-primary text-primary-foreground hover:bg-primary/90",
        destructive:
          "bg-destructive text-destructive-foreground hover:bg-destructive/90",
        outline:
          "border border-input bg-background hover:bg-accent hover:text-accent-foreground",
        secondary:
          "bg-secondary text-secondary-foreground hover:bg-secondary/80",
        ghost: "hover:bg-accent hover:text-accent-foreground",
        link: "text-primary underline-offset-4 hover:underline",
      },
      size: {
        default: "h-10 px-4 py-2",
        sm: "h-9 rounded-md px-3",
        lg: "h-11 rounded-md px-8",
        icon: "h-10 w-10",
      },
    },
    defaultVariants: {
      variant: "default",
      size: "default",
    },
  },
);

export interface ButtonProps
  extends React.ButtonHTMLAttributes<HTMLButtonElement>,
    VariantProps<typeof buttonVariants> {
  asChild?: boolean;
}

const Button = React.forwardRef<HTMLButtonElement, ButtonProps>(
  ({ className, variant, size, asChild = false, ...props }, ref) => {
    const Comp = asChild ? Slot : "button";
    return (
      <Comp
        className={cn(buttonVariants({ variant, size, className }))}
        ref={ref}
        {...props}
      />
    );
  },
);
Button.displayName = "Button";

export { Button, buttonVariants };
</file>

<file path="src/components/ui/card.tsx">
import * as React from "react"

import { cn } from "@/lib/utils"

const Card = React.forwardRef<
  HTMLDivElement,
  React.HTMLAttributes<HTMLDivElement>
>(({ className, ...props }, ref) => (
  <div
    ref={ref}
    className={cn(
      "rounded-lg border bg-card text-card-foreground shadow-xs",
      className
    )}
    {...props}
  />
))
Card.displayName = "Card"

const CardHeader = React.forwardRef<
  HTMLDivElement,
  React.HTMLAttributes<HTMLDivElement>
>(({ className, ...props }, ref) => (
  <div
    ref={ref}
    className={cn("flex flex-col space-y-1.5 p-6", className)}
    {...props}
  />
))
CardHeader.displayName = "CardHeader"

const CardTitle = React.forwardRef<
  HTMLDivElement,
  React.HTMLAttributes<HTMLDivElement>
>(({ className, ...props }, ref) => (
  <div
    ref={ref}
    className={cn(
      "text-2xl font-semibold leading-none tracking-tight",
      className
    )}
    {...props}
  />
))
CardTitle.displayName = "CardTitle"

const CardDescription = React.forwardRef<
  HTMLDivElement,
  React.HTMLAttributes<HTMLDivElement>
>(({ className, ...props }, ref) => (
  <div
    ref={ref}
    className={cn("text-sm text-muted-foreground", className)}
    {...props}
  />
))
CardDescription.displayName = "CardDescription"

const CardContent = React.forwardRef<
  HTMLDivElement,
  React.HTMLAttributes<HTMLDivElement>
>(({ className, ...props }, ref) => (
  <div ref={ref} className={cn("p-6 pt-0", className)} {...props} />
))
CardContent.displayName = "CardContent"

const CardFooter = React.forwardRef<
  HTMLDivElement,
  React.HTMLAttributes<HTMLDivElement>
>(({ className, ...props }, ref) => (
  <div
    ref={ref}
    className={cn("flex items-center p-6 pt-0", className)}
    {...props}
  />
))
CardFooter.displayName = "CardFooter"

export { Card, CardHeader, CardFooter, CardTitle, CardDescription, CardContent }
</file>

<file path="src/components/ui/checkbox.tsx">
"use client";

import * as React from "react";
import * as CheckboxPrimitive from "@radix-ui/react-checkbox";
import { Check } from "lucide-react";

import { cn } from "@/lib/utils";

const Checkbox = React.forwardRef<
  React.ElementRef<typeof CheckboxPrimitive.Root>,
  React.ComponentPropsWithoutRef<typeof CheckboxPrimitive.Root>
>(({ className, ...props }, ref) => (
  <CheckboxPrimitive.Root
    ref={ref}
    className={cn(
      "peer h-4 w-4 shrink-0 rounded-sm border border-primary ring-offset-background focus-visible:outline-hidden focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:cursor-not-allowed disabled:opacity-50 data-[state=checked]:bg-primary data-[state=checked]:text-primary-foreground",
      className,
    )}
    {...props}
  >
    <CheckboxPrimitive.Indicator
      className={cn("flex items-center justify-center text-current")}
    >
      <Check className="h-4 w-4" />
    </CheckboxPrimitive.Indicator>
  </CheckboxPrimitive.Root>
));
Checkbox.displayName = CheckboxPrimitive.Root.displayName;

export { Checkbox };
</file>

<file path="src/components/ui/dialog.tsx">
'use client';

import * as React from 'react';
import * as DialogPrimitive from '@radix-ui/react-dialog';
import { X } from 'lucide-react';

import { cn } from '@/lib/utils';

const Dialog = DialogPrimitive.Root;

const DialogTrigger = DialogPrimitive.Trigger;

const DialogPortal = DialogPrimitive.Portal;

const DialogClose = DialogPrimitive.Close;

const DialogOverlay = React.forwardRef<
  React.ElementRef<typeof DialogPrimitive.Overlay>,
  React.ComponentPropsWithoutRef<typeof DialogPrimitive.Overlay>
>(({ className, ...props }, ref) => (
  <DialogPrimitive.Overlay
    ref={ref}
    className={cn(
      'fixed inset-0 z-50 bg-black/80 data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0',
      className,
    )}
    {...props}
  />
));
DialogOverlay.displayName = DialogPrimitive.Overlay.displayName;

const DialogContent = React.forwardRef<
  React.ElementRef<typeof DialogPrimitive.Content>,
  React.ComponentPropsWithoutRef<typeof DialogPrimitive.Content>
>(({ className, children, ...props }, ref) => (
  <DialogPortal>
    <DialogOverlay />
    <DialogPrimitive.Content
      ref={ref}
      className={cn(
        'fixed left-[50%] top-[50%] z-50 grid w-full max-w-lg translate-x-[-50%] translate-y-[-50%] gap-4 border border-slate-200 bg-white p-6 shadow-lg duration-200 data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[state=closed]:slide-out-to-left-1/2 data-[state=closed]:slide-out-to-top-[48%] data-[state=open]:slide-in-from-left-1/2 data-[state=open]:slide-in-from-top-[48%] sm:rounded-lg',
        className,
      )}
      {...props}
    >
      {children}
      <DialogPrimitive.Close className="absolute right-4 top-4 rounded-sm opacity-70 ring-offset-white transition-opacity hover:opacity-100 focus:outline-none focus:ring-2 focus:ring-slate-950 focus:ring-offset-2 disabled:pointer-events-none data-[state=open]:bg-slate-100 data-[state=open]:text-slate-500">
        <X className="h-4 w-4" />
        <span className="sr-only">Close</span>
      </DialogPrimitive.Close>
    </DialogPrimitive.Content>
  </DialogPortal>
));
DialogContent.displayName = DialogPrimitive.Content.displayName;

const DialogHeader = ({
  className,
  ...props
}: React.HTMLAttributes<HTMLDivElement>) => (
  <div
    className={cn(
      'flex flex-col space-y-1.5 text-center sm:text-left',
      className,
    )}
    {...props}
  />
);
DialogHeader.displayName = 'DialogHeader';

const DialogFooter = ({
  className,
  ...props
}: React.HTMLAttributes<HTMLDivElement>) => (
  <div
    className={cn(
      'flex flex-col-reverse sm:flex-row sm:justify-end sm:space-x-2',
      className,
    )}
    {...props}
  />
);
DialogFooter.displayName = 'DialogFooter';

const DialogTitle = React.forwardRef<
  React.ElementRef<typeof DialogPrimitive.Title>,
  React.ComponentPropsWithoutRef<typeof DialogPrimitive.Title>
>(({ className, ...props }, ref) => (
  <DialogPrimitive.Title
    ref={ref}
    className={cn(
      'text-lg font-semibold leading-none tracking-tight',
      className,
    )}
    {...props}
  />
));
DialogTitle.displayName = DialogPrimitive.Title.displayName;

const DialogDescription = React.forwardRef<
  React.ElementRef<typeof DialogPrimitive.Description>,
  React.ComponentPropsWithoutRef<typeof DialogPrimitive.Description>
>(({ className, ...props }, ref) => (
  <DialogPrimitive.Description
    ref={ref}
    className={cn('text-sm text-slate-500', className)}
    {...props}
  />
));
DialogDescription.displayName = DialogPrimitive.Description.displayName;

export {
  Dialog,
  DialogPortal,
  DialogOverlay,
  DialogClose,
  DialogTrigger,
  DialogContent,
  DialogHeader,
  DialogFooter,
  DialogTitle,
  DialogDescription,
};
</file>

<file path="src/components/ui/dropdown-menu.tsx">
"use client";

import * as React from "react";
import * as DropdownMenuPrimitive from "@radix-ui/react-dropdown-menu";
import { Check, ChevronRight, Circle } from "lucide-react";

import { cn } from "@/lib/utils";

const DropdownMenu = DropdownMenuPrimitive.Root;

const DropdownMenuTrigger = DropdownMenuPrimitive.Trigger;

const DropdownMenuGroup = DropdownMenuPrimitive.Group;

const DropdownMenuPortal = DropdownMenuPrimitive.Portal;

const DropdownMenuSub = DropdownMenuPrimitive.Sub;

const DropdownMenuRadioGroup = DropdownMenuPrimitive.RadioGroup;

const DropdownMenuSubTrigger = React.forwardRef<
  React.ElementRef<typeof DropdownMenuPrimitive.SubTrigger>,
  React.ComponentPropsWithoutRef<typeof DropdownMenuPrimitive.SubTrigger> & {
    inset?: boolean;
  }
>(({ className, inset, children, ...props }, ref) => (
  <DropdownMenuPrimitive.SubTrigger
    ref={ref}
    className={cn(
      "flex cursor-default select-none items-center rounded-sm px-2 py-1.5 text-sm outline-hidden focus:bg-accent data-[state=open]:bg-accent",
      inset && "pl-8",
      className,
    )}
    {...props}
  >
    {children}
    <ChevronRight className="ml-auto h-4 w-4" />
  </DropdownMenuPrimitive.SubTrigger>
));
DropdownMenuSubTrigger.displayName =
  DropdownMenuPrimitive.SubTrigger.displayName;

const DropdownMenuSubContent = React.forwardRef<
  React.ElementRef<typeof DropdownMenuPrimitive.SubContent>,
  React.ComponentPropsWithoutRef<typeof DropdownMenuPrimitive.SubContent>
>(({ className, ...props }, ref) => (
  <DropdownMenuPrimitive.SubContent
    ref={ref}
    className={cn(
      "z-50 min-w-32 overflow-hidden rounded-md border bg-popover p-1 text-popover-foreground shadow-lg data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2",
      className,
    )}
    {...props}
  />
));
DropdownMenuSubContent.displayName =
  DropdownMenuPrimitive.SubContent.displayName;

const DropdownMenuContent = React.forwardRef<
  React.ElementRef<typeof DropdownMenuPrimitive.Content>,
  React.ComponentPropsWithoutRef<typeof DropdownMenuPrimitive.Content>
>(({ className, sideOffset = 4, ...props }, ref) => (
  <DropdownMenuPrimitive.Portal>
    <DropdownMenuPrimitive.Content
      ref={ref}
      sideOffset={sideOffset}
      className={cn(
        "z-50 min-w-32 overflow-hidden rounded-md border bg-popover p-1 text-popover-foreground shadow-md data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2",
        className,
      )}
      {...props}
    />
  </DropdownMenuPrimitive.Portal>
));
DropdownMenuContent.displayName = DropdownMenuPrimitive.Content.displayName;

const DropdownMenuItem = React.forwardRef<
  React.ElementRef<typeof DropdownMenuPrimitive.Item>,
  React.ComponentPropsWithoutRef<typeof DropdownMenuPrimitive.Item> & {
    inset?: boolean;
  }
>(({ className, inset, ...props }, ref) => (
  <DropdownMenuPrimitive.Item
    ref={ref}
    className={cn(
      "relative flex cursor-default select-none items-center rounded-sm px-2 py-1.5 text-sm outline-hidden transition-colors focus:bg-accent focus:text-accent-foreground data-disabled:pointer-events-none data-disabled:opacity-50",
      inset && "pl-8",
      className,
    )}
    {...props}
  />
));
DropdownMenuItem.displayName = DropdownMenuPrimitive.Item.displayName;

const DropdownMenuCheckboxItem = React.forwardRef<
  React.ElementRef<typeof DropdownMenuPrimitive.CheckboxItem>,
  React.ComponentPropsWithoutRef<typeof DropdownMenuPrimitive.CheckboxItem>
>(({ className, children, checked, ...props }, ref) => (
  <DropdownMenuPrimitive.CheckboxItem
    ref={ref}
    className={cn(
      "relative flex cursor-default select-none items-center rounded-sm py-1.5 pl-8 pr-2 text-sm outline-hidden transition-colors focus:bg-accent focus:text-accent-foreground data-disabled:pointer-events-none data-disabled:opacity-50",
      className,
    )}
    checked={checked}
    {...props}
  >
    <span className="absolute left-2 flex h-3.5 w-3.5 items-center justify-center">
      <DropdownMenuPrimitive.ItemIndicator>
        <Check className="h-4 w-4" />
      </DropdownMenuPrimitive.ItemIndicator>
    </span>
    {children}
  </DropdownMenuPrimitive.CheckboxItem>
));
DropdownMenuCheckboxItem.displayName =
  DropdownMenuPrimitive.CheckboxItem.displayName;

const DropdownMenuRadioItem = React.forwardRef<
  React.ElementRef<typeof DropdownMenuPrimitive.RadioItem>,
  React.ComponentPropsWithoutRef<typeof DropdownMenuPrimitive.RadioItem>
>(({ className, children, ...props }, ref) => (
  <DropdownMenuPrimitive.RadioItem
    ref={ref}
    className={cn(
      "relative flex cursor-default select-none items-center rounded-sm py-1.5 pl-8 pr-2 text-sm outline-hidden transition-colors focus:bg-accent focus:text-accent-foreground data-disabled:pointer-events-none data-disabled:opacity-50",
      className,
    )}
    {...props}
  >
    <span className="absolute left-2 flex h-3.5 w-3.5 items-center justify-center">
      <DropdownMenuPrimitive.ItemIndicator>
        <Circle className="h-2 w-2 fill-current" />
      </DropdownMenuPrimitive.ItemIndicator>
    </span>
    {children}
  </DropdownMenuPrimitive.RadioItem>
));
DropdownMenuRadioItem.displayName = DropdownMenuPrimitive.RadioItem.displayName;

const DropdownMenuLabel = React.forwardRef<
  React.ElementRef<typeof DropdownMenuPrimitive.Label>,
  React.ComponentPropsWithoutRef<typeof DropdownMenuPrimitive.Label> & {
    inset?: boolean;
  }
>(({ className, inset, ...props }, ref) => (
  <DropdownMenuPrimitive.Label
    ref={ref}
    className={cn(
      "px-2 py-1.5 text-sm font-semibold",
      inset && "pl-8",
      className,
    )}
    {...props}
  />
));
DropdownMenuLabel.displayName = DropdownMenuPrimitive.Label.displayName;

const DropdownMenuSeparator = React.forwardRef<
  React.ElementRef<typeof DropdownMenuPrimitive.Separator>,
  React.ComponentPropsWithoutRef<typeof DropdownMenuPrimitive.Separator>
>(({ className, ...props }, ref) => (
  <DropdownMenuPrimitive.Separator
    ref={ref}
    className={cn("-mx-1 my-1 h-px bg-muted", className)}
    {...props}
  />
));
DropdownMenuSeparator.displayName = DropdownMenuPrimitive.Separator.displayName;

const DropdownMenuShortcut = ({
  className,
  ...props
}: React.HTMLAttributes<HTMLSpanElement>) => {
  return (
    <span
      className={cn("ml-auto text-xs tracking-widest opacity-60", className)}
      {...props}
    />
  );
};
DropdownMenuShortcut.displayName = "DropdownMenuShortcut";

export {
  DropdownMenu,
  DropdownMenuTrigger,
  DropdownMenuContent,
  DropdownMenuItem,
  DropdownMenuCheckboxItem,
  DropdownMenuRadioItem,
  DropdownMenuLabel,
  DropdownMenuSeparator,
  DropdownMenuShortcut,
  DropdownMenuGroup,
  DropdownMenuPortal,
  DropdownMenuSub,
  DropdownMenuSubContent,
  DropdownMenuSubTrigger,
  DropdownMenuRadioGroup,
};
</file>

<file path="src/components/ui/file-upload.tsx">
"use client";

import { cn } from "@/lib/utils";
import { ChangeEvent, useRef } from "react";

interface FileUploadProps extends React.HTMLAttributes<HTMLDivElement> {
  onFileChange: (file: File) => void;
  accept?: string;
}

export function FileUpload({
  className,
  onFileChange,
  accept = "image/*",
  children,
  ...props
}: FileUploadProps) {
  const inputRef = useRef<HTMLInputElement>(null);

  const handleClick = () => {
    inputRef.current?.click();
  };

  const handleChange = (e: ChangeEvent<HTMLInputElement>) => {
    const file = e.target.files?.[0];
    if (file) {
      onFileChange(file);
    }
  };

  return (
    <div
      onClick={handleClick}
      className={cn(
        "cursor-pointer rounded-md border-2 border-dashed border-gray-300 p-4 hover:border-gray-400",
        className
      )}
      {...props}
    >
      <input
        type="file"
        ref={inputRef}
        onChange={handleChange}
        accept={accept}
        className="hidden"
      />
      {children}
    </div>
  );
}
</file>

<file path="src/components/ui/form.tsx">
'use client';

import * as React from 'react';
import * as LabelPrimitive from '@radix-ui/react-label';
import { Slot } from '@radix-ui/react-slot';
import {
  Controller,
  ControllerProps,
  FieldPath,
  FieldValues,
  FormProvider,
  useFormContext,
} from 'react-hook-form';

import { cn } from '@/lib/utils';
import { Label } from '@/components/ui/label';

const Form = FormProvider;

type FormFieldContextValue<
  TFieldValues extends FieldValues = FieldValues,
  TName extends FieldPath<TFieldValues> = FieldPath<TFieldValues>,
> = {
  name: TName;
};

const FormFieldContext = React.createContext<FormFieldContextValue>(
  {} as FormFieldContextValue,
);

const FormField = <
  TFieldValues extends FieldValues = FieldValues,
  TName extends FieldPath<TFieldValues> = FieldPath<TFieldValues>,
>({
  ...props
}: ControllerProps<TFieldValues, TName>) => {
  return (
    <FormFieldContext.Provider value={{ name: props.name }}>
      <Controller {...props} />
    </FormFieldContext.Provider>
  );
};

const useFormField = () => {
  const fieldContext = React.useContext(FormFieldContext);
  const itemContext = React.useContext(FormItemContext);
  const { getFieldState, formState } = useFormContext();

  const fieldState = getFieldState(fieldContext.name, formState);

  if (!fieldContext) {
    throw new Error('useFormField should be used within <FormField>');
  }

  const { id } = itemContext;

  return {
    id,
    name: fieldContext.name,
    formItemId: `${id}-form-item`,
    formDescriptionId: `${id}-form-item-description`,
    formMessageId: `${id}-form-item-message`,
    ...fieldState,
  };
};

type FormItemContextValue = {
  id: string;
};

const FormItemContext = React.createContext<FormItemContextValue>(
  {} as FormItemContextValue,
);

const FormItem = React.forwardRef<
  HTMLDivElement,
  React.HTMLAttributes<HTMLDivElement>
>(({ className, ...props }, ref) => {
  const id = React.useId();

  return (
    <FormItemContext.Provider value={{ id }}>
      <div ref={ref} className={cn('space-y-2', className)} {...props} />
    </FormItemContext.Provider>
  );
});
FormItem.displayName = 'FormItem';

const FormLabel = React.forwardRef<
  React.ElementRef<typeof LabelPrimitive.Root>,
  React.ComponentPropsWithoutRef<typeof LabelPrimitive.Root>
>(({ className, ...props }, ref) => {
  const { error, formItemId } = useFormField();

  return (
    <Label
      ref={ref}
      className={cn(error && 'text-destructive', className)}
      htmlFor={formItemId}
      {...props}
    />
  );
});
FormLabel.displayName = 'FormLabel';

const FormControl = React.forwardRef<
  React.ElementRef<typeof Slot>,
  React.ComponentPropsWithoutRef<typeof Slot>
>(({ ...props }, ref) => {
  const { error, formItemId, formDescriptionId, formMessageId } =
    useFormField();

  return (
    <Slot
      ref={ref}
      id={formItemId}
      aria-describedby={
        !error
          ? `${formDescriptionId}`
          : `${formDescriptionId} ${formMessageId}`
      }
      aria-invalid={!!error}
      {...props}
    />
  );
});
FormControl.displayName = 'FormControl';

const FormDescription = React.forwardRef<
  HTMLParagraphElement,
  React.HTMLAttributes<HTMLParagraphElement>
>(({ className, ...props }, ref) => {
  const { formDescriptionId } = useFormField();

  return (
    <p
      ref={ref}
      id={formDescriptionId}
      className={cn('text-sm text-muted-foreground', className)}
      {...props}
    />
  );
});
FormDescription.displayName = 'FormDescription';

const FormMessage = React.forwardRef<
  HTMLParagraphElement,
  React.HTMLAttributes<HTMLParagraphElement>
>(({ className, children, ...props }, ref) => {
  const { error, formMessageId } = useFormField();
  const body = error ? String(error?.message) : children;

  if (!body) {
    return null;
  }

  return (
    <p
      ref={ref}
      id={formMessageId}
      className={cn('text-sm font-medium text-destructive', className)}
      {...props}
    >
      {body}
    </p>
  );
});
FormMessage.displayName = 'FormMessage';

export {
  useFormField,
  Form,
  FormItem,
  FormLabel,
  FormControl,
  FormDescription,
  FormMessage,
  FormField,
};
</file>

<file path="src/components/ui/input.tsx">
import * as React from "react";

import { cn } from "@/lib/utils";

export interface InputProps
  extends React.InputHTMLAttributes<HTMLInputElement> {}

const Input = React.forwardRef<HTMLInputElement, InputProps>(
  ({ className, type, ...props }, ref) => {
    return (
      <input
        type={type}
        className={cn(
          "flex h-10 w-full rounded-md border border-input bg-background px-3 py-2 text-sm ring-offset-background file:border-0 file:bg-transparent file:text-sm file:font-medium placeholder:text-muted-foreground focus-visible:outline-hidden focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:cursor-not-allowed disabled:opacity-50",
          className,
        )}
        ref={ref}
        {...props}
      />
    );
  },
);
Input.displayName = "Input";

export { Input };
</file>

<file path="src/components/ui/label.tsx">
"use client";

import * as React from "react";
import * as LabelPrimitive from "@radix-ui/react-label";
import { cva, type VariantProps } from "class-variance-authority";

import { cn } from "@/lib/utils";

const labelVariants = cva(
  "text-sm font-medium leading-none peer-disabled:cursor-not-allowed peer-disabled:opacity-70",
);

const Label = React.forwardRef<
  React.ElementRef<typeof LabelPrimitive.Root>,
  React.ComponentPropsWithoutRef<typeof LabelPrimitive.Root> &
    VariantProps<typeof labelVariants>
>(({ className, ...props }, ref) => (
  <LabelPrimitive.Root
    ref={ref}
    className={cn(labelVariants(), className)}
    {...props}
  />
));
Label.displayName = LabelPrimitive.Root.displayName;

export { Label };
</file>

<file path="src/components/ui/progress.tsx">
"use client"

import * as React from "react"
import * as ProgressPrimitive from "@radix-ui/react-progress"

import { cn } from "@/lib/utils"

const Progress = React.forwardRef<
  React.ElementRef<typeof ProgressPrimitive.Root>,
  React.ComponentPropsWithoutRef<typeof ProgressPrimitive.Root>
>(({ className, value, ...props }, ref) => (
  <ProgressPrimitive.Root
    ref={ref}
    className={cn(
      "relative h-2 w-full overflow-hidden rounded-full bg-secondary",
      className
    )}
    {...props}
  >
    <ProgressPrimitive.Indicator
      className="h-full w-full flex-1 bg-primary transition-all"
      style={{ transform: `translateX(-${100 - (value || 0)}%)` }}
    />
  </ProgressPrimitive.Root>
))
Progress.displayName = ProgressPrimitive.Root.displayName

export { Progress }
</file>

<file path="src/components/ui/select.tsx">
'use client';

import * as React from 'react';
import * as SelectPrimitive from '@radix-ui/react-select';
import { Check, ChevronDown, ChevronUp } from 'lucide-react';

import { cn } from '@/lib/utils';

const Select = SelectPrimitive.Root;

const SelectGroup = SelectPrimitive.Group;

const SelectValue = SelectPrimitive.Value;

const SelectTrigger = React.forwardRef<
  React.ElementRef<typeof SelectPrimitive.Trigger>,
  React.ComponentPropsWithoutRef<typeof SelectPrimitive.Trigger>
>(({ className, children, ...props }, ref) => (
  <SelectPrimitive.Trigger
    ref={ref}
    className={cn(
      'flex h-10 w-full items-center justify-between rounded-md border border-input bg-background px-3 py-2 text-sm ring-offset-background placeholder:text-muted-foreground focus:outline-hidden focus:ring-2 focus:ring-ring focus:ring-offset-2 disabled:cursor-not-allowed disabled:opacity-50 [&>span]:line-clamp-1',
      className,
    )}
    {...props}
  >
    {children}
    <SelectPrimitive.Icon asChild>
      <ChevronDown className="h-4 w-4 opacity-50" />
    </SelectPrimitive.Icon>
  </SelectPrimitive.Trigger>
));
SelectTrigger.displayName = SelectPrimitive.Trigger.displayName;

const SelectScrollUpButton = React.forwardRef<
  React.ElementRef<typeof SelectPrimitive.ScrollUpButton>,
  React.ComponentPropsWithoutRef<typeof SelectPrimitive.ScrollUpButton>
>(({ className, ...props }, ref) => (
  <SelectPrimitive.ScrollUpButton
    ref={ref}
    className={cn(
      'flex cursor-default items-center justify-center py-1',
      className,
    )}
    {...props}
  >
    <ChevronUp className="h-4 w-4" />
  </SelectPrimitive.ScrollUpButton>
));
SelectScrollUpButton.displayName = SelectPrimitive.ScrollUpButton.displayName;

const SelectScrollDownButton = React.forwardRef<
  React.ElementRef<typeof SelectPrimitive.ScrollDownButton>,
  React.ComponentPropsWithoutRef<typeof SelectPrimitive.ScrollDownButton>
>(({ className, ...props }, ref) => (
  <SelectPrimitive.ScrollDownButton
    ref={ref}
    className={cn(
      'flex cursor-default items-center justify-center py-1',
      className,
    )}
    {...props}
  >
    <ChevronDown className="h-4 w-4" />
  </SelectPrimitive.ScrollDownButton>
));
SelectScrollDownButton.displayName =
  SelectPrimitive.ScrollDownButton.displayName;

const SelectContent = React.forwardRef<
  React.ElementRef<typeof SelectPrimitive.Content>,
  React.ComponentPropsWithoutRef<typeof SelectPrimitive.Content>
>(({ className, children, position = 'popper', ...props }, ref) => (
  <SelectPrimitive.Portal>
    <SelectPrimitive.Content
      ref={ref}
      className={cn(
        'relative z-50 max-h-96 min-w-32 overflow-hidden rounded-md border bg-popover text-popover-foreground shadow-md data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2',
        position === 'popper' &&
          'data-[side=bottom]:translate-y-1 data-[side=left]:-translate-x-1 data-[side=right]:translate-x-1 data-[side=top]:-translate-y-1',
        className,
      )}
      position={position}
      {...props}
    >
      <SelectScrollUpButton />
      <SelectPrimitive.Viewport
        className={cn(
          'p-1',
          position === 'popper' &&
            'h-(--radix-select-trigger-height) w-full min-w-(--radix-select-trigger-width)',
        )}
      >
        {children}
      </SelectPrimitive.Viewport>
      <SelectScrollDownButton />
    </SelectPrimitive.Content>
  </SelectPrimitive.Portal>
));
SelectContent.displayName = SelectPrimitive.Content.displayName;

const SelectLabel = React.forwardRef<
  React.ElementRef<typeof SelectPrimitive.Label>,
  React.ComponentPropsWithoutRef<typeof SelectPrimitive.Label>
>(({ className, ...props }, ref) => (
  <SelectPrimitive.Label
    ref={ref}
    className={cn('py-1.5 pl-8 pr-2 text-sm font-semibold', className)}
    {...props}
  />
));
SelectLabel.displayName = SelectPrimitive.Label.displayName;

const SelectItem = React.forwardRef<
  React.ElementRef<typeof SelectPrimitive.Item>,
  React.ComponentPropsWithoutRef<typeof SelectPrimitive.Item>
>(({ className, children, ...props }, ref) => (
  <SelectPrimitive.Item
    ref={ref}
    className={cn(
      'relative flex w-full cursor-default select-none items-center rounded-sm py-1.5 pl-8 pr-2 text-sm outline-hidden focus:bg-accent focus:text-accent-foreground data-disabled:pointer-events-none data-disabled:opacity-50',
      className,
    )}
    {...props}
  >
    <span className="absolute left-2 flex h-3.5 w-3.5 items-center justify-center">
      <SelectPrimitive.ItemIndicator>
        <Check className="h-4 w-4" />
      </SelectPrimitive.ItemIndicator>
    </span>

    <SelectPrimitive.ItemText>{children}</SelectPrimitive.ItemText>
  </SelectPrimitive.Item>
));
SelectItem.displayName = SelectPrimitive.Item.displayName;

const SelectSeparator = React.forwardRef<
  React.ElementRef<typeof SelectPrimitive.Separator>,
  React.ComponentPropsWithoutRef<typeof SelectPrimitive.Separator>
>(({ className, ...props }, ref) => (
  <SelectPrimitive.Separator
    ref={ref}
    className={cn('-mx-1 my-1 h-px bg-muted', className)}
    {...props}
  />
));
SelectSeparator.displayName = SelectPrimitive.Separator.displayName;

export {
  Select,
  SelectGroup,
  SelectValue,
  SelectTrigger,
  SelectContent,
  SelectLabel,
  SelectItem,
  SelectSeparator,
  SelectScrollUpButton,
  SelectScrollDownButton,
};
</file>

<file path="src/components/ui/separator.tsx">
"use client"

import * as React from "react"
import * as SeparatorPrimitive from "@radix-ui/react-separator"

import { cn } from "@/lib/utils"

const Separator = React.forwardRef<
  React.ElementRef<typeof SeparatorPrimitive.Root>,
  React.ComponentPropsWithoutRef<typeof SeparatorPrimitive.Root>
>(
  (
    { className, orientation = "horizontal", decorative = true, ...props },
    ref
  ) => (
    <SeparatorPrimitive.Root
      ref={ref}
      decorative={decorative}
      orientation={orientation}
      className={cn(
        "shrink-0 bg-border",
        orientation === "horizontal" ? "h-px w-full" : "h-full w-px",
        className
      )}
      {...props}
    />
  )
)
Separator.displayName = SeparatorPrimitive.Root.displayName

export { Separator }
</file>

<file path="src/components/ui/sheet.tsx">
'use client';

import * as React from 'react';
import * as SheetPrimitive from '@radix-ui/react-dialog';
import { cva, type VariantProps } from 'class-variance-authority';
import { X } from 'lucide-react';

import { cn } from '@/lib/utils';

const Sheet = SheetPrimitive.Root;

const SheetTrigger = SheetPrimitive.Trigger;

const SheetClose = SheetPrimitive.Close;

const SheetPortal = SheetPrimitive.Portal;

const SheetOverlay = React.forwardRef<
  React.ElementRef<typeof SheetPrimitive.Overlay>,
  React.ComponentPropsWithoutRef<typeof SheetPrimitive.Overlay>
>(({ className, ...props }, ref) => (
  <SheetPrimitive.Overlay
    className={cn(
      'fixed inset-0 z-50 bg-black/80  data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0',
      className,
    )}
    {...props}
    ref={ref}
  />
));
SheetOverlay.displayName = SheetPrimitive.Overlay.displayName;

const sheetVariants = cva(
  'fixed z-50 gap-4 bg-background p-6 shadow-lg transition ease-in-out data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:duration-300 data-[state=open]:duration-500',
  {
    variants: {
      side: {
        top: 'inset-x-0 top-0 border-b data-[state=closed]:slide-out-to-top data-[state=open]:slide-in-from-top',
        bottom:
          'inset-x-0 bottom-0 border-t data-[state=closed]:slide-out-to-bottom data-[state=open]:slide-in-from-bottom',
        left: 'inset-y-0 left-0 h-full w-3/4 border-r data-[state=closed]:slide-out-to-left data-[state=open]:slide-in-from-left sm:max-w-sm',
        right:
          'inset-y-0 right-0 h-full w-3/4  border-l data-[state=closed]:slide-out-to-right data-[state=open]:slide-in-from-right sm:max-w-sm',
      },
    },
    defaultVariants: {
      side: 'right',
    },
  },
);

interface SheetContentProps
  extends React.ComponentPropsWithoutRef<typeof SheetPrimitive.Content>,
    VariantProps<typeof sheetVariants> {}

const SheetContent = React.forwardRef<
  React.ElementRef<typeof SheetPrimitive.Content>,
  SheetContentProps
>(({ side = 'right', className, children, ...props }, ref) => (
  <SheetPortal>
    <SheetOverlay />
    <SheetPrimitive.Content
      ref={ref}
      className={cn(sheetVariants({ side }), className)}
      {...props}
    >
      {children}
      <SheetPrimitive.Close className="absolute right-4 top-4 rounded-sm opacity-70 ring-offset-background transition-opacity hover:opacity-100 focus:outline-hidden focus:ring-2 focus:ring-ring focus:ring-offset-2 disabled:pointer-events-none data-[state=open]:bg-secondary">
        <X className="h-4 w-4" />
        <span className="sr-only">Close</span>
      </SheetPrimitive.Close>
    </SheetPrimitive.Content>
  </SheetPortal>
));
SheetContent.displayName = SheetPrimitive.Content.displayName;

const SheetHeader = ({
  className,
  ...props
}: React.HTMLAttributes<HTMLDivElement>) => (
  <div
    className={cn(
      'flex flex-col space-y-2 text-center sm:text-left',
      className,
    )}
    {...props}
  />
);
SheetHeader.displayName = 'SheetHeader';

const SheetFooter = ({
  className,
  ...props
}: React.HTMLAttributes<HTMLDivElement>) => (
  <div
    className={cn(
      'flex flex-col-reverse sm:flex-row sm:justify-end sm:space-x-2',
      className,
    )}
    {...props}
  />
);
SheetFooter.displayName = 'SheetFooter';

const SheetTitle = React.forwardRef<
  React.ElementRef<typeof SheetPrimitive.Title>,
  React.ComponentPropsWithoutRef<typeof SheetPrimitive.Title>
>(({ className, ...props }, ref) => (
  <SheetPrimitive.Title
    ref={ref}
    className={cn('text-lg font-semibold text-foreground', className)}
    {...props}
  />
));
SheetTitle.displayName = SheetPrimitive.Title.displayName;

const SheetDescription = React.forwardRef<
  React.ElementRef<typeof SheetPrimitive.Description>,
  React.ComponentPropsWithoutRef<typeof SheetPrimitive.Description>
>(({ className, ...props }, ref) => (
  <SheetPrimitive.Description
    ref={ref}
    className={cn('text-sm text-muted-foreground', className)}
    {...props}
  />
));
SheetDescription.displayName = SheetPrimitive.Description.displayName;

export {
  Sheet,
  SheetPortal,
  SheetOverlay,
  SheetTrigger,
  SheetClose,
  SheetContent,
  SheetHeader,
  SheetFooter,
  SheetTitle,
  SheetDescription,
};
</file>

<file path="src/components/ui/skeleton.tsx">
import { cn } from "@/lib/utils"

function Skeleton({
  className,
  ...props
}: React.HTMLAttributes<HTMLDivElement>) {
  return (
    <div
      className={cn("animate-pulse rounded-md bg-muted", className)}
      {...props}
    />
  )
}

export { Skeleton }
</file>

<file path="src/components/ui/sonner.tsx">
"use client"

import { Toaster as Sonner } from "sonner"

type ToasterProps = React.ComponentProps<typeof Sonner>

const Toaster = ({ ...props }: ToasterProps) => {
  return (
    <Sonner
      className="toaster group"
      toastOptions={{
        classNames: {
          toast:
            "group toast group-[.toaster]:bg-background group-[.toaster]:text-foreground group-[.toaster]:border-border group-[.toaster]:shadow-lg",
          description: "group-[.toast]:text-muted-foreground",
          actionButton:
            "group-[.toast]:bg-primary group-[.toast]:text-primary-foreground",
          cancelButton:
            "group-[.toast]:bg-muted group-[.toast]:text-muted-foreground",
        },
      }}
      {...props}
    />
  )
}

export { Toaster }
</file>

<file path="src/components/ui/table.tsx">
import * as React from "react";

import { cn } from "@/lib/utils";

const Table = React.forwardRef<
  HTMLTableElement,
  React.HTMLAttributes<HTMLTableElement>
>(({ className, ...props }, ref) => (
  <div className="relative w-full overflow-auto">
    <table
      ref={ref}
      className={cn("w-full caption-bottom text-sm", className)}
      {...props}
    />
  </div>
));
Table.displayName = "Table";

const TableHeader = React.forwardRef<
  HTMLTableSectionElement,
  React.HTMLAttributes<HTMLTableSectionElement>
>(({ className, ...props }, ref) => (
  <thead ref={ref} className={cn("[&_tr]:border-b", className)} {...props} />
));
TableHeader.displayName = "TableHeader";

const TableBody = React.forwardRef<
  HTMLTableSectionElement,
  React.HTMLAttributes<HTMLTableSectionElement>
>(({ className, ...props }, ref) => (
  <tbody
    ref={ref}
    className={cn("[&_tr:last-child]:border-0", className)}
    {...props}
  />
));
TableBody.displayName = "TableBody";

const TableFooter = React.forwardRef<
  HTMLTableSectionElement,
  React.HTMLAttributes<HTMLTableSectionElement>
>(({ className, ...props }, ref) => (
  <tfoot
    ref={ref}
    className={cn(
      "border-t bg-muted/50 font-medium [&>tr]:last:border-b-0",
      className,
    )}
    {...props}
  />
));
TableFooter.displayName = "TableFooter";

const TableRow = React.forwardRef<
  HTMLTableRowElement,
  React.HTMLAttributes<HTMLTableRowElement>
>(({ className, ...props }, ref) => (
  <tr
    ref={ref}
    className={cn(
      "border-b transition-colors hover:bg-muted/50 data-[state=selected]:bg-muted",
      className,
    )}
    {...props}
  />
));
TableRow.displayName = "TableRow";

const TableHead = React.forwardRef<
  HTMLTableCellElement,
  React.ThHTMLAttributes<HTMLTableCellElement>
>(({ className, ...props }, ref) => (
  <th
    ref={ref}
    className={cn(
      "h-12 px-4 text-left align-middle font-medium text-muted-foreground [&:has([role=checkbox])]:pr-0",
      className,
    )}
    {...props}
  />
));
TableHead.displayName = "TableHead";

const TableCell = React.forwardRef<
  HTMLTableCellElement,
  React.TdHTMLAttributes<HTMLTableCellElement>
>(({ className, ...props }, ref) => (
  <td
    ref={ref}
    className={cn("p-4 align-middle [&:has([role=checkbox])]:pr-0", className)}
    {...props}
  />
));
TableCell.displayName = "TableCell";

const TableCaption = React.forwardRef<
  HTMLTableCaptionElement,
  React.HTMLAttributes<HTMLTableCaptionElement>
>(({ className, ...props }, ref) => (
  <caption
    ref={ref}
    className={cn("mt-4 text-sm text-muted-foreground", className)}
    {...props}
  />
));
TableCaption.displayName = "TableCaption";

export {
  Table,
  TableHeader,
  TableBody,
  TableFooter,
  TableHead,
  TableRow,
  TableCell,
  TableCaption,
};
</file>

<file path="src/components/ui/tabs.tsx">
"use client"

import * as React from "react"
import * as TabsPrimitive from "@radix-ui/react-tabs"

import { cn } from "@/lib/utils"

const Tabs = TabsPrimitive.Root

const TabsList = React.forwardRef<
  React.ElementRef<typeof TabsPrimitive.List>,
  React.ComponentPropsWithoutRef<typeof TabsPrimitive.List>
>(({ className, ...props }, ref) => (
  <TabsPrimitive.List
    ref={ref}
    className={cn(
      "inline-flex h-10 items-center justify-center rounded-md bg-muted p-1 text-muted-foreground",
      className
    )}
    {...props}
  />
))
TabsList.displayName = TabsPrimitive.List.displayName

const TabsTrigger = React.forwardRef<
  React.ElementRef<typeof TabsPrimitive.Trigger>,
  React.ComponentPropsWithoutRef<typeof TabsPrimitive.Trigger>
>(({ className, ...props }, ref) => (
  <TabsPrimitive.Trigger
    ref={ref}
    className={cn(
      "inline-flex items-center justify-center whitespace-nowrap rounded-sm px-3 py-1.5 text-sm font-medium ring-offset-background transition-all focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:pointer-events-none disabled:opacity-50 data-[state=active]:bg-background data-[state=active]:text-foreground data-[state=active]:shadow-sm",
      className
    )}
    {...props}
  />
))
TabsTrigger.displayName = TabsPrimitive.Trigger.displayName

const TabsContent = React.forwardRef<
  React.ElementRef<typeof TabsPrimitive.Content>,
  React.ComponentPropsWithoutRef<typeof TabsPrimitive.Content>
>(({ className, ...props }, ref) => (
  <TabsPrimitive.Content
    ref={ref}
    className={cn(
      "mt-2 ring-offset-background focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2",
      className
    )}
    {...props}
  />
))
TabsContent.displayName = TabsPrimitive.Content.displayName

export { Tabs, TabsList, TabsTrigger, TabsContent }
</file>

<file path="src/components/ui/textarea.tsx">
import * as React from 'react';

import { cn } from '@/lib/utils';

const Textarea = React.forwardRef<
  HTMLTextAreaElement,
  React.ComponentProps<'textarea'>
>(({ className, ...props }, ref) => {
  return (
    <textarea
      className={cn(
        'flex min-h-[80px] w-full rounded-md border border-input bg-background px-3 py-2 text-base ring-offset-background placeholder:text-muted-foreground focus-visible:outline-hidden focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:cursor-not-allowed disabled:opacity-50 md:text-sm',
        className,
      )}
      ref={ref}
      {...props}
    />
  );
});
Textarea.displayName = 'Textarea';

export { Textarea };
</file>

<file path="src/components/ui/toast.tsx">
'use client';

import * as React from 'react';
import * as ToastPrimitives from '@radix-ui/react-toast';
import { cva, type VariantProps } from 'class-variance-authority';
import { X } from 'lucide-react';

import { cn } from '@/lib/utils';

const ToastProvider = ToastPrimitives.Provider;

const ToastViewport = React.forwardRef<
  React.ElementRef<typeof ToastPrimitives.Viewport>,
  React.ComponentPropsWithoutRef<typeof ToastPrimitives.Viewport>
>(({ className, ...props }, ref) => (
  <ToastPrimitives.Viewport
    ref={ref}
    className={cn(
      'fixed top-0 z-100 flex max-h-screen w-full flex-col-reverse p-4 sm:bottom-0 sm:right-0 sm:top-auto sm:flex-col md:max-w-[420px]',
      className,
    )}
    {...props}
  />
));
ToastViewport.displayName = ToastPrimitives.Viewport.displayName;

const toastVariants = cva(
  'group pointer-events-auto relative flex w-full items-center justify-between space-x-4 overflow-hidden rounded-md border p-6 pr-8 shadow-lg transition-all data-[swipe=cancel]:translate-x-0 data-[swipe=end]:translate-x-(--radix-toast-swipe-end-x) data-[swipe=move]:translate-x-(--radix-toast-swipe-move-x) data-[swipe=move]:transition-none data-[state=open]:animate-in data-[state=closed]:animate-out data-[swipe=end]:animate-out data-[state=closed]:fade-out-80 data-[state=closed]:slide-out-to-right-full data-[state=open]:slide-in-from-top-full data-[state=open]:sm:slide-in-from-bottom-full',
  {
    variants: {
      variant: {
        default: 'border bg-background text-foreground',
        destructive:
          'destructive group border-destructive bg-destructive text-destructive-foreground',
      },
    },
    defaultVariants: {
      variant: 'default',
    },
  },
);

const Toast = React.forwardRef<
  React.ElementRef<typeof ToastPrimitives.Root>,
  React.ComponentPropsWithoutRef<typeof ToastPrimitives.Root> &
    VariantProps<typeof toastVariants>
>(({ className, variant, ...props }, ref) => {
  return (
    <ToastPrimitives.Root
      ref={ref}
      className={cn(toastVariants({ variant }), className)}
      {...props}
    />
  );
});
Toast.displayName = ToastPrimitives.Root.displayName;

const ToastAction = React.forwardRef<
  React.ElementRef<typeof ToastPrimitives.Action>,
  React.ComponentPropsWithoutRef<typeof ToastPrimitives.Action>
>(({ className, ...props }, ref) => (
  <ToastPrimitives.Action
    ref={ref}
    className={cn(
      'inline-flex h-8 shrink-0 items-center justify-center rounded-md border bg-transparent px-3 text-sm font-medium ring-offset-background transition-colors hover:bg-secondary focus:outline-hidden focus:ring-2 focus:ring-ring focus:ring-offset-2 disabled:pointer-events-none disabled:opacity-50 group-[.destructive]:border-muted/40 hover:group-[.destructive]:border-destructive/30 hover:group-[.destructive]:bg-destructive hover:group-[.destructive]:text-destructive-foreground focus:group-[.destructive]:ring-destructive',
      className,
    )}
    {...props}
  />
));
ToastAction.displayName = ToastPrimitives.Action.displayName;

const ToastClose = React.forwardRef<
  React.ElementRef<typeof ToastPrimitives.Close>,
  React.ComponentPropsWithoutRef<typeof ToastPrimitives.Close>
>(({ className, ...props }, ref) => (
  <ToastPrimitives.Close
    ref={ref}
    className={cn(
      'absolute right-2 top-2 rounded-md p-1 text-foreground/50 opacity-0 transition-opacity hover:text-foreground focus:opacity-100 focus:outline-hidden focus:ring-2 group-hover:opacity-100 group-[.destructive]:text-red-300 hover:group-[.destructive]:text-red-50 focus:group-[.destructive]:ring-red-400 focus:group-[.destructive]:ring-offset-red-600',
      className,
    )}
    toast-close=""
    {...props}
  >
    <X className="h-4 w-4" />
  </ToastPrimitives.Close>
));
ToastClose.displayName = ToastPrimitives.Close.displayName;

const ToastTitle = React.forwardRef<
  React.ElementRef<typeof ToastPrimitives.Title>,
  React.ComponentPropsWithoutRef<typeof ToastPrimitives.Title>
>(({ className, ...props }, ref) => (
  <ToastPrimitives.Title
    ref={ref}
    className={cn('text-sm font-semibold', className)}
    {...props}
  />
));
ToastTitle.displayName = ToastPrimitives.Title.displayName;

const ToastDescription = React.forwardRef<
  React.ElementRef<typeof ToastPrimitives.Description>,
  React.ComponentPropsWithoutRef<typeof ToastPrimitives.Description>
>(({ className, ...props }, ref) => (
  <ToastPrimitives.Description
    ref={ref}
    className={cn('text-sm opacity-90', className)}
    {...props}
  />
));
ToastDescription.displayName = ToastPrimitives.Description.displayName;

type ToastProps = React.ComponentPropsWithoutRef<typeof Toast>;

type ToastActionElement = React.ReactElement<typeof ToastAction>;

export {
  type ToastProps,
  type ToastActionElement,
  ToastProvider,
  ToastViewport,
  Toast,
  ToastTitle,
  ToastDescription,
  ToastClose,
  ToastAction,
};
</file>

<file path="src/components/ui/toaster.tsx">
'use client';

import { useToast } from '@/hooks/use-toast';
import {
  Toast,
  ToastClose,
  ToastDescription,
  ToastProvider,
  ToastTitle,
  ToastViewport,
} from '@/components/ui/toast';

export function Toaster() {
  const { toasts } = useToast();

  return (
    <ToastProvider>
      {toasts.map(function ({ id, title, description, action, ...props }) {
        return (
          <Toast key={id} {...props}>
            <div className="grid gap-1">
              {title && <ToastTitle>{title}</ToastTitle>}
              {description && (
                <ToastDescription>{description}</ToastDescription>
              )}
            </div>
            {action}
            <ToastClose />
          </Toast>
        );
      })}
      <ToastViewport />
    </ToastProvider>
  );
}
</file>

<file path="src/constants/env.ts">
import { z } from 'zod';

const clientEnvSchema = z.object({
  NEXT_PUBLIC_SUPABASE_URL: z.string().url(),
  NEXT_PUBLIC_SUPABASE_ANON_KEY: z.string().min(1),
});

const _clientEnv = clientEnvSchema.safeParse({
  NEXT_PUBLIC_SUPABASE_URL: process.env.NEXT_PUBLIC_SUPABASE_URL,
  NEXT_PUBLIC_SUPABASE_ANON_KEY: process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY,
});

export type ClientEnv = z.infer<typeof clientEnvSchema>;

if (!_clientEnv.success) {
  console.error('환경 변수 검증 실패:', _clientEnv.error.flatten().fieldErrors);
  throw new Error('환경 변수를 확인하세요.');
}

export const env: ClientEnv = _clientEnv.data;
</file>

<file path="src/features/articles/backend/ai-service.ts">
import { generateObject } from 'ai';
import { createGoogleGenerativeAI } from '@ai-sdk/google';
import type { SupabaseClient } from '@supabase/supabase-js';
import {
  failure,
  success,
  type HandlerResult,
} from '@/backend/http/response';
import {
  AIGeneratedContentSchema,
  type AIGeneratedContent,
  type GenerateArticleRequest,
} from '@/features/articles/backend/schema';
import {
  articleErrorCodes,
  type ArticleServiceError,
} from '@/features/articles/backend/error';
import type { StyleGuideResponse } from '@/features/onboarding/backend/schema';

const STYLE_GUIDES_TABLE = 'style_guides';

/**
 * Gets style guide by ID or default style guide for user
 */
const getStyleGuide = async (
  client: SupabaseClient,
  clerkUserId: string,
  styleGuideId?: string,
): Promise<StyleGuideResponse | null> => {
  let query = client.from(STYLE_GUIDES_TABLE).select('*').eq('clerk_user_id', clerkUserId);

  if (styleGuideId) {
    query = query.eq('id', styleGuideId);
  } else {
    query = query.eq('is_default', true);
  }

  const { data, error } = await query.single();

  if (error || !data) {
    return null;
  }

  // Map snake_case to camelCase
  return {
    id: data.id,
    clerkUserId: data.clerk_user_id,
    brandName: data.brand_name,
    brandDescription: data.brand_description,
    personality: data.personality,
    formality: data.formality,
    targetAudience: data.target_audience,
    painPoints: data.pain_points,
    language: data.language,
    tone: data.tone,
    contentLength: data.content_length,
    readingLevel: data.reading_level,
    notes: data.notes,
    isDefault: data.is_default,
    createdAt: data.created_at,
    updatedAt: data.updated_at,
  };
};

/**
 * Builds AI prompt based on topic, style guide, and keywords
 */
const buildPrompt = (
  topic: string,
  styleGuide: StyleGuideResponse | null,
  keywords: string[],
  additionalInstructions?: string,
): string => {
  const language = styleGuide?.language || 'ko';
  const isKorean = language === 'ko';

  const contentLengthGuide = {
    short: isKorean ? '1000-1500자' : '500-800 words',
    medium: isKorean ? '2000-3000자' : '1000-1500 words',
    long: isKorean ? '4000-6000자' : '2000-3000 words',
  };

  const readingLevelGuide = {
    beginner: isKorean ? '초보자도 쉽게 이해할 수 있는' : 'beginner-friendly',
    intermediate: isKorean ? '중급 수준의' : 'intermediate-level',
    advanced: isKorean ? '전문적이고 심화된' : 'advanced and in-depth',
  };

  const toneGuide = {
    professional: isKorean ? '전문적이고 신뢰감 있는' : 'professional and trustworthy',
    friendly: isKorean ? '친근하고 대화하는 듯한' : 'friendly and conversational',
    inspirational: isKorean ? '영감을 주고 동기부여하는' : 'inspirational and motivating',
    educational: isKorean ? '교육적이고 정보 전달에 충실한' : 'educational and informative',
  };

  const promptTemplate = isKorean
    ? `
당신은 전문 블로그 콘텐츠 작가입니다. 다음 조건에 맞춰 고품질 블로그 글을 작성해주세요.

**주제**: ${topic}

**브랜드 정보**:
${styleGuide ? `- 브랜드명: ${styleGuide.brandName}
- 브랜드 설명: ${styleGuide.brandDescription}
- 브랜드 성격: ${styleGuide.personality.join(', ')}
- 격식 수준: ${styleGuide.formality}
- 타겟 독자: ${styleGuide.targetAudience}
- 독자의 고민: ${styleGuide.painPoints}` : '일반적인 블로그 스타일로 작성'}

**작성 스타일**:
- 어조: ${styleGuide ? toneGuide[styleGuide.tone] : '친근하고 전문적인'}
- 글 길이: ${styleGuide ? contentLengthGuide[styleGuide.contentLength] : '2000-3000자'}
- 난이도: ${styleGuide ? readingLevelGuide[styleGuide.readingLevel] : '중급 수준의'}

**키워드**: ${keywords.length > 0 ? keywords.join(', ') : '주제와 관련된 키워드를 자연스럽게 포함'}

${additionalInstructions ? `**추가 지시사항**: ${additionalInstructions}` : ''}

**작성 요구사항**:
1. 제목은 SEO에 최적화되고 클릭을 유도할 수 있도록 작성
2. 본문은 Markdown 형식으로 작성 (제목, 소제목, 목록, 강조 등 활용)
3. 서론, 본론, 결론 구조를 갖추되 자연스럽게 전개
4. 실용적이고 실행 가능한 정보 제공
5. 독자의 고민을 해결하는 데 집중
6. Meta Description은 160자 이내로 요약
7. 주요 키워드를 자연스럽게 본문에 포함
8. 소제목(headings)은 명확하고 구조적으로 구성

**출력 형식**:
- title: 블로그 글 제목
- content: Markdown 형식의 본문 (제목 제외)
- metaDescription: SEO를 위한 메타 설명 (160자 이내)
- keywords: 관련 키워드 배열 (5-10개)
- headings: 본문의 주요 소제목 배열
`
    : `
You are a professional blog content writer. Create a high-quality blog post according to the following requirements.

**Topic**: ${topic}

**Brand Information**:
${styleGuide ? `- Brand Name: ${styleGuide.brandName}
- Brand Description: ${styleGuide.brandDescription}
- Brand Personality: ${styleGuide.personality.join(', ')}
- Formality Level: ${styleGuide.formality}
- Target Audience: ${styleGuide.targetAudience}
- Audience Pain Points: ${styleGuide.painPoints}` : 'Write in a general blog style'}

**Writing Style**:
- Tone: ${styleGuide ? toneGuide[styleGuide.tone] : 'friendly and professional'}
- Content Length: ${styleGuide ? contentLengthGuide[styleGuide.contentLength] : '1000-1500 words'}
- Reading Level: ${styleGuide ? readingLevelGuide[styleGuide.readingLevel] : 'intermediate-level'}

**Keywords**: ${keywords.length > 0 ? keywords.join(', ') : 'Naturally include relevant keywords'}

${additionalInstructions ? `**Additional Instructions**: ${additionalInstructions}` : ''}

**Writing Requirements**:
1. Create an SEO-optimized title that encourages clicks
2. Write the body in Markdown format (use headings, subheadings, lists, emphasis, etc.)
3. Structure with introduction, body, and conclusion in a natural flow
4. Provide practical and actionable information
5. Focus on solving the reader's pain points
6. Summarize in Meta Description (max 160 characters)
7. Naturally incorporate main keywords throughout the content
8. Organize headings clearly and structurally

**Output Format**:
- title: Blog post title
- content: Markdown-formatted body (excluding title)
- metaDescription: SEO meta description (max 160 chars)
- keywords: Array of relevant keywords (5-10)
- headings: Array of main subheadings from the content
`;

  return promptTemplate;
};

/**
 * Generates article content using Google Gemini
 */
export const generateArticleContent = async (
  client: SupabaseClient,
  clerkUserId: string,
  apiKey: string,
  request: GenerateArticleRequest,
): Promise<HandlerResult<AIGeneratedContent, ArticleServiceError, unknown>> => {
  try {
    // Get style guide if provided
    const styleGuide = await getStyleGuide(
      client,
      clerkUserId,
      request.styleGuideId,
    );

    if (request.styleGuideId && !styleGuide) {
      return failure(
        404,
        articleErrorCodes.styleGuideNotFound,
        'Style guide not found',
      );
    }

    // Build prompt
    const prompt = buildPrompt(
      request.topic,
      styleGuide,
      request.keywords || [],
      request.additionalInstructions,
    );

    // Call Gemini API using generateObject for structured output
    const google = createGoogleGenerativeAI({
      apiKey,
    });

    const { object } = await generateObject({
      model: google('gemini-2.0-flash-exp'),
      schema: AIGeneratedContentSchema,
      prompt,
    });

    return success(object);
  } catch (error) {
    return failure(
      500,
      articleErrorCodes.aiGenerationFailed,
      `AI generation failed: ${error instanceof Error ? error.message : 'Unknown error'}`,
      error,
    );
  }
};
</file>

<file path="src/features/articles/backend/quota-service.ts">
import type { SupabaseClient } from '@supabase/supabase-js';
import {
  failure,
  success,
  type HandlerResult,
} from '@/backend/http/response';
import {
  articleErrorCodes,
  type ArticleServiceError,
} from '@/features/articles/backend/error';

const GENERATION_QUOTA_TABLE = 'generation_quota';

// Quota limits per tier
const QUOTA_LIMITS = {
  free: 10,
  pro: 100,
} as const;

type TierType = 'free' | 'pro';

interface QuotaRow {
  id: string;
  clerk_user_id: string;
  tier: TierType;
  generation_count: number;
  last_reset_at: string;
  created_at: string;
  updated_at: string;
}

interface QuotaCheckResult {
  allowed: boolean;
  tier: TierType;
  currentCount: number;
  limit: number;
  remaining: number;
}

/**
 * Gets or creates quota record for user
 */
const getOrCreateQuotaRecord = async (
  client: SupabaseClient,
  clerkUserId: string,
): Promise<QuotaRow | null> => {
  // Try to get existing record
  const { data: existing } = await client
    .from(GENERATION_QUOTA_TABLE)
    .select('*')
    .eq('clerk_user_id', clerkUserId)
    .single();

  if (existing) {
    return existing as QuotaRow;
  }

  // Create new record if doesn't exist
  const { data: newRecord, error } = await client
    .from(GENERATION_QUOTA_TABLE)
    .insert({
      clerk_user_id: clerkUserId,
      tier: 'free',
      generation_count: 0,
    })
    .select('*')
    .single();

  if (error || !newRecord) {
    return null;
  }

  return newRecord as QuotaRow;
};

/**
 * Checks if user has available quota
 * Returns quota information including remaining count
 */
export const checkQuota = async (
  client: SupabaseClient,
  clerkUserId: string,
): Promise<HandlerResult<QuotaCheckResult, ArticleServiceError, unknown>> => {
  try {
    const quota = await getOrCreateQuotaRecord(client, clerkUserId);

    if (!quota) {
      return failure(
        500,
        articleErrorCodes.quotaCheckFailed,
        'Failed to retrieve or create quota record',
      );
    }

    const tier = quota.tier as TierType;
    const limit = QUOTA_LIMITS[tier];
    const currentCount = quota.generation_count;
    const remaining = Math.max(0, limit - currentCount);
    const allowed = currentCount < limit;

    return success(
      {
        allowed,
        tier,
        currentCount,
        limit,
        remaining,
      },
      200,
    );
  } catch (error) {
    return failure(
      500,
      articleErrorCodes.quotaCheckFailed,
      `Quota check failed: ${error instanceof Error ? error.message : 'Unknown error'}`,
      error,
    );
  }
};

/**
 * Increments generation count for user
 * Uses atomic update to prevent race conditions
 */
export const incrementQuota = async (
  client: SupabaseClient,
  clerkUserId: string,
): Promise<HandlerResult<{ newCount: number; remaining: number }, ArticleServiceError, unknown>> => {
  try {
    // Get current quota to determine tier
    const quota = await getOrCreateQuotaRecord(client, clerkUserId);

    if (!quota) {
      return failure(
        500,
        articleErrorCodes.quotaIncrementFailed,
        'Failed to retrieve quota record',
      );
    }

    const tier = quota.tier as TierType;
    const limit = QUOTA_LIMITS[tier];

    // Atomic increment using PostgreSQL
    const { data, error } = await client
      .from(GENERATION_QUOTA_TABLE)
      .update({
        generation_count: quota.generation_count + 1,
      })
      .eq('clerk_user_id', clerkUserId)
      .eq('generation_count', quota.generation_count) // Ensure no race condition
      .select('generation_count')
      .single();

    if (error || !data) {
      return failure(
        500,
        articleErrorCodes.quotaIncrementFailed,
        `Failed to increment quota: ${error?.message || 'Unknown error'}`,
      );
    }

    const newCount = data.generation_count;
    const remaining = Math.max(0, limit - newCount);

    return success({ newCount, remaining }, 200);
  } catch (error) {
    return failure(
      500,
      articleErrorCodes.quotaIncrementFailed,
      `Quota increment failed: ${error instanceof Error ? error.message : 'Unknown error'}`,
      error,
    );
  }
};

/**
 * Gets quota status for user (without creating record)
 */
export const getQuotaStatus = async (
  client: SupabaseClient,
  clerkUserId: string,
): Promise<HandlerResult<QuotaCheckResult, ArticleServiceError, unknown>> => {
  try {
    const { data: quota } = await client
      .from(GENERATION_QUOTA_TABLE)
      .select('*')
      .eq('clerk_user_id', clerkUserId)
      .single();

    if (!quota) {
      // Return default free tier status
      return success(
        {
          allowed: true,
          tier: 'free',
          currentCount: 0,
          limit: QUOTA_LIMITS.free,
          remaining: QUOTA_LIMITS.free,
        },
        200,
      );
    }

    const tier = quota.tier as TierType;
    const limit = QUOTA_LIMITS[tier];
    const currentCount = quota.generation_count;
    const remaining = Math.max(0, limit - currentCount);
    const allowed = currentCount < limit;

    return success(
      {
        allowed,
        tier,
        currentCount,
        limit,
        remaining,
      },
      200,
    );
  } catch (error) {
    return failure(
      500,
      articleErrorCodes.quotaCheckFailed,
      `Failed to get quota status: ${error instanceof Error ? error.message : 'Unknown error'}`,
      error,
    );
  }
};
</file>

<file path="src/features/articles/backend/service.ts">
import type { SupabaseClient } from '@supabase/supabase-js';
import {
  failure,
  success,
  type HandlerResult,
} from '@/backend/http/response';
import {
  ArticleTableRowSchema,
  ArticleResponseSchema,
  type ArticleResponse,
  type CreateArticleRequest,
  type UpdateArticleRequest,
} from '@/features/articles/backend/schema';
import {
  articleErrorCodes,
  type ArticleServiceError,
} from '@/features/articles/backend/error';

const ARTICLES_TABLE = 'articles';

/**
 * Maps database row (snake_case) to API response (camelCase)
 */
const mapArticleRowToResponse = (row: unknown): ArticleResponse => {
  // Validate the database row
  const rowParse = ArticleTableRowSchema.safeParse(row);

  if (!rowParse.success) {
    throw new Error('Article row failed validation');
  }

  // Map snake_case to camelCase
  const mapped = {
    id: rowParse.data.id,
    clerkUserId: rowParse.data.clerk_user_id,
    title: rowParse.data.title,
    slug: rowParse.data.slug,
    keywords: rowParse.data.keywords,
    description: rowParse.data.description,
    content: rowParse.data.content,
    styleGuideId: rowParse.data.style_guide_id,
    tone: rowParse.data.tone,
    contentLength: rowParse.data.content_length,
    readingLevel: rowParse.data.reading_level,
    metaTitle: rowParse.data.meta_title,
    metaDescription: rowParse.data.meta_description,
    status: rowParse.data.status,
    publishedAt: rowParse.data.published_at,
    createdAt: rowParse.data.created_at,
    updatedAt: rowParse.data.updated_at,
  } satisfies ArticleResponse;

  // Validate the response
  const parsed = ArticleResponseSchema.safeParse(mapped);

  if (!parsed.success) {
    throw new Error('Article response failed validation');
  }

  return parsed.data;
};

/**
 * Creates a new article draft
 */
export const createArticle = async (
  client: SupabaseClient,
  clerkUserId: string,
  data: CreateArticleRequest,
): Promise<HandlerResult<ArticleResponse, ArticleServiceError, unknown>> => {
  // Map camelCase TypeScript to snake_case database columns
  const dbRecord = {
    clerk_user_id: clerkUserId,
    title: data.title,
    slug: data.slug,
    keywords: data.keywords,
    description: data.description || null,
    content: data.content,
    style_guide_id: data.styleGuideId || null,
    tone: data.tone || null,
    content_length: data.contentLength || null,
    reading_level: data.readingLevel || null,
    meta_title: data.metaTitle || null,
    meta_description: data.metaDescription || null,
    status: 'draft' as const,
  };

  const { data: savedData, error } = await client
    .from(ARTICLES_TABLE)
    .insert(dbRecord)
    .select('*')
    .single();

  if (error) {
    return failure(
      500,
      articleErrorCodes.createError,
      `Failed to create article: ${error.message}`,
    );
  }

  if (!savedData) {
    return failure(
      500,
      articleErrorCodes.createError,
      'Article was created but no data was returned',
    );
  }

  try {
    const mapped = mapArticleRowToResponse(savedData);
    return success(mapped, 201);
  } catch (err) {
    return failure(
      500,
      articleErrorCodes.validationError,
      'Article row failed validation.',
      err,
    );
  }
};

/**
 * Gets an article by ID
 * Only returns articles belonging to the specified user
 */
export const getArticleById = async (
  client: SupabaseClient,
  clerkUserId: string,
  articleId: string,
): Promise<HandlerResult<ArticleResponse, ArticleServiceError, unknown>> => {
  const { data, error } = await client
    .from(ARTICLES_TABLE)
    .select('*')
    .eq('id', articleId)
    .eq('clerk_user_id', clerkUserId)
    .single();

  if (error) {
    if (error.code === 'PGRST116') {
      return failure(404, articleErrorCodes.notFound, 'Article not found');
    }
    return failure(
      500,
      articleErrorCodes.fetchError,
      `Failed to fetch article: ${error.message}`,
    );
  }

  if (!data) {
    return failure(404, articleErrorCodes.notFound, 'Article not found');
  }

  try {
    const mapped = mapArticleRowToResponse(data);
    return success(mapped, 200);
  } catch (err) {
    return failure(
      500,
      articleErrorCodes.validationError,
      'Article row failed validation.',
      err,
    );
  }
};

/**
 * Updates an existing article
 * Only updates articles belonging to the specified user
 */
export const updateArticle = async (
  client: SupabaseClient,
  clerkUserId: string,
  articleId: string,
  data: UpdateArticleRequest,
): Promise<HandlerResult<ArticleResponse, ArticleServiceError, unknown>> => {
  // Map camelCase TypeScript to snake_case database columns
  const updateData: Record<string, unknown> = {};

  if (data.title !== undefined) updateData.title = data.title;
  if (data.slug !== undefined) updateData.slug = data.slug;
  if (data.keywords !== undefined) updateData.keywords = data.keywords;
  if (data.description !== undefined)
    updateData.description = data.description || null;
  if (data.content !== undefined) updateData.content = data.content;
  if (data.styleGuideId !== undefined)
    updateData.style_guide_id = data.styleGuideId || null;
  if (data.tone !== undefined) updateData.tone = data.tone || null;
  if (data.contentLength !== undefined)
    updateData.content_length = data.contentLength || null;
  if (data.readingLevel !== undefined)
    updateData.reading_level = data.readingLevel || null;
  if (data.metaTitle !== undefined)
    updateData.meta_title = data.metaTitle || null;
  if (data.metaDescription !== undefined)
    updateData.meta_description = data.metaDescription || null;
  if (data.status !== undefined) {
    updateData.status = data.status;
    // If publishing for the first time, set published_at
    if (data.status === 'published') {
      updateData.published_at = new Date().toISOString();
    }
  }

  const { data: updatedData, error } = await client
    .from(ARTICLES_TABLE)
    .update(updateData)
    .eq('id', articleId)
    .eq('clerk_user_id', clerkUserId)
    .select('*')
    .single();

  if (error) {
    if (error.code === 'PGRST116') {
      return failure(404, articleErrorCodes.notFound, 'Article not found');
    }
    return failure(
      500,
      articleErrorCodes.updateError,
      `Failed to update article: ${error.message}`,
    );
  }

  if (!updatedData) {
    return failure(
      500,
      articleErrorCodes.updateError,
      'Article was updated but no data was returned',
    );
  }

  try {
    const mapped = mapArticleRowToResponse(updatedData);
    return success(mapped, 200);
  } catch (err) {
    return failure(
      500,
      articleErrorCodes.validationError,
      'Article row failed validation.',
      err,
    );
  }
};

/**
 * Deletes an article by ID
 * Only deletes articles belonging to the specified user
 */
export const deleteArticle = async (
  client: SupabaseClient,
  clerkUserId: string,
  articleId: string,
): Promise<HandlerResult<{ id: string }, ArticleServiceError, unknown>> => {
  const { error } = await client
    .from(ARTICLES_TABLE)
    .delete()
    .eq('id', articleId)
    .eq('clerk_user_id', clerkUserId);

  if (error) {
    return failure(
      500,
      articleErrorCodes.deleteError,
      `Failed to delete article: ${error.message}`,
    );
  }

  return success({ id: articleId }, 200);
};
</file>

<file path="src/features/articles/components/article-form.tsx">
"use client";

import { UseFormReturn } from "react-hook-form";
import {
  FormField,
  FormItem,
  FormLabel,
  FormControl,
  FormDescription,
  FormMessage,
} from "@/components/ui/form";
import { Input } from "@/components/ui/input";
import { Textarea } from "@/components/ui/textarea";
import {
  Select,
  SelectContent,
  SelectItem,
  SelectTrigger,
  SelectValue,
} from "@/components/ui/select";
import { Button } from "@/components/ui/button";
import { Badge } from "@/components/ui/badge";
import { X, Plus } from "lucide-react";
import { useState } from "react";
import type { ArticleFormData } from "../lib/article-form-schema";
import { generateSlug } from "../lib/article-form-schema";

interface ArticleFormProps {
  form: UseFormReturn<ArticleFormData>;
  styleGuides?: Array<{ id: string; name: string }>;
  isLoading?: boolean;
}

export function ArticleForm({ form, styleGuides, isLoading }: ArticleFormProps) {
  const [keywordInput, setKeywordInput] = useState("");

  const handleAddKeyword = () => {
    const trimmed = keywordInput.trim();
    if (!trimmed) return;

    const currentKeywords = form.getValues("keywords") || [];
    if (!currentKeywords.includes(trimmed)) {
      form.setValue("keywords", [...currentKeywords, trimmed]);
    }
    setKeywordInput("");
  };

  const handleRemoveKeyword = (keyword: string) => {
    const currentKeywords = form.getValues("keywords") || [];
    form.setValue(
      "keywords",
      currentKeywords.filter((k) => k !== keyword)
    );
  };

  const handleTitleChange = (value: string) => {
    form.setValue("title", value);

    // Auto-generate slug if it's empty or was auto-generated
    const currentSlug = form.getValues("slug");
    if (!currentSlug || currentSlug === generateSlug(form.getValues("title"))) {
      const newSlug = generateSlug(value);
      form.setValue("slug", newSlug);
    }
  };

  const keywords = form.watch("keywords") || [];

  return (
    <div className="space-y-6">
      <div>
        <h2 className="text-2xl font-bold" style={{ color: "#1F2937" }}>
          글 작성
        </h2>
        <p className="mt-1 text-sm" style={{ color: "#6B7280" }}>
          새로운 블로그 글을 작성해주세요
        </p>
      </div>

      {/* Title */}
      <FormField
        control={form.control}
        name="title"
        render={({ field }) => (
          <FormItem>
            <FormLabel className="text-base font-semibold">
              제목 <span style={{ color: "#DC2626" }}>*</span>
            </FormLabel>
            <FormControl>
              <Input
                {...field}
                onChange={(e) => handleTitleChange(e.target.value)}
                placeholder="글의 제목을 입력하세요"
                disabled={isLoading}
                className="h-12 text-base"
                style={{
                  borderColor: "#E1E5EA",
                  borderRadius: "8px",
                }}
              />
            </FormControl>
            <FormDescription>
              명확하고 간결한 제목을 입력해주세요
            </FormDescription>
            <FormMessage />
          </FormItem>
        )}
      />

      {/* Slug */}
      <FormField
        control={form.control}
        name="slug"
        render={({ field }) => (
          <FormItem>
            <FormLabel className="text-base font-semibold">
              URL 슬러그 <span style={{ color: "#DC2626" }}>*</span>
            </FormLabel>
            <FormControl>
              <Input
                {...field}
                placeholder="url-slug-example"
                disabled={isLoading}
                className="h-12 font-mono text-sm"
                style={{
                  borderColor: "#E1E5EA",
                  borderRadius: "8px",
                }}
              />
            </FormControl>
            <FormDescription>
              소문자, 숫자, 하이픈(-)만 사용 가능합니다
            </FormDescription>
            <FormMessage />
          </FormItem>
        )}
      />

      {/* Keywords */}
      <FormField
        control={form.control}
        name="keywords"
        render={() => (
          <FormItem>
            <FormLabel className="text-base font-semibold">키워드</FormLabel>
            <div className="space-y-3">
              <div className="flex gap-2">
                <Input
                  value={keywordInput}
                  onChange={(e) => setKeywordInput(e.target.value)}
                  onKeyDown={(e) => {
                    if (e.key === "Enter") {
                      e.preventDefault();
                      handleAddKeyword();
                    }
                  }}
                  placeholder="키워드 입력 후 Enter"
                  disabled={isLoading}
                  className="h-10"
                  style={{
                    borderColor: "#E1E5EA",
                    borderRadius: "8px",
                  }}
                />
                <Button
                  type="button"
                  variant="outline"
                  size="icon"
                  onClick={handleAddKeyword}
                  disabled={isLoading}
                  className="h-10 w-10"
                  style={{
                    borderColor: "#E1E5EA",
                    borderRadius: "8px",
                  }}
                >
                  <Plus className="h-4 w-4" />
                </Button>
              </div>
              {keywords.length > 0 && (
                <div className="flex flex-wrap gap-2">
                  {keywords.map((keyword) => (
                    <Badge
                      key={keyword}
                      variant="secondary"
                      className="px-3 py-1.5 text-sm"
                      style={{
                        backgroundColor: "#F3F4F6",
                        color: "#374151",
                      }}
                    >
                      {keyword}
                      <button
                        type="button"
                        onClick={() => handleRemoveKeyword(keyword)}
                        className="ml-2 hover:opacity-70"
                        disabled={isLoading}
                      >
                        <X className="h-3 w-3" />
                      </button>
                    </Badge>
                  ))}
                </div>
              )}
            </div>
            <FormDescription>
              글의 주요 키워드를 입력해주세요
            </FormDescription>
            <FormMessage />
          </FormItem>
        )}
      />

      {/* Description */}
      <FormField
        control={form.control}
        name="description"
        render={({ field }) => (
          <FormItem>
            <FormLabel className="text-base font-semibold">
              요약 설명
            </FormLabel>
            <FormControl>
              <Textarea
                {...field}
                placeholder="글의 요약 설명을 입력하세요"
                disabled={isLoading}
                rows={3}
                className="resize-none"
                style={{
                  borderColor: "#E1E5EA",
                  borderRadius: "8px",
                }}
              />
            </FormControl>
            <FormDescription>
              최대 500자까지 입력 가능합니다
            </FormDescription>
            <FormMessage />
          </FormItem>
        )}
      />

      {/* Content */}
      <FormField
        control={form.control}
        name="content"
        render={({ field }) => (
          <FormItem>
            <FormLabel className="text-base font-semibold">
              본문 <span style={{ color: "#DC2626" }}>*</span>
            </FormLabel>
            <FormControl>
              <Textarea
                {...field}
                placeholder="글의 본문을 입력하세요 (Markdown 지원)"
                disabled={isLoading}
                rows={12}
                className="resize-none font-mono text-sm"
                style={{
                  borderColor: "#E1E5EA",
                  borderRadius: "8px",
                }}
              />
            </FormControl>
            <FormDescription>
              Markdown 문법을 사용할 수 있습니다
            </FormDescription>
            <FormMessage />
          </FormItem>
        )}
      />

      {/* Style Guide */}
      {styleGuides && styleGuides.length > 0 && (
        <FormField
          control={form.control}
          name="styleGuideId"
          render={({ field }) => (
            <FormItem>
              <FormLabel className="text-base font-semibold">
                스타일 가이드
              </FormLabel>
              <Select
                onValueChange={field.onChange}
                value={field.value}
                disabled={isLoading}
              >
                <FormControl>
                  <SelectTrigger
                    className="h-12"
                    style={{
                      borderColor: "#E1E5EA",
                      borderRadius: "8px",
                    }}
                  >
                    <SelectValue placeholder="스타일 가이드 선택 (선택사항)" />
                  </SelectTrigger>
                </FormControl>
                <SelectContent>
                  {styleGuides.map((guide) => (
                    <SelectItem key={guide.id} value={guide.id}>
                      {guide.name}
                    </SelectItem>
                  ))}
                </SelectContent>
              </Select>
              <FormDescription>
                글 작성 시 참고할 스타일 가이드를 선택하세요
              </FormDescription>
              <FormMessage />
            </FormItem>
          )}
        />
      )}

      {/* Tone */}
      <FormField
        control={form.control}
        name="tone"
        render={({ field }) => (
          <FormItem>
            <FormLabel className="text-base font-semibold">톤</FormLabel>
            <Select
              onValueChange={field.onChange}
              value={field.value}
              disabled={isLoading}
            >
              <FormControl>
                <SelectTrigger
                  className="h-12"
                  style={{
                    borderColor: "#E1E5EA",
                    borderRadius: "8px",
                  }}
                >
                  <SelectValue placeholder="글의 톤을 선택하세요" />
                </SelectTrigger>
              </FormControl>
              <SelectContent>
                <SelectItem value="professional">Professional (전문적)</SelectItem>
                <SelectItem value="friendly">Friendly (친근함)</SelectItem>
                <SelectItem value="inspirational">Inspirational (영감적)</SelectItem>
                <SelectItem value="educational">Educational (교육적)</SelectItem>
              </SelectContent>
            </Select>
            <FormDescription>
              글의 분위기와 스타일을 선택하세요
            </FormDescription>
            <FormMessage />
          </FormItem>
        )}
      />

      <div className="grid gap-6 sm:grid-cols-2">
        {/* Content Length */}
        <FormField
          control={form.control}
          name="contentLength"
          render={({ field }) => (
            <FormItem>
              <FormLabel className="text-base font-semibold">
                글 길이
              </FormLabel>
              <Select
                onValueChange={field.onChange}
                value={field.value}
                disabled={isLoading}
              >
                <FormControl>
                  <SelectTrigger
                    className="h-12"
                    style={{
                      borderColor: "#E1E5EA",
                      borderRadius: "8px",
                    }}
                  >
                    <SelectValue placeholder="선택" />
                  </SelectTrigger>
                </FormControl>
                <SelectContent>
                  <SelectItem value="short">짧음 (Short)</SelectItem>
                  <SelectItem value="medium">중간 (Medium)</SelectItem>
                  <SelectItem value="long">김 (Long)</SelectItem>
                </SelectContent>
              </Select>
              <FormMessage />
            </FormItem>
          )}
        />

        {/* Reading Level */}
        <FormField
          control={form.control}
          name="readingLevel"
          render={({ field }) => (
            <FormItem>
              <FormLabel className="text-base font-semibold">
                난이도
              </FormLabel>
              <Select
                onValueChange={field.onChange}
                value={field.value}
                disabled={isLoading}
              >
                <FormControl>
                  <SelectTrigger
                    className="h-12"
                    style={{
                      borderColor: "#E1E5EA",
                      borderRadius: "8px",
                    }}
                  >
                    <SelectValue placeholder="선택" />
                  </SelectTrigger>
                </FormControl>
                <SelectContent>
                  <SelectItem value="beginner">초급 (Beginner)</SelectItem>
                  <SelectItem value="intermediate">중급 (Intermediate)</SelectItem>
                  <SelectItem value="advanced">고급 (Advanced)</SelectItem>
                </SelectContent>
              </Select>
              <FormMessage />
            </FormItem>
          )}
        />
      </div>
    </div>
  );
}
</file>

<file path="src/features/articles/components/article-preview.tsx">
"use client";

import { Card } from "@/components/ui/card";
import { FileText } from "lucide-react";
import type { ArticleFormData } from "../lib/article-form-schema";

interface ArticlePreviewProps {
  formData: ArticleFormData;
}

export function ArticlePreview({ formData }: ArticlePreviewProps) {
  const hasContent = formData.title || formData.content;

  return (
    <Card
      className="sticky top-4 h-fit overflow-hidden"
      style={{
        borderColor: "#E1E5EA",
        borderRadius: "12px",
      }}
    >
      <div
        className="border-b px-6 py-4"
        style={{ borderColor: "#E1E5EA", backgroundColor: "#F9FAFB" }}
      >
        <h3 className="flex items-center gap-2 text-lg font-semibold">
          <FileText className="h-5 w-5" style={{ color: "#3BA2F8" }} />
          미리보기
        </h3>
      </div>

      <div className="p-6">
        {!hasContent ? (
          <div
            className="flex min-h-[400px] items-center justify-center text-center"
            style={{ color: "#9CA3AF" }}
          >
            <div>
              <FileText className="mx-auto mb-3 h-12 w-12" />
              <p className="text-sm">
                글을 작성하면
                <br />
                미리보기가 표시됩니다
              </p>
            </div>
          </div>
        ) : (
          <div className="space-y-6">
            {/* Title */}
            {formData.title && (
              <div>
                <h1
                  className="text-3xl font-bold leading-tight"
                  style={{ color: "#1F2937" }}
                >
                  {formData.title}
                </h1>
              </div>
            )}

            {/* Meta Info */}
            <div className="flex flex-wrap gap-2">
              {formData.tone && (
                <span
                  className="rounded-full px-3 py-1 text-xs font-medium"
                  style={{
                    backgroundColor: "#EFF6FF",
                    color: "#3B82F6",
                  }}
                >
                  {formData.tone}
                </span>
              )}
              {formData.contentLength && (
                <span
                  className="rounded-full px-3 py-1 text-xs font-medium"
                  style={{
                    backgroundColor: "#F0FDF4",
                    color: "#10B981",
                  }}
                >
                  {formData.contentLength}
                </span>
              )}
              {formData.readingLevel && (
                <span
                  className="rounded-full px-3 py-1 text-xs font-medium"
                  style={{
                    backgroundColor: "#FEF3C7",
                    color: "#F59E0B",
                  }}
                >
                  {formData.readingLevel}
                </span>
              )}
            </div>

            {/* Keywords */}
            {formData.keywords && formData.keywords.length > 0 && (
              <div>
                <h4
                  className="mb-2 text-xs font-semibold uppercase"
                  style={{ color: "#6B7280" }}
                >
                  키워드
                </h4>
                <div className="flex flex-wrap gap-1.5">
                  {formData.keywords.map((keyword) => (
                    <span
                      key={keyword}
                      className="rounded px-2 py-0.5 text-xs"
                      style={{
                        backgroundColor: "#F3F4F6",
                        color: "#4B5563",
                      }}
                    >
                      #{keyword}
                    </span>
                  ))}
                </div>
              </div>
            )}

            {/* Description */}
            {formData.description && (
              <div>
                <p
                  className="text-base leading-relaxed"
                  style={{ color: "#6B7280" }}
                >
                  {formData.description}
                </p>
              </div>
            )}

            {/* Content Preview */}
            {formData.content && (
              <div
                className="border-t pt-6"
                style={{ borderColor: "#E1E5EA" }}
              >
                <h4
                  className="mb-3 text-xs font-semibold uppercase"
                  style={{ color: "#6B7280" }}
                >
                  본문
                </h4>
                <div
                  className="prose prose-sm max-w-none"
                  style={{ color: "#374151" }}
                >
                  <pre className="whitespace-pre-wrap font-sans text-sm leading-relaxed">
                    {formData.content}
                  </pre>
                </div>
              </div>
            )}
          </div>
        )}
      </div>
    </Card>
  );
}
</file>

<file path="src/features/articles/components/auto-save-indicator.tsx">
'use client';

import { Check, Loader2, AlertCircle } from 'lucide-react';
import { formatDistanceToNow } from 'date-fns';
import { ko } from 'date-fns/locale';

interface AutoSaveIndicatorProps {
  isSaving: boolean;
  isError: boolean;
  lastSavedAt?: string;
}

export function AutoSaveIndicator({
  isSaving,
  isError,
  lastSavedAt,
}: AutoSaveIndicatorProps) {
  return (
    <div className="flex items-center gap-2 text-sm text-muted-foreground">
      {isSaving && (
        <>
          <Loader2 className="h-4 w-4 animate-spin" />
          <span>저장 중...</span>
        </>
      )}
      {isError && (
        <>
          <AlertCircle className="h-4 w-4 text-red-500" />
          <span className="text-red-500">저장 실패</span>
        </>
      )}
      {!isSaving && !isError && lastSavedAt && (
        <>
          <Check className="h-4 w-4 text-green-500" />
          <span>
            {formatDistanceToNow(new Date(lastSavedAt), {
              addSuffix: true,
              locale: ko,
            })}
            에 저장됨
          </span>
        </>
      )}
    </div>
  );
}
</file>

<file path="src/features/articles/components/generation-form.tsx">
"use client";

import { useState } from "react";
import { useForm } from "react-hook-form";
import { zodResolver } from "@hookform/resolvers/zod";
import { z } from "zod";
import {
  Form,
  FormField,
  FormItem,
  FormLabel,
  FormControl,
  FormDescription,
  FormMessage,
} from "@/components/ui/form";
import { Input } from "@/components/ui/input";
import {
  Select,
  SelectContent,
  SelectItem,
  SelectTrigger,
  SelectValue,
} from "@/components/ui/select";
import { Button } from "@/components/ui/button";
import { Sparkles } from "lucide-react";

const GenerationFormSchema = z.object({
  topic: z
    .string()
    .min(2, "주제는 2자 이상이어야 합니다")
    .max(200, "주제는 200자 이내여야 합니다"),
  styleGuideId: z.string().uuid("유효한 스타일 가이드를 선택해주세요"),
  keywords: z
    .string()
    .max(500, "키워드는 500자 이내여야 합니다")
    .optional(),
});

export type GenerationFormData = z.infer<typeof GenerationFormSchema>;

interface GenerationFormProps {
  styleGuides: Array<{ id: string; name: string }>;
  onSubmit: (data: GenerationFormData) => Promise<void>;
  isLoading?: boolean;
}

export function GenerationForm({
  styleGuides,
  onSubmit,
  isLoading,
}: GenerationFormProps) {
  const [isSubmitting, setIsSubmitting] = useState(false);

  const form = useForm<GenerationFormData>({
    resolver: zodResolver(GenerationFormSchema),
    defaultValues: {
      topic: "",
      styleGuideId: styleGuides[0]?.id || "",
      keywords: "",
    },
  });

  const handleSubmit = async (data: GenerationFormData) => {
    setIsSubmitting(true);
    try {
      await onSubmit(data);
    } finally {
      setIsSubmitting(false);
    }
  };

  return (
    <Form {...form}>
      <form onSubmit={form.handleSubmit(handleSubmit)} className="space-y-6">
        <div>
          <h2 className="text-3xl font-bold" style={{ color: "#1F2937" }}>
            AI로 글쓰기
          </h2>
          <p className="mt-2 text-base" style={{ color: "#6B7280" }}>
            주제를 입력하고 스타일 가이드를 선택하면 AI가 자동으로 글을 생성해줍니다
          </p>
        </div>

        {/* Topic Input */}
        <FormField
          control={form.control}
          name="topic"
          render={({ field }) => (
            <FormItem>
              <FormLabel className="text-base font-semibold">
                글의 주제 <span style={{ color: "#DC2626" }}>*</span>
              </FormLabel>
              <FormControl>
                <Input
                  {...field}
                  placeholder="예: Next.js에서 Server Actions 사용하기"
                  disabled={isSubmitting || isLoading}
                  className="h-12 text-base"
                  style={{
                    borderColor: "#E1E5EA",
                    borderRadius: "8px",
                  }}
                />
              </FormControl>
              <FormDescription>
                작성하고 싶은 글의 주제나 키워드를 입력해주세요
              </FormDescription>
              <FormMessage />
            </FormItem>
          )}
        />

        {/* Style Guide Selection */}
        <FormField
          control={form.control}
          name="styleGuideId"
          render={({ field }) => (
            <FormItem>
              <FormLabel className="text-base font-semibold">
                스타일 가이드 <span style={{ color: "#DC2626" }}>*</span>
              </FormLabel>
              <Select
                onValueChange={field.onChange}
                defaultValue={field.value}
                disabled={isSubmitting || isLoading}
              >
                <FormControl>
                  <SelectTrigger
                    className="h-12 text-base"
                    style={{
                      borderColor: "#E1E5EA",
                      borderRadius: "8px",
                    }}
                  >
                    <SelectValue placeholder="스타일 가이드를 선택하세요" />
                  </SelectTrigger>
                </FormControl>
                <SelectContent>
                  {styleGuides.map((guide) => (
                    <SelectItem key={guide.id} value={guide.id}>
                      {guide.name}
                    </SelectItem>
                  ))}
                </SelectContent>
              </Select>
              <FormDescription>
                글의 톤, 길이, 난이도를 결정하는 기본 설정입니다
              </FormDescription>
              <FormMessage />
            </FormItem>
          )}
        />

        {/* Keywords (Optional) */}
        <FormField
          control={form.control}
          name="keywords"
          render={({ field }) => (
            <FormItem>
              <FormLabel className="text-base font-semibold">
                키워드 (선택사항)
              </FormLabel>
              <FormControl>
                <Input
                  {...field}
                  placeholder="쉼표로 구분하여 여러 키워드를 입력할 수 있습니다"
                  disabled={isSubmitting || isLoading}
                  className="h-12 text-base"
                  style={{
                    borderColor: "#E1E5EA",
                    borderRadius: "8px",
                  }}
                />
              </FormControl>
              <FormDescription>
                글에 포함시키고 싶은 키워드를 쉼표로 구분하여 입력하세요
              </FormDescription>
              <FormMessage />
            </FormItem>
          )}
        />

        {/* Submit Button */}
        <div className="flex justify-end pt-4">
          <Button
            type="submit"
            disabled={isSubmitting || isLoading || !form.formState.isValid}
            className="h-12 px-8"
            style={{
              backgroundColor: "#3BA2F8",
              borderRadius: "8px",
            }}
          >
            <Sparkles className="mr-2 h-4 w-4" />
            {isSubmitting ? "생성 중..." : "AI로 글 생성하기"}
          </Button>
        </div>
      </form>
    </Form>
  );
}
</file>

<file path="src/features/articles/components/generation-progress.tsx">
"use client";

import { useEffect, useState } from "react";
import { Card } from "@/components/ui/card";
import { Button } from "@/components/ui/button";
import { Progress } from "@/components/ui/progress";
import { Skeleton } from "@/components/ui/skeleton";
import { Alert, AlertDescription } from "@/components/ui/alert";
import { X, AlertCircle, RefreshCw, Sparkles, Clock } from "lucide-react";

interface GenerationProgressProps {
  isGenerating: boolean;
  error: Error | null;
  onCancel: () => void;
  onRetry: () => void;
}

export function GenerationProgress({
  isGenerating,
  error,
  onCancel,
  onRetry,
}: GenerationProgressProps) {
  const [progress, setProgress] = useState(0);
  const [timeElapsed, setTimeElapsed] = useState(0);
  const maxTime = 300; // 5분 (300초)

  useEffect(() => {
    if (!isGenerating) {
      setProgress(0);
      setTimeElapsed(0);
      return;
    }

    const interval = setInterval(() => {
      setTimeElapsed((prev) => {
        const next = prev + 1;

        // Calculate progress: 0% → 95% over 5 minutes, then 100% when done
        if (next >= maxTime) {
          setProgress(95);
          return maxTime;
        }

        // Logarithmic curve for smooth progress
        const progressPercent = Math.min(95, (next / maxTime) * 100);
        setProgress(progressPercent);

        return next;
      });
    }, 1000);

    return () => clearInterval(interval);
  }, [isGenerating, maxTime]);

  // Complete progress when done
  useEffect(() => {
    if (!isGenerating && progress > 0) {
      setProgress(100);
    }
  }, [isGenerating, progress]);

  const formatTime = (seconds: number) => {
    const mins = Math.floor(seconds / 60);
    const secs = seconds % 60;
    return `${mins}:${secs.toString().padStart(2, "0")}`;
  };

  const timeRemaining = Math.max(0, maxTime - timeElapsed);

  const handleCancel = () => {
    const confirmed = window.confirm(
      "AI 글 생성을 취소하시겠습니까? 진행 중인 작업이 중단됩니다."
    );
    if (confirmed) {
      onCancel();
    }
  };

  // Error state
  if (error) {
    const isQuotaError = error.message.includes("생성 횟수 제한");
    const isAIError = error.message.includes("AI 글 생성에 실패");

    return (
      <Card
        className="p-6"
        style={{
          borderColor: "#E1E5EA",
          borderRadius: "12px",
        }}
      >
        <Alert
          variant="destructive"
          className="mb-4"
          style={{ borderColor: "#EF4444" }}
        >
          <AlertCircle className="h-4 w-4" />
          <AlertDescription>
            {isQuotaError ? (
              <div>
                <p className="font-semibold mb-2">생성 횟수 제한에 도달했습니다</p>
                <p className="text-sm">{error.message}</p>
                <p className="text-sm mt-2">
                  더 많은 글을 생성하려면 플랜을 업그레이드해주세요.
                </p>
              </div>
            ) : isAIError ? (
              <div>
                <p className="font-semibold mb-2">AI 글 생성에 실패했습니다</p>
                <p className="text-sm">{error.message}</p>
                <p className="text-sm mt-2">
                  잠시 후 다시 시도해주세요. 문제가 계속되면 고객 지원팀에 문의해주세요.
                </p>
              </div>
            ) : (
              <div>
                <p className="font-semibold mb-2">오류가 발생했습니다</p>
                <p className="text-sm">{error.message}</p>
              </div>
            )}
          </AlertDescription>
        </Alert>

        <div className="flex gap-2">
          {!isQuotaError && (
            <Button
              onClick={onRetry}
              className="flex-1"
              style={{
                backgroundColor: "#3BA2F8",
                borderRadius: "8px",
              }}
            >
              <RefreshCw className="mr-2 h-4 w-4" />
              다시 시도
            </Button>
          )}
          <Button
            onClick={onCancel}
            variant="outline"
            className="flex-1"
            style={{ borderRadius: "8px" }}
          >
            취소
          </Button>
        </div>
      </Card>
    );
  }

  // Loading state
  if (!isGenerating) {
    return null;
  }

  return (
    <Card
      className="p-6"
      style={{
        borderColor: "#E1E5EA",
        borderRadius: "12px",
      }}
      role="status"
      aria-live="polite"
      aria-label="AI 글 생성 진행 중"
    >
      {/* Header */}
      <div className="mb-6">
        <div className="flex items-start justify-between mb-4">
          <div className="flex items-center gap-2">
            <div
              className="p-2 rounded-lg"
              style={{ backgroundColor: "#EFF6FF" }}
            >
              <Sparkles className="h-5 w-5" style={{ color: "#3BA2F8" }} />
            </div>
            <div>
              <h3
                className="font-semibold text-lg"
                style={{ color: "#1F2937" }}
              >
                AI가 글을 작성하고 있습니다
              </h3>
              <p className="text-sm" style={{ color: "#6B7280" }}>
                잠시만 기다려주세요
              </p>
            </div>
          </div>
          <Button
            variant="ghost"
            size="icon"
            onClick={handleCancel}
            aria-label="취소"
            style={{ color: "#6B7280" }}
          >
            <X className="h-4 w-4" />
          </Button>
        </div>

        {/* Progress Bar */}
        <div className="space-y-2">
          <div className="flex items-center justify-between text-sm">
            <span style={{ color: "#6B7280" }}>진행률</span>
            <span
              className="font-semibold"
              style={{ color: "#3BA2F8" }}
              aria-label={`진행률 ${Math.round(progress)}%`}
            >
              {Math.round(progress)}%
            </span>
          </div>
          <Progress
            value={progress}
            className="h-2"
            aria-valuenow={progress}
            aria-valuemin={0}
            aria-valuemax={100}
          />
        </div>

        {/* Timer */}
        <div
          className="mt-4 flex items-center gap-2 text-sm"
          style={{ color: "#6B7280" }}
        >
          <Clock className="h-4 w-4" />
          <span>
            남은 시간: <span className="font-mono">{formatTime(timeRemaining)}</span>
          </span>
        </div>
      </div>

      {/* Skeleton Preview */}
      <div className="space-y-4 mb-6">
        <div>
          <Skeleton className="h-8 w-3/4 mb-2" />
          <Skeleton className="h-4 w-1/2" />
        </div>
        <div className="space-y-2">
          <Skeleton className="h-4 w-full" />
          <Skeleton className="h-4 w-full" />
          <Skeleton className="h-4 w-5/6" />
        </div>
        <div className="space-y-2">
          <Skeleton className="h-4 w-full" />
          <Skeleton className="h-4 w-full" />
          <Skeleton className="h-4 w-4/5" />
        </div>
      </div>

      {/* Motivational Message */}
      <div
        className="p-4 rounded-lg"
        style={{ backgroundColor: "#F0FDF4" }}
      >
        <p className="text-sm font-medium" style={{ color: "#16A34A" }}>
          💡 이 글을 직접 작성하면 약 50분이 걸립니다. AI가 당신의 시간을 절약해드립니다!
        </p>
      </div>

      {/* Cancel Button */}
      <div className="mt-4">
        <Button
          onClick={handleCancel}
          variant="outline"
          className="w-full"
          style={{ borderRadius: "8px" }}
        >
          취소
        </Button>
      </div>
    </Card>
  );
}
</file>

<file path="src/features/articles/components/markdown-preview.tsx">
'use client';

import ReactMarkdown from 'react-markdown';
import rehypeSanitize from 'rehype-sanitize';
import rehypeHighlight from 'rehype-highlight';
import remarkGfm from 'remark-gfm';
import 'highlight.js/styles/github.css';

interface MarkdownPreviewProps {
  content: string;
}

export function MarkdownPreview({ content }: MarkdownPreviewProps) {
  return (
    <div className="prose prose-slate max-w-none dark:prose-invert">
      <ReactMarkdown
        remarkPlugins={[remarkGfm]}
        rehypePlugins={[rehypeSanitize, rehypeHighlight]}
      >
        {content}
      </ReactMarkdown>
    </div>
  );
}
</file>

<file path="src/features/articles/components/seo-panel.tsx">
"use client";

import { Card } from "@/components/ui/card";
import { Badge } from "@/components/ui/badge";
import {
  Search,
  CheckCircle2,
  AlertCircle,
  XCircle,
  Info,
} from "lucide-react";
import type { ArticleFormData } from "../lib/article-form-schema";

interface SeoCheckItem {
  label: string;
  status: "pass" | "warning" | "fail" | "info";
  message: string;
}

interface SeoPanelProps {
  formData: ArticleFormData;
}

export function SeoPanel({ formData }: SeoPanelProps) {
  const checks: SeoCheckItem[] = [
    // Title checks
    {
      label: "제목 길이",
      status: formData.title
        ? formData.title.length >= 30 && formData.title.length <= 60
          ? "pass"
          : formData.title.length > 60
            ? "warning"
            : "info"
        : "info",
      message: formData.title
        ? `${formData.title.length}자 (권장: 30-60자)`
        : "제목을 입력하세요",
    },
    // Meta title
    {
      label: "Meta 제목",
      status: formData.metaTitle
        ? formData.metaTitle.length <= 60
          ? "pass"
          : "warning"
        : "info",
      message: formData.metaTitle
        ? `${formData.metaTitle.length}자 (최대: 60자)`
        : "Meta 제목을 입력하면 검색 결과에 표시됩니다",
    },
    // Meta description
    {
      label: "Meta 설명",
      status: formData.metaDescription
        ? formData.metaDescription.length >= 120 &&
          formData.metaDescription.length <= 160
          ? "pass"
          : formData.metaDescription.length > 160
            ? "warning"
            : "info"
        : "info",
      message: formData.metaDescription
        ? `${formData.metaDescription.length}자 (권장: 120-160자)`
        : "Meta 설명을 입력하면 검색 결과에 표시됩니다",
    },
    // Slug
    {
      label: "URL 슬러그",
      status: formData.slug
        ? /^[a-z0-9]+(?:-[a-z0-9]+)*$/.test(formData.slug)
          ? "pass"
          : "fail"
        : "info",
      message: formData.slug
        ? /^[a-z0-9]+(?:-[a-z0-9]+)*$/.test(formData.slug)
          ? "올바른 형식입니다"
          : "소문자, 숫자, 하이픈만 사용 가능합니다"
        : "URL 슬러그를 입력하세요",
    },
    // Keywords
    {
      label: "키워드",
      status:
        formData.keywords && formData.keywords.length > 0
          ? formData.keywords.length >= 3 && formData.keywords.length <= 10
            ? "pass"
            : "warning"
          : "info",
      message:
        formData.keywords && formData.keywords.length > 0
          ? `${formData.keywords.length}개 키워드 (권장: 3-10개)`
          : "키워드를 3-10개 추가하세요",
    },
    // Content length
    {
      label: "본문 길이",
      status: formData.content
        ? formData.content.length >= 300
          ? "pass"
          : "info"
        : "info",
      message: formData.content
        ? `${formData.content.length}자 (최소 권장: 300자)`
        : "본문을 입력하세요",
    },
  ];

  const passCount = checks.filter((c) => c.status === "pass").length;
  const totalCount = checks.length;
  const score = Math.round((passCount / totalCount) * 100);

  const getStatusIcon = (status: SeoCheckItem["status"]) => {
    switch (status) {
      case "pass":
        return <CheckCircle2 className="h-4 w-4" style={{ color: "#10B981" }} />;
      case "warning":
        return <AlertCircle className="h-4 w-4" style={{ color: "#F59E0B" }} />;
      case "fail":
        return <XCircle className="h-4 w-4" style={{ color: "#DC2626" }} />;
      case "info":
        return <Info className="h-4 w-4" style={{ color: "#6B7280" }} />;
    }
  };

  const getStatusColor = (status: SeoCheckItem["status"]) => {
    switch (status) {
      case "pass":
        return "#10B981";
      case "warning":
        return "#F59E0B";
      case "fail":
        return "#DC2626";
      case "info":
        return "#6B7280";
    }
  };

  const getScoreColor = (score: number) => {
    if (score >= 80) return "#10B981";
    if (score >= 50) return "#F59E0B";
    return "#DC2626";
  };

  return (
    <Card
      className="sticky top-4 h-fit overflow-hidden"
      style={{
        borderColor: "#E1E5EA",
        borderRadius: "12px",
      }}
    >
      <div
        className="border-b px-6 py-4"
        style={{ borderColor: "#E1E5EA", backgroundColor: "#F9FAFB" }}
      >
        <div className="flex items-center justify-between">
          <h3 className="flex items-center gap-2 text-lg font-semibold">
            <Search className="h-5 w-5" style={{ color: "#3BA2F8" }} />
            SEO 점검
          </h3>
          <Badge
            variant="secondary"
            className="text-base font-bold"
            style={{
              backgroundColor: getScoreColor(score) + "20",
              color: getScoreColor(score),
            }}
          >
            {score}점
          </Badge>
        </div>
        <p className="mt-1 text-xs" style={{ color: "#6B7280" }}>
          {passCount}/{totalCount} 항목 통과
        </p>
      </div>

      <div className="divide-y" style={{ borderColor: "#E1E5EA" }}>
        {checks.map((check, index) => (
          <div key={index} className="px-6 py-4">
            <div className="flex items-start gap-3">
              <div className="mt-0.5">{getStatusIcon(check.status)}</div>
              <div className="flex-1 space-y-1">
                <div className="flex items-center justify-between">
                  <h4
                    className="text-sm font-medium"
                    style={{ color: "#374151" }}
                  >
                    {check.label}
                  </h4>
                </div>
                <p
                  className="text-xs leading-relaxed"
                  style={{ color: getStatusColor(check.status) }}
                >
                  {check.message}
                </p>
              </div>
            </div>
          </div>
        ))}
      </div>

      <div
        className="border-t px-6 py-4"
        style={{ borderColor: "#E1E5EA", backgroundColor: "#F9FAFB" }}
      >
        <div className="space-y-2">
          <h4
            className="text-xs font-semibold uppercase"
            style={{ color: "#6B7280" }}
          >
            SEO 개선 팁
          </h4>
          <ul
            className="space-y-1.5 text-xs leading-relaxed"
            style={{ color: "#6B7280" }}
          >
            <li>• 제목은 주요 키워드를 포함하고 30-60자로 작성</li>
            <li>• Meta 설명은 클릭을 유도하는 내용으로 120-160자</li>
            <li>• URL은 짧고 의미있는 키워드로 구성</li>
            <li>• 키워드는 자연스럽게 본문에 포함</li>
          </ul>
        </div>
      </div>
    </Card>
  );
}
</file>

<file path="src/features/articles/components/table-of-contents.tsx">
'use client';

import { Card } from '@/components/ui/card';
import { Button } from '@/components/ui/button';
import { List } from 'lucide-react';
import type { Heading } from '../lib/markdown-utils';

interface TableOfContentsProps {
  headings: Heading[];
  currentHeadingId?: string;
}

export function TableOfContents({
  headings,
  currentHeadingId,
}: TableOfContentsProps) {
  if (headings.length === 0) {
    return null;
  }

  return (
    <Card className="p-4">
      <div className="flex items-center gap-2 mb-4">
        <List className="h-4 w-4" />
        <h3 className="font-semibold">목차</h3>
      </div>
      <nav className="space-y-1">
        {headings.map((heading) => (
          <Button
            key={heading.id}
            variant="ghost"
            className={`w-full justify-start text-left ${
              heading.level > 1 ? `pl-${(heading.level - 1) * 4}` : ''
            } ${currentHeadingId === heading.id ? 'bg-accent' : ''}`}
            onClick={() => {
              const element = document.getElementById(heading.id);
              element?.scrollIntoView({ behavior: 'smooth' });
            }}
          >
            {heading.text}
          </Button>
        ))}
      </nav>
    </Card>
  );
}
</file>

<file path="src/features/articles/hooks/useArticle.ts">
"use client";

import { useQuery } from "@tanstack/react-query";
import { getArticle } from "../actions/article-actions";
import type { ArticleResponse } from "../lib/dto";

export const useArticle = (articleId: string | null) => {
  return useQuery<ArticleResponse, Error>({
    queryKey: ["article", articleId],
    queryFn: () => {
      if (!articleId) {
        throw new Error("Article ID is required");
      }
      return getArticle(articleId);
    },
    enabled: !!articleId,
  });
};
</file>

<file path="src/features/articles/hooks/useAutoSave.ts">
'use client';

import { useEffect, useState } from 'react';
import { useDebounce } from 'react-use';
import { useUpdateArticle } from './useUpdateArticle';
import type { UpdateArticleRequest } from '../lib/dto';

export function useAutoSave(articleId: string, formData: UpdateArticleRequest) {
  const [debouncedData, setDebouncedData] = useState(formData);
  const updateMutation = useUpdateArticle();
  const [hasChanges, setHasChanges] = useState(false);

  // 2초 디바운스
  useDebounce(
    () => {
      setDebouncedData(formData);
      setHasChanges(true);
    },
    2000,
    [formData]
  );

  // 디바운스된 데이터 변경 시 자동 저장
  useEffect(() => {
    if (hasChanges && debouncedData) {
      updateMutation.mutate({
        articleId,
        data: debouncedData,
      });
      setHasChanges(false);
    }
  }, [debouncedData, hasChanges, articleId, updateMutation]);

  return {
    isSaving: updateMutation.isPending,
    isError: updateMutation.isError,
    error: updateMutation.error,
    lastSavedAt: updateMutation.data?.updatedAt,
  };
}
</file>

<file path="src/features/articles/hooks/useCreateArticle.ts">
"use client";

import { useMutation, useQueryClient } from "@tanstack/react-query";
import { createArticleDraft } from "../actions/article-actions";
import type { CreateArticleRequest, ArticleResponse } from "../lib/dto";

export const useCreateArticle = () => {
  const queryClient = useQueryClient();

  return useMutation<ArticleResponse, Error, CreateArticleRequest>({
    mutationFn: createArticleDraft,
    onSuccess: (data) => {
      queryClient.invalidateQueries({ queryKey: ["articles"] });
      queryClient.setQueryData(["article", data.id], data);
    },
  });
};
</file>

<file path="src/features/articles/hooks/useStyleGuide.ts">
"use client";

import { useQuery } from "@tanstack/react-query";
import { getUserStyleGuide } from "../actions/article-actions";

export interface StyleGuideData {
  id: string;
  clerkUserId: string;
  brandName: string;
  brandDescription: string;
  personality: string[];
  formality: "casual" | "neutral" | "formal";
  targetAudience: string;
  painPoints: string;
  language: "ko" | "en";
  tone: "professional" | "friendly" | "inspirational" | "educational";
  contentLength: "short" | "medium" | "long";
  readingLevel: "beginner" | "intermediate" | "advanced";
  notes: string | null;
  isDefault: boolean;
  createdAt: string;
  updatedAt: string;
}

export const useStyleGuide = () => {
  return useQuery<StyleGuideData, Error>({
    queryKey: ["styleGuide"],
    queryFn: getUserStyleGuide,
  });
};
</file>

<file path="src/features/articles/hooks/useUpdateArticle.ts">
"use client";

import { useMutation, useQueryClient } from "@tanstack/react-query";
import { updateArticleDraft } from "../actions/article-actions";
import type { UpdateArticleRequest, ArticleResponse } from "../lib/dto";

interface UpdateArticleVariables {
  articleId: string;
  data: UpdateArticleRequest;
}

export const useUpdateArticle = () => {
  const queryClient = useQueryClient();

  return useMutation<ArticleResponse, Error, UpdateArticleVariables>({
    mutationFn: ({ articleId, data }) => updateArticleDraft(articleId, data),
    onSuccess: (data) => {
      queryClient.invalidateQueries({ queryKey: ["articles"] });
      queryClient.setQueryData(["article", data.id], data);
    },
  });
};
</file>

<file path="src/features/articles/lib/article-form-schema.ts">
import { z } from "zod";
import {
  CreateArticleRequestSchema,
  ContentToneSchema,
  ContentLengthSchema,
  ReadingLevelSchema,
} from "./dto";

export const ArticleFormSchema = CreateArticleRequestSchema;

export type ArticleFormData = z.infer<typeof ArticleFormSchema>;

export const defaultArticleFormValues: ArticleFormData = {
  title: "",
  slug: "",
  keywords: [],
  description: "",
  content: "",
  styleGuideId: undefined,
  tone: undefined,
  contentLength: undefined,
  readingLevel: undefined,
  metaTitle: "",
  metaDescription: "",
};

// Export enums for use in form components
export { ContentToneSchema, ContentLengthSchema, ReadingLevelSchema };

// Helper to generate slug from title
export const generateSlug = (title: string): string => {
  return title
    .toLowerCase()
    .trim()
    .replace(/[^\w\s가-힣-]/g, "") // Remove special chars except Korean
    .replace(/\s+/g, "-") // Replace spaces with hyphens
    .replace(/-+/g, "-") // Remove consecutive hyphens
    .replace(/^-|-$/g, ""); // Remove leading/trailing hyphens
};
</file>

<file path="src/features/articles/lib/article-schema.ts">
import { z } from 'zod';

// Reuse style schema from onboarding
import { styleSchema } from '@/features/onboarding/lib/onboarding-schema';

// Article Draft Form Schema
export const articleDraftSchema = z.object({
  title: z
    .string()
    .min(1, '제목을 입력해주세요')
    .max(200, '제목은 200자 이내로 입력해주세요'),
  slug: z
    .string()
    .min(1, 'URL 슬러그를 입력해주세요')
    .max(200, '슬러그는 200자 이내로 입력해주세요')
    .regex(
      /^[a-z0-9]+(?:-[a-z0-9]+)*$/,
      '슬러그는 소문자, 숫자, 하이픈(-)만 사용 가능합니다',
    ),
  keywords: z.array(z.string()).default([]),
  description: z.string().max(500, '설명은 500자 이내로 입력해주세요').optional(),
  content: z.string().min(1, '내용을 입력해주세요'),
  // Style overrides (optional - uses style guide defaults if not provided)
  tone: styleSchema.shape.tone.optional(),
  contentLength: styleSchema.shape.contentLength.optional(),
  readingLevel: styleSchema.shape.readingLevel.optional(),
  // SEO metadata
  metaTitle: z.string().max(60, 'Meta 제목은 60자 이내로 입력해주세요').optional(),
  metaDescription: z
    .string()
    .max(160, 'Meta 설명은 160자 이내로 입력해주세요')
    .optional(),
});

export type ArticleDraftFormData = z.infer<typeof articleDraftSchema>;

// Default values for the article draft form
export const defaultArticleDraftValues: ArticleDraftFormData = {
  title: '',
  slug: '',
  keywords: [],
  description: '',
  content: '',
  metaTitle: '',
  metaDescription: '',
};
</file>

<file path="src/features/auth/hooks/useCurrentUser.ts">
"use client";

import { useMemo } from "react";
import { useCurrentUserContext } from "../context/current-user-context";

export const useCurrentUser = () => {
  const context = useCurrentUserContext();

  return useMemo(
    () => ({
      user: context.user,
      status: context.status,
      isAuthenticated: context.isAuthenticated,
      isLoading: context.isLoading,
      refresh: context.refresh,
    }),
    [context]
  );
};
</file>

<file path="src/features/auth/types.ts">
export type CurrentUser = {
  id: string;
  email: string | null;
  appMetadata: Record<string, unknown>;
  userMetadata: Record<string, unknown>;
};

export type CurrentUserSnapshot =
  | { status: "authenticated"; user: CurrentUser }
  | { status: "unauthenticated"; user: null }
  | { status: "loading"; user: CurrentUser | null };

export type CurrentUserContextValue = CurrentUserSnapshot & {
  refresh: () => Promise<void>;
  isAuthenticated: boolean;
  isLoading: boolean;
};
</file>

<file path="src/features/example/backend/error.ts">
export const exampleErrorCodes = {
  notFound: 'EXAMPLE_NOT_FOUND',
  fetchError: 'EXAMPLE_FETCH_ERROR',
  validationError: 'EXAMPLE_VALIDATION_ERROR',
} as const;

type ExampleErrorValue = (typeof exampleErrorCodes)[keyof typeof exampleErrorCodes];

export type ExampleServiceError = ExampleErrorValue;
</file>

<file path="src/features/example/backend/route.ts">
import type { Hono } from 'hono';
import {
  failure,
  respond,
  type ErrorResult,
} from '@/backend/http/response';
import {
  getLogger,
  getSupabase,
  type AppEnv,
} from '@/backend/hono/context';
import { ExampleParamsSchema } from '@/features/example/backend/schema';
import { getExampleById } from './service';
import {
  exampleErrorCodes,
  type ExampleServiceError,
} from './error';

export const registerExampleRoutes = (app: Hono<AppEnv>) => {
  app.get('/example/:id', async (c) => {
    const parsedParams = ExampleParamsSchema.safeParse({ id: c.req.param('id') });

    if (!parsedParams.success) {
      return respond(
        c,
        failure(
          400,
          'INVALID_EXAMPLE_PARAMS',
          'The provided example id is invalid.',
          parsedParams.error.format(),
        ),
      );
    }

    const supabase = getSupabase(c);
    const logger = getLogger(c);

    const result = await getExampleById(supabase, parsedParams.data.id);

    if (!result.ok) {
      const errorResult = result as ErrorResult<ExampleServiceError, unknown>;

      if (errorResult.error.code === exampleErrorCodes.fetchError) {
        logger.error('Failed to fetch example', errorResult.error.message);
      }

      return respond(c, result);
    }

    return respond(c, result);
  });
};
</file>

<file path="src/features/example/backend/schema.ts">
import { z } from 'zod';

export const ExampleParamsSchema = z.object({
  id: z.string().uuid({ message: 'Example id must be a valid UUID.' }),
});

export const ExampleResponseSchema = z.object({
  id: z.string().uuid(),
  fullName: z.string(),
  avatarUrl: z.string().url(),
  bio: z.string().nullable(),
  updatedAt: z.string(),
});

export type ExampleResponse = z.infer<typeof ExampleResponseSchema>;

export const ExampleTableRowSchema = z.object({
  id: z.string().uuid(),
  full_name: z.string().nullable(),
  avatar_url: z.string().nullable(),
  bio: z.string().nullable(),
  updated_at: z.string(),
});

export type ExampleRow = z.infer<typeof ExampleTableRowSchema>;
</file>

<file path="src/features/example/backend/service.ts">
import type { SupabaseClient } from '@supabase/supabase-js';
import {
  failure,
  success,
  type HandlerResult,
} from '@/backend/http/response';
import {
  ExampleResponseSchema,
  ExampleTableRowSchema,
  type ExampleResponse,
  type ExampleRow,
} from '@/features/example/backend/schema';
import {
  exampleErrorCodes,
  type ExampleServiceError,
} from '@/features/example/backend/error';

const EXAMPLE_TABLE = 'example';

const fallbackAvatar = (id: string) =>
  `https://picsum.photos/seed/${encodeURIComponent(id)}/200/200`;

export const getExampleById = async (
  client: SupabaseClient,
  id: string,
): Promise<HandlerResult<ExampleResponse, ExampleServiceError, unknown>> => {
  const { data, error } = await client
    .from(EXAMPLE_TABLE)
    .select('id, full_name, avatar_url, bio, updated_at')
    .eq('id', id)
    .maybeSingle<ExampleRow>();

  if (error) {
    return failure(500, exampleErrorCodes.fetchError, error.message);
  }

  if (!data) {
    return failure(404, exampleErrorCodes.notFound, 'Example not found');
  }

  const rowParse = ExampleTableRowSchema.safeParse(data);

  if (!rowParse.success) {
    return failure(
      500,
      exampleErrorCodes.validationError,
      'Example row failed validation.',
      rowParse.error.format(),
    );
  }

  const mapped = {
    id: rowParse.data.id,
    fullName: rowParse.data.full_name ?? 'Anonymous User',
    avatarUrl:
      rowParse.data.avatar_url ?? fallbackAvatar(rowParse.data.id),
    bio: rowParse.data.bio,
    updatedAt: rowParse.data.updated_at,
  } satisfies ExampleResponse;

  const parsed = ExampleResponseSchema.safeParse(mapped);

  if (!parsed.success) {
    return failure(
      500,
      exampleErrorCodes.validationError,
      'Example payload failed validation.',
      parsed.error.format(),
    );
  }

  return success(parsed.data);
};
</file>

<file path="src/features/example/components/example-status.test.tsx">
import { describe, it, expect, vi } from 'vitest';
import { render, screen } from '@testing-library/react';
import userEvent from '@testing-library/user-event';
import { QueryClient, QueryClientProvider } from '@tanstack/react-query';
import { ExampleStatus } from './example-status';

// Mock the API client
vi.mock('@/lib/remote/api-client', () => ({
  apiClient: {
    get: vi.fn(),
  },
  extractApiErrorMessage: vi.fn((error, defaultMsg) => defaultMsg),
}));

const createWrapper = () => {
  const queryClient = new QueryClient({
    defaultOptions: {
      queries: {
        retry: false,
        gcTime: 0,
      },
    },
  });

  function Wrapper({ children }: { children: React.ReactNode }) {
    return (
      <QueryClientProvider client={queryClient}>{children}</QueryClientProvider>
    );
  }

  return Wrapper;
};

describe('ExampleStatus', () => {
  it('should render the component correctly', () => {
    render(<ExampleStatus />, { wrapper: createWrapper() });

    expect(screen.getByText(/Backend Health Check/i)).toBeInTheDocument();
    expect(screen.getByPlaceholderText(/00000000-0000-0000-0000-000000000000/i)).toBeInTheDocument();
    expect(screen.getByRole('button', { name: /조회하기/i })).toBeInTheDocument();
  });

  it('should display idle status initially', () => {
    render(<ExampleStatus />, { wrapper: createWrapper() });

    expect(screen.getByText(/Idle/i)).toBeInTheDocument();
    expect(screen.getByText(/UUID를 입력하고 조회하기 버튼을 누르면/i)).toBeInTheDocument();
  });

  it('should update input value when user types', async () => {
    const user = userEvent.setup();
    render(<ExampleStatus />, { wrapper: createWrapper() });

    const input = screen.getByPlaceholderText(/00000000-0000-0000-0000-000000000000/i);

    await user.type(input, 'test-id');

    expect(input).toHaveValue('test-id');
  });

  it('should clear results when empty input is submitted', async () => {
    const user = userEvent.setup();
    render(<ExampleStatus />, { wrapper: createWrapper() });

    const input = screen.getByPlaceholderText(/00000000-0000-0000-0000-000000000000/i);
    const button = screen.getByRole('button', { name: /조회하기/i });

    // Submit empty input
    await user.type(input, '   ');
    await user.click(button);

    expect(screen.getByText(/Idle/i)).toBeInTheDocument();
  });

  it('should show current status header', () => {
    render(<ExampleStatus />, { wrapper: createWrapper() });

    expect(screen.getByText(/현재 상태/i)).toBeInTheDocument();
  });

  it('should have accessible form elements', () => {
    render(<ExampleStatus />, { wrapper: createWrapper() });

    const input = screen.getByPlaceholderText(/00000000-0000-0000-0000-000000000000/i);
    const button = screen.getByRole('button', { name: /조회하기/i });

    expect(input).toBeInTheDocument();
    expect(button).toBeInTheDocument();
  });

  it('should display description text', () => {
    render(<ExampleStatus />, { wrapper: createWrapper() });

    expect(screen.getByText(/예시 API/i)).toBeInTheDocument();
    expect(screen.getByText(/Supabase 예시 레코드의 UUID를 입력하면/i)).toBeInTheDocument();
  });
});
</file>

<file path="src/features/example/components/example-status.tsx">
'use client';

import { useState } from 'react';
import type { FormEvent } from 'react';
import { Button } from '@/components/ui/button';
import { Input } from '@/components/ui/input';
import { useExampleQuery } from '@/features/example/hooks/useExampleQuery';

const statusBadge = (
  label: string,
  tone: 'success' | 'error' | 'idle',
) => {
  const toneStyles: Record<typeof tone, string> = {
    success: 'bg-emerald-500/10 text-emerald-300 border-emerald-400/40',
    error: 'bg-rose-500/10 text-rose-300 border-rose-400/40',
    idle: 'bg-slate-500/10 text-slate-200 border-slate-400/30',
  };

  return (
    <span
      className={`inline-flex items-center rounded-full border px-2.5 py-0.5 text-xs font-medium ${toneStyles[tone]}`}
    >
      {label}
    </span>
  );
};

export const ExampleStatus = () => {
  const [inputValue, setInputValue] = useState('');
  const [exampleId, setExampleId] = useState('');
  const query = useExampleQuery(exampleId);

  const handleSubmit = (event: FormEvent<HTMLFormElement>) => {
    event.preventDefault();
    const trimmed = inputValue.trim();

    if (!trimmed) {
      setExampleId('');
      return;
    }

    if (trimmed === exampleId) {
      void query.refetch();
      return;
    }

    setExampleId(trimmed);
  };

  return (
    <section className="mx-auto flex w-full max-w-3xl flex-col gap-6">
      <header className="space-y-2 text-slate-100">
        <h1 className="text-3xl font-semibold tracking-tight">Backend Health Check</h1>
        <p className="text-sm text-slate-300">
          예시 API(`/api/example/:id`)가 정상 동작하는지 확인합니다. Supabase 예시
          레코드의 UUID를 입력하면 React Query를 통해 백엔드 응답을 확인할 수
          있습니다.
        </p>
      </header>

      <form
        onSubmit={handleSubmit}
        className="flex flex-col gap-3 rounded-xl border border-slate-800 bg-slate-950/60 p-4 md:flex-row md:items-center"
      >
        <div className="flex-1 space-y-1">
          <label className="text-xs uppercase tracking-wide text-slate-400">
            Example UUID
          </label>
          <Input
            value={inputValue}
            onChange={(event) => setInputValue(event.target.value)}
            placeholder="00000000-0000-0000-0000-000000000000"
            className="bg-slate-900/70 text-slate-100 placeholder:text-slate-600"
          />
        </div>
        <Button
          type="submit"
          variant="secondary"
          className="mt-2 h-12 rounded-lg border border-slate-600 bg-slate-800 text-slate-100 hover:bg-slate-700 md:mt-6"
        >
          조회하기
        </Button>
      </form>

      <article className="space-y-3 rounded-xl border border-slate-800 bg-slate-950/60 p-6 text-slate-100">
        <div className="flex items-center justify-between">
          <h2 className="text-lg font-semibold">현재 상태</h2>
          {exampleId
            ? query.status === 'pending'
              ? statusBadge('Fetching', 'idle')
              : query.status === 'error'
                ? statusBadge('Error', 'error')
                : statusBadge('Success', 'success')
            : statusBadge('Idle', 'idle')}
        </div>

        {!exampleId && (
          <p className="text-sm text-slate-300">
            UUID를 입력하고 조회하기 버튼을 누르면 결과가 이곳에 표시됩니다.
          </p>
        )}

        {exampleId && query.status === 'pending' && (
          <p className="text-sm text-slate-300">Supabase에서 데이터를 가져오는 중...</p>
        )}

        {query.status === 'error' && (
          <div className="space-y-2 rounded-lg border border-rose-400/30 bg-rose-500/5 p-4">
            <p className="text-sm font-medium text-rose-300">요청 실패</p>
            <p className="text-xs text-rose-200/80">
              {query.error instanceof Error
                ? query.error.message
                : '알 수 없는 에러가 발생했습니다.'}
            </p>
          </div>
        )}

        {query.data && (
          <div className="space-y-3 rounded-lg border border-emerald-400/30 bg-emerald-500/5 p-4 text-sm text-emerald-100">
            <div>
              <p className="text-xs uppercase tracking-wide text-emerald-300">ID</p>
              <p className="font-mono text-xs md:text-sm">{query.data.id}</p>
            </div>
            <div>
              <p className="text-xs uppercase tracking-wide text-emerald-300">
                이름
              </p>
              <p>{query.data.fullName}</p>
            </div>
            <div>
              <p className="text-xs uppercase tracking-wide text-emerald-300">
                소개
              </p>
              <p>{query.data.bio ?? '—'}</p>
            </div>
            <div>
              <p className="text-xs uppercase tracking-wide text-emerald-300">
                아바타
              </p>
              <a
                href={query.data.avatarUrl}
                target="_blank"
                rel="noreferrer"
                className="underline"
              >
                {query.data.avatarUrl}
              </a>
            </div>
            <div>
              <p className="text-xs uppercase tracking-wide text-emerald-300">
                업데이트 시각
              </p>
              <p>{query.data.updatedAt}</p>
            </div>
          </div>
        )}
      </article>
    </section>
  );
};
</file>

<file path="src/features/example/hooks/useExampleQuery.ts">
'use client';

import { useQuery } from '@tanstack/react-query';
import { apiClient, extractApiErrorMessage } from '@/lib/remote/api-client';
import { ExampleResponseSchema } from '@/features/example/lib/dto';

const fetchExample = async (id: string) => {
  try {
    const { data } = await apiClient.get(`/api/example/${id}`);
    return ExampleResponseSchema.parse(data);
  } catch (error) {
    const message = extractApiErrorMessage(error, 'Failed to fetch example.');
    throw new Error(message);
  }
};

export const useExampleQuery = (id: string) =>
  useQuery({
    queryKey: ['example', id],
    queryFn: () => fetchExample(id),
    enabled: Boolean(id),
    staleTime: 60 * 1000,
  });
</file>

<file path="src/features/example/lib/dto.test.ts">
import { describe, it, expect } from 'vitest';
import { ExampleResponseSchema } from './dto';

describe('ExampleResponseSchema', () => {
  it('should validate a correct example response', () => {
    const validData = {
      id: '123e4567-e89b-12d3-a456-426614174000',
      fullName: 'Test User',
      avatarUrl: 'https://example.com/avatar.jpg',
      bio: 'This is a test bio',
      updatedAt: '2024-01-01T00:00:00Z',
    };

    const result = ExampleResponseSchema.safeParse(validData);

    expect(result.success).toBe(true);
    if (result.success) {
      expect(result.data).toEqual(validData);
    }
  });

  it('should allow null bio', () => {
    const validData = {
      id: '123e4567-e89b-12d3-a456-426614174000',
      fullName: 'Test User',
      avatarUrl: 'https://example.com/avatar.jpg',
      bio: null,
      updatedAt: '2024-01-01T00:00:00Z',
    };

    const result = ExampleResponseSchema.safeParse(validData);

    expect(result.success).toBe(true);
  });

  it('should reject invalid data structure', () => {
    const invalidData = {
      id: 123, // should be string
      fullName: 'Test User',
    };

    const result = ExampleResponseSchema.safeParse(invalidData);

    expect(result.success).toBe(false);
  });

  it('should reject missing required fields', () => {
    const invalidData = {
      id: 'test-id',
      // missing fullName, avatarUrl, updatedAt
    };

    const result = ExampleResponseSchema.safeParse(invalidData);

    expect(result.success).toBe(false);
  });
});
</file>

<file path="src/features/example/lib/dto.ts">
export {
  ExampleParamsSchema,
  ExampleResponseSchema,
  type ExampleResponse,
} from '@/features/example/backend/schema';
</file>

<file path="src/features/landing/components/features-section.tsx">
"use client";

import { Sparkles, Search, Palette, Edit3 } from "lucide-react";

interface Feature {
  icon: React.ReactNode;
  title: string;
  description: string;
}

const features: Feature[] = [
  {
    icon: <Sparkles className="w-6 h-6" />,
    title: "AI 자동 생성",
    description: "1,500~2,500단어의 고품질 블로그 글을 AI가 자동으로 작성합니다. 키워드만 입력하면 전문적인 글이 완성됩니다.",
  },
  {
    icon: <Search className="w-6 h-6" />,
    title: "SEO 키워드 & 메타데이터",
    description: "검색 엔진 최적화를 위한 키워드, 메타 디스크립션, H 태그 구조가 자동으로 삽입되어 검색 노출을 극대화합니다.",
  },
  {
    icon: <Palette className="w-6 h-6" />,
    title: "브랜드 보이스 커스터마이징",
    description: "당신만의 브랜드 톤과 스타일을 설정하여 일관된 브랜드 보이스로 콘텐츠를 생성할 수 있습니다.",
  },
  {
    icon: <Edit3 className="w-6 h-6" />,
    title: "실시간 편집 & 재생성",
    description: "문단별로 실시간 수정 및 재생성이 가능합니다. 원하는 부분만 골라서 다시 생성할 수 있습니다.",
  },
];

export function FeaturesSection() {
  return (
    <section className="w-full bg-[#FCFCFD] py-20 px-4">
      <div className="max-w-6xl mx-auto">
        {/* Section Header */}
        <div className="text-center mb-16">
          <h2 className="text-3xl md:text-4xl font-bold text-[#111827] mb-4">
            강력한 기능으로 콘텐츠 생성을 간편하게
          </h2>
          <p className="text-lg text-[#6B7280] max-w-2xl mx-auto">
            AI 기반 자동 생성부터 SEO 최적화까지, 블로그 글 작성에 필요한 모든 기능을 제공합니다
          </p>
        </div>

        {/* Features Grid */}
        <div className="grid grid-cols-1 md:grid-cols-2 gap-8">
          {features.map((feature, index) => (
            <div
              key={index}
              className="group p-8 rounded-xl border border-[#E1E5EA] bg-white hover:border-[#3BA2F8] transition-all duration-300 hover:shadow-lg"
            >
              <div className="flex flex-col space-y-4">
                {/* Icon */}
                <div className="w-12 h-12 rounded-lg bg-[#F5F7FA] flex items-center justify-center text-[#3BA2F8] group-hover:bg-[#3BA2F8] group-hover:text-white transition-all duration-300">
                  {feature.icon}
                </div>

                {/* Content */}
                <div className="space-y-2">
                  <h3 className="text-xl font-semibold text-[#111827]">
                    {feature.title}
                  </h3>
                  <p className="text-base text-[#6B7280] leading-relaxed">
                    {feature.description}
                  </p>
                </div>
              </div>
            </div>
          ))}
        </div>
      </div>
    </section>
  );
}
</file>

<file path="src/features/landing/components/final-cta-section.tsx">
"use client";

import { ArrowRight } from "lucide-react";
import Link from "next/link";
import { Button } from "@/components/ui/button";

export function FinalCtaSection() {
  return (
    <section className="w-full bg-[#1E2A38] py-20 px-4">
      <div className="max-w-4xl mx-auto text-center">
        <div className="space-y-8">
          {/* Heading */}
          <h2 className="text-3xl md:text-5xl font-bold text-white leading-tight">
            지금 바로 첫 글을
            <br />
            5분 안에 완성하세요
          </h2>

          {/* Subheading */}
          <p className="text-lg md:text-xl text-[#D1D5DB] max-w-2xl mx-auto">
            신용카드 등록 없이 무료로 시작할 수 있습니다.
            <br />
            3편의 블로그 글을 무료로 생성해보세요.
          </p>

          {/* CTA Button */}
          <div className="flex flex-col sm:flex-row items-center justify-center gap-4 pt-4">
            <Button
              size="lg"
              className="px-8 py-6 text-base font-medium bg-[#3BA2F8] hover:bg-[#3BA2F8]/90 text-white rounded-lg shadow-lg"
              asChild
            >
              <Link href="/signup">
                무료로 시작하기
                <ArrowRight className="ml-2 h-5 w-5" />
              </Link>
            </Button>

            <Button
              size="lg"
              variant="outline"
              className="px-8 py-6 text-base font-medium bg-transparent hover:bg-white/10 text-white border-2 border-white/20 rounded-lg"
              asChild
            >
              <Link href="/login">로그인</Link>
            </Button>
          </div>

          {/* Trust Badge */}
          <div className="pt-8">
            <p className="text-sm text-[#9CA3AF]">
              ✓ 신용카드 불필요 · ✓ 3편 무료 체험 · ✓ 언제든 취소 가능
            </p>
          </div>
        </div>
      </div>
    </section>
  );
}
</file>

<file path="src/features/landing/components/hero-section.tsx">
"use client";

import { motion } from "framer-motion";
import { ArrowRight } from "lucide-react";
import Link from "next/link";
import { Button } from "@/components/ui/button";

interface HeroSectionProps {
  badge?: string;
  heading?: string;
  subheading?: string;
  ctaText?: string;
  ctaUrl?: string;
  secondaryText?: string;
}

export function HeroSection({
  badge = "AI 블로그 작성 도구",
  heading = "5분 안에 SEO 최적화된 블로그 글 완성",
  subheading = "인디해커와 솔로 창업자를 위한 AI 블로그 작성 도구. 키워드만 입력하면 영어·한국어 블로그 글과 SEO 메타데이터가 자동으로 완성됩니다.",
  ctaText = "무료로 시작하기",
  ctaUrl = "/signup",
  secondaryText = "3편까지 무료",
}: HeroSectionProps) {
  const fadeUpVariants = {
    hidden: { opacity: 0, y: 20 },
    visible: (i: number) => ({
      opacity: 1,
      y: 0,
      transition: {
        duration: 0.6,
        delay: i * 0.15,
        ease: [0.25, 0.4, 0.25, 1],
      },
    }),
  };

  return (
    <section className="relative min-h-[90vh] w-full flex items-center justify-center overflow-hidden bg-[#FCFCFD]">
      {/* Subtle background gradient */}
      <div className="absolute inset-0 bg-[radial-gradient(circle_at_50%_50%,rgba(30,42,56,0.03),transparent_50%)]" />

      <div className="relative z-10 container mx-auto px-4 md:px-6 max-w-4xl py-20">
        <div className="text-center">
          {/* Badge */}
          <motion.div
            custom={0}
            variants={fadeUpVariants}
            initial="hidden"
            animate="visible"
            className="inline-flex items-center gap-2 px-4 py-1.5 rounded-full border border-[#E1E5EA] bg-[#F5F7FA]/50 mb-8"
          >
            <span className="text-xs font-medium text-[#374151]">
              {badge}
            </span>
          </motion.div>

          {/* Main Heading */}
          <motion.div
            custom={1}
            variants={fadeUpVariants}
            initial="hidden"
            animate="visible"
          >
            <h1 className="text-4xl sm:text-5xl md:text-6xl lg:text-7xl font-bold mb-6 tracking-tight text-[#111827] leading-tight">
              {heading}
            </h1>
          </motion.div>

          {/* Subheading */}
          <motion.div
            custom={2}
            variants={fadeUpVariants}
            initial="hidden"
            animate="visible"
          >
            <p className="text-base sm:text-lg md:text-xl text-[#6B7280] mb-10 max-w-2xl mx-auto font-normal leading-relaxed">
              {subheading}
            </p>
          </motion.div>

          {/* CTA Button */}
          <motion.div
            custom={3}
            variants={fadeUpVariants}
            initial="hidden"
            animate="visible"
            className="flex flex-col items-center gap-3"
          >
            <Button
              size="lg"
              className="rounded-lg px-8 py-6 text-base font-medium bg-[#3BA2F8] hover:bg-[#3BA2F8]/90 text-white shadow-sm"
              asChild
            >
              <Link href={ctaUrl}>
                {ctaText}
                <ArrowRight className="ml-2 h-5 w-5" />
              </Link>
            </Button>

            {/* Secondary text */}
            {secondaryText && (
              <p className="text-sm text-[#6B7280]">
                {secondaryText}
              </p>
            )}
          </motion.div>
        </div>
      </div>

      {/* Bottom border */}
      <div className="absolute bottom-0 left-0 right-0 h-px bg-[#E1E5EA]" />
    </section>
  );
}
</file>

<file path="src/features/landing/components/how-it-works-section.tsx">
"use client";

import { Keyboard, Sparkles, FileEdit, ArrowRight } from "lucide-react";

interface Step {
  number: string;
  icon: React.ReactNode;
  title: string;
  description: string;
}

const steps: Step[] = [
  {
    number: "01",
    icon: <Keyboard className="w-8 h-8" />,
    title: "키워드 입력",
    description: "주제 키워드와 간단한 설명을 입력하고 원하는 브랜드 보이스를 선택합니다.",
  },
  {
    number: "02",
    icon: <Sparkles className="w-8 h-8" />,
    title: "AI 생성",
    description: "AI가 5분 내에 SEO 최적화된 초안, 제목, 메타데이터를 자동으로 생성합니다.",
  },
  {
    number: "03",
    icon: <FileEdit className="w-8 h-8" />,
    title: "편집 & 완성",
    description: "원스크린 편집기에서 문단별 수정 및 재생성을 통해 완벽한 글을 완성합니다.",
  },
];

export function HowItWorksSection() {
  return (
    <section className="w-full bg-white py-20 px-4">
      <div className="max-w-6xl mx-auto">
        {/* Section Header */}
        <div className="text-center mb-16">
          <h2 className="text-3xl md:text-4xl font-bold text-[#111827] mb-4">
            3단계로 완성하는 블로그 글
          </h2>
          <p className="text-lg text-[#6B7280] max-w-2xl mx-auto">
            복잡한 과정 없이 간단한 3단계만으로 전문적인 블로그 글을 완성할 수 있습니다
          </p>
        </div>

        {/* Steps */}
        <div className="grid grid-cols-1 md:grid-cols-3 gap-8 md:gap-4 relative">
          {steps.map((step, index) => (
            <div key={index} className="relative">
              {/* Step Card */}
              <div className="flex flex-col items-center text-center space-y-6 p-8 rounded-xl border border-[#E1E5EA] bg-[#FCFCFD] hover:border-[#3BA2F8] transition-all duration-300">
                {/* Step Number */}
                <div className="text-5xl font-bold text-[#E1E5EA]">
                  {step.number}
                </div>

                {/* Icon */}
                <div className="w-16 h-16 rounded-full bg-[#3BA2F8] flex items-center justify-center text-white">
                  {step.icon}
                </div>

                {/* Content */}
                <div className="space-y-3">
                  <h3 className="text-xl font-semibold text-[#111827]">
                    {step.title}
                  </h3>
                  <p className="text-base text-[#6B7280] leading-relaxed">
                    {step.description}
                  </p>
                </div>
              </div>

              {/* Arrow between steps (hidden on mobile, last arrow hidden on all screens) */}
              {index < steps.length - 1 && (
                <div className="hidden md:block absolute top-1/2 -right-6 transform -translate-y-1/2 z-10">
                  <ArrowRight className="w-8 h-8 text-[#3BA2F8]" />
                </div>
              )}
            </div>
          ))}
        </div>

        {/* Time Badge */}
        <div className="mt-12 text-center">
          <div className="inline-flex items-center gap-2 px-6 py-3 rounded-full bg-[#F5F7FA] border border-[#E1E5EA]">
            <span className="text-2xl font-bold text-[#3BA2F8]">5분</span>
            <span className="text-base text-[#6B7280]">이내 완성</span>
          </div>
        </div>
      </div>
    </section>
  );
}
</file>

<file path="src/features/landing/components/pricing-section.tsx">
"use client";

import { Check } from "lucide-react";
import Link from "next/link";
import { Button } from "@/components/ui/button";

interface PricingPlan {
  name: string;
  price: string;
  period: string;
  description: string;
  features: string[];
  cta: string;
  ctaUrl: string;
  highlighted?: boolean;
}

const plans: PricingPlan[] = [
  {
    name: "무료 플랜",
    price: "₩0",
    period: "영구 무료",
    description: "서비스를 체험하고 시작하기에 완벽합니다",
    features: [
      "3편까지 블로그 글 생성",
      "모든 기능 사용 가능",
      "AI 자동 생성",
      "SEO 최적화",
      "브랜드 보이스 1개",
      "마크다운 내보내기",
    ],
    cta: "무료로 시작하기",
    ctaUrl: "/signup",
    highlighted: false,
  },
  {
    name: "프로 플랜",
    price: "$19",
    period: "월",
    description: "진지하게 콘텐츠를 만드는 분들을 위한 플랜",
    features: [
      "무제한 블로그 글 생성",
      "모든 기능 사용 가능",
      "브랜드 보이스 3개",
      "우선 지원",
      "향후 신규 기능 우선 접근",
      "고급 SEO 분석",
    ],
    cta: "프로 시작하기",
    ctaUrl: "/signup",
    highlighted: true,
  },
];

export function PricingSection() {
  return (
    <section className="w-full bg-white py-20 px-4">
      <div className="max-w-6xl mx-auto">
        {/* Section Header */}
        <div className="text-center mb-16">
          <h2 className="text-3xl md:text-4xl font-bold text-[#111827] mb-4">
            간단하고 투명한 가격
          </h2>
          <p className="text-lg text-[#6B7280] max-w-2xl mx-auto">
            무료로 시작해서 필요할 때 업그레이드하세요. 숨겨진 비용은 없습니다
          </p>
        </div>

        {/* Pricing Cards */}
        <div className="grid grid-cols-1 md:grid-cols-2 gap-8 max-w-4xl mx-auto">
          {plans.map((plan, index) => (
            <div
              key={index}
              className={`relative p-8 rounded-xl border ${
                plan.highlighted
                  ? "border-[#3BA2F8] shadow-xl scale-105"
                  : "border-[#E1E5EA]"
              } bg-white transition-all duration-300`}
            >
              {/* Highlighted Badge */}
              {plan.highlighted && (
                <div className="absolute -top-4 left-1/2 transform -translate-x-1/2">
                  <div className="px-4 py-1.5 rounded-full bg-[#3BA2F8] text-white text-sm font-medium">
                    추천
                  </div>
                </div>
              )}

              <div className="space-y-6">
                {/* Plan Name */}
                <div>
                  <h3 className="text-2xl font-bold text-[#111827]">
                    {plan.name}
                  </h3>
                  <p className="text-sm text-[#6B7280] mt-2">
                    {plan.description}
                  </p>
                </div>

                {/* Price */}
                <div className="flex items-baseline gap-2">
                  <span className="text-5xl font-bold text-[#111827]">
                    {plan.price}
                  </span>
                  <span className="text-lg text-[#6B7280]">
                    / {plan.period}
                  </span>
                </div>

                {/* CTA Button */}
                <Button
                  className={`w-full py-6 text-base font-medium rounded-lg ${
                    plan.highlighted
                      ? "bg-[#3BA2F8] hover:bg-[#3BA2F8]/90 text-white"
                      : "bg-[#F5F7FA] hover:bg-[#E1E5EA] text-[#111827] border border-[#E1E5EA]"
                  }`}
                  asChild
                >
                  <Link href={plan.ctaUrl}>{plan.cta}</Link>
                </Button>

                {/* Features List */}
                <div className="space-y-4 pt-6 border-t border-[#E1E5EA]">
                  {plan.features.map((feature, featureIndex) => (
                    <div key={featureIndex} className="flex items-start gap-3">
                      <div className="flex-shrink-0 w-5 h-5 rounded-full bg-[#3BA2F8]/10 flex items-center justify-center">
                        <Check className="w-3 h-3 text-[#3BA2F8]" />
                      </div>
                      <span className="text-base text-[#374151]">
                        {feature}
                      </span>
                    </div>
                  ))}
                </div>
              </div>
            </div>
          ))}
        </div>
      </div>
    </section>
  );
}
</file>

<file path="src/features/landing/components/use-cases-section.tsx">
"use client";

import { Rocket, BookOpen, Megaphone, TrendingUp } from "lucide-react";

interface UseCase {
  icon: React.ReactNode;
  title: string;
  description: string;
}

const useCases: UseCase[] = [
  {
    icon: <Rocket className="w-6 h-6" />,
    title: "제품 런칭 블로그",
    description: "새로운 제품이나 서비스를 알리는 런칭 블로그를 빠르게 작성하고 SEO 최적화로 더 많은 사람들에게 알립니다.",
  },
  {
    icon: <BookOpen className="w-6 h-6" />,
    title: "튜토리얼 & 가이드",
    description: "사용자를 위한 상세한 튜토리얼과 가이드 문서를 체계적으로 작성하여 고객 만족도를 높입니다.",
  },
  {
    icon: <Megaphone className="w-6 h-6" />,
    title: "회사 소식 & 업데이트",
    description: "회사의 최신 소식과 제품 업데이트를 일관된 톤으로 전달하여 브랜드 이미지를 강화합니다.",
  },
  {
    icon: <TrendingUp className="w-6 h-6" />,
    title: "SEO 콘텐츠 마케팅",
    description: "검색 엔진 상위 노출을 위한 키워드 최적화 콘텐츠를 대량으로 생성하여 트래픽을 증가시킵니다.",
  },
];

export function UseCasesSection() {
  return (
    <section className="w-full bg-[#FCFCFD] py-20 px-4">
      <div className="max-w-6xl mx-auto">
        {/* Section Header */}
        <div className="text-center mb-16">
          <h2 className="text-3xl md:text-4xl font-bold text-[#111827] mb-4">
            다양한 상황에서 활용하세요
          </h2>
          <p className="text-lg text-[#6B7280] max-w-2xl mx-auto">
            제품 런칭부터 SEO 마케팅까지, 모든 블로그 작성 시나리오를 지원합니다
          </p>
        </div>

        {/* Use Cases Grid */}
        <div className="grid grid-cols-1 md:grid-cols-2 gap-8">
          {useCases.map((useCase, index) => (
            <div
              key={index}
              className="group p-8 rounded-xl border border-[#E1E5EA] bg-white hover:bg-[#F5F7FA] transition-all duration-300"
            >
              <div className="flex items-start space-x-4">
                {/* Icon */}
                <div className="flex-shrink-0 w-12 h-12 rounded-lg bg-[#F5F7FA] flex items-center justify-center text-[#3BA2F8] group-hover:bg-[#3BA2F8] group-hover:text-white transition-all duration-300">
                  {useCase.icon}
                </div>

                {/* Content */}
                <div className="flex-1 space-y-2">
                  <h3 className="text-xl font-semibold text-[#111827]">
                    {useCase.title}
                  </h3>
                  <p className="text-base text-[#6B7280] leading-relaxed">
                    {useCase.description}
                  </p>
                </div>
              </div>
            </div>
          ))}
        </div>
      </div>
    </section>
  );
}
</file>

<file path="src/features/onboarding/actions/create-style-guide.ts">
"use server";

import { auth } from "@clerk/nextjs/server";
import { revalidatePath } from "next/cache";
import { OnboardingFormData } from "../lib/onboarding-schema";

/**
 * Create a new style guide
 * Used in /style-guides/new page
 */
export async function createStyleGuide(data: OnboardingFormData) {
  try {
    console.log("[SERVER ACTION] Starting createStyleGuide");

    // Get authenticated user
    const { userId } = await auth();

    console.log("[SERVER ACTION] userId:", userId);

    if (!userId) {
      console.log("[SERVER ACTION] No userId, throwing Unauthorized error");
      throw new Error("Unauthorized");
    }

    // Save style guide data to Supabase via Hono API
    const apiUrl = `${process.env.NEXT_PUBLIC_APP_URL}/api/style-guides`;
    console.log("[SERVER ACTION] Saving style guide to API:", apiUrl);

    const response = await fetch(apiUrl, {
      method: "POST",
      headers: {
        "Content-Type": "application/json",
        "x-clerk-user-id": userId,
      },
      body: JSON.stringify(data),
    });

    console.log("[SERVER ACTION] API response status:", response.status);

    if (!response.ok) {
      const errorData = await response.json().catch(() => ({}));
      console.error("[SERVER ACTION] Failed to save style guide:", errorData);
      throw new Error(
        errorData.error?.message || "스타일 가이드 저장에 실패했습니다"
      );
    }

    const savedData = await response.json();
    console.log("[SERVER ACTION] Style guide saved successfully:", savedData);

    // Revalidate style guide page
    console.log("[SERVER ACTION] Revalidating style guide paths");
    revalidatePath("/style-guides", "page");
    revalidatePath("/style-guide", "page");

    const result = { success: true, data: savedData.data };
    console.log("[SERVER ACTION] Returning result:", result);
    return result;
  } catch (error) {
    console.error("[SERVER ACTION] Error creating style guide:", error);
    throw new Error(
      error instanceof Error
        ? error.message
        : "스타일 가이드 생성 중 오류가 발생했습니다"
    );
  }
}
</file>

<file path="src/features/onboarding/backend/schema.ts">
import { z } from 'zod';
import { onboardingSchema } from '@/features/onboarding/lib/onboarding-schema';

// Request schema - reuses the onboarding form schema
export const CreateStyleGuideRequestSchema = onboardingSchema;

export type CreateStyleGuideRequest = z.infer<typeof CreateStyleGuideRequestSchema>;

// Database row schema (snake_case to match database columns)
export const StyleGuideTableRowSchema = z.object({
  id: z.string().uuid(),
  clerk_user_id: z.string(),
  brand_name: z.string(),
  brand_description: z.string(),
  personality: z.array(z.string()),
  formality: z.enum(['casual', 'neutral', 'formal']),
  target_audience: z.string(),
  pain_points: z.string(),
  language: z.enum(['ko', 'en']),
  tone: z.enum(['professional', 'friendly', 'inspirational', 'educational']),
  content_length: z.enum(['short', 'medium', 'long']),
  reading_level: z.enum(['beginner', 'intermediate', 'advanced']),
  notes: z.string().nullable(),
  is_default: z.boolean(),
  created_at: z.string(),
  updated_at: z.string(),
});

export type StyleGuideRow = z.infer<typeof StyleGuideTableRowSchema>;

// Response schema (camelCase for API responses)
export const StyleGuideResponseSchema = z.object({
  id: z.string().uuid(),
  clerkUserId: z.string(),
  brandName: z.string(),
  brandDescription: z.string(),
  personality: z.array(z.string()),
  formality: z.enum(['casual', 'neutral', 'formal']),
  targetAudience: z.string(),
  painPoints: z.string(),
  language: z.enum(['ko', 'en']),
  tone: z.enum(['professional', 'friendly', 'inspirational', 'educational']),
  contentLength: z.enum(['short', 'medium', 'long']),
  readingLevel: z.enum(['beginner', 'intermediate', 'advanced']),
  notes: z.string().nullable(),
  isDefault: z.boolean(),
  createdAt: z.string(),
  updatedAt: z.string(),
});

export type StyleGuideResponse = z.infer<typeof StyleGuideResponseSchema>;
</file>

<file path="src/features/onboarding/components/preview-panel.tsx">
"use client";

import { Card } from "@/components/ui/card";
import { OnboardingFormData } from "../lib/onboarding-schema";
import {
  PERSONALITY_OPTIONS,
  PREVIEW_TEMPLATES,
  TONE_OPTIONS,
  CONTENT_LENGTH_OPTIONS,
  READING_LEVEL_OPTIONS,
} from "../lib/constants";

interface PreviewPanelProps {
  formData: Partial<OnboardingFormData>;
}

export function PreviewPanel({ formData }: PreviewPanelProps) {
  const {
    brandName,
    personality,
    formality,
    targetAudience,
    language,
    tone,
    contentLength,
    readingLevel,
  } = formData;

  // Generate preview text
  const generatePreviewText = () => {
    if (!brandName || !personality || !formality || !targetAudience) {
      return language === "ko"
        ? "브랜드 정보를 입력하면 여기에 미리보기가 표시됩니다."
        : "Fill in your brand information to see a preview here.";
    }

    const template =
      PREVIEW_TEMPLATES[language || "ko"][formality || "neutral"];

    // Get personality label
    const personalityLabel = personality
      .map(
        (p) =>
          PERSONALITY_OPTIONS.find((opt) => opt.value === p)?.label || p
      )
      .join(", ");

    return template
      .replace("{brandName}", brandName)
      .replace("{personality}", personalityLabel)
      .replace("{targetAudience}", targetAudience);
  };

  const toneLabel = TONE_OPTIONS.find((t) => t.value === tone)?.label;
  const lengthLabel = CONTENT_LENGTH_OPTIONS.find(
    (l) => l.value === contentLength
  )?.label;
  const levelLabel = READING_LEVEL_OPTIONS.find(
    (r) => r.value === readingLevel
  )?.label;

  return (
    <Card
      className="sticky top-6 h-fit p-6"
      style={{
        backgroundColor: "#FFFFFF",
        borderColor: "#E1E5EA",
        borderRadius: "12px",
      }}
    >
      <div className="space-y-4">
        <div>
          <h3
            className="text-lg font-semibold"
            style={{ color: "#111827" }}
          >
            미리보기
          </h3>
          <p className="text-sm" style={{ color: "#6B7280" }}>
            설정에 따른 콘텐츠 스타일
          </p>
        </div>

        <div
          className="rounded-lg p-4"
          style={{
            backgroundColor: "#F5F7FA",
            borderLeft: "4px solid #3BA2F8",
          }}
        >
          <p
            className="leading-relaxed"
            style={{
              color: "#374151",
              fontSize: "15px",
              lineHeight: "1.7",
            }}
          >
            {generatePreviewText()}
          </p>
        </div>

        {/* Settings summary */}
        <div className="space-y-3 pt-4">
          <h4
            className="text-sm font-medium"
            style={{ color: "#374151" }}
          >
            설정 요약
          </h4>

          <div className="space-y-2">
            {brandName && (
              <div className="flex items-center justify-between text-sm">
                <span style={{ color: "#6B7280" }}>브랜드</span>
                <span
                  className="font-medium"
                  style={{ color: "#111827" }}
                >
                  {brandName}
                </span>
              </div>
            )}

            {language && (
              <div className="flex items-center justify-between text-sm">
                <span style={{ color: "#6B7280" }}>언어</span>
                <span
                  className="font-medium"
                  style={{ color: "#111827" }}
                >
                  {language === "ko" ? "한국어" : "English"}
                </span>
              </div>
            )}

            {tone && (
              <div className="flex items-center justify-between text-sm">
                <span style={{ color: "#6B7280" }}>톤</span>
                <span
                  className="font-medium"
                  style={{ color: "#111827" }}
                >
                  {toneLabel}
                </span>
              </div>
            )}

            {contentLength && (
              <div className="flex items-center justify-between text-sm">
                <span style={{ color: "#6B7280" }}>길이</span>
                <span
                  className="font-medium"
                  style={{ color: "#111827" }}
                >
                  {lengthLabel}
                </span>
              </div>
            )}

            {readingLevel && (
              <div className="flex items-center justify-between text-sm">
                <span style={{ color: "#6B7280" }}>수준</span>
                <span
                  className="font-medium"
                  style={{ color: "#111827" }}
                >
                  {levelLabel}
                </span>
              </div>
            )}
          </div>
        </div>
      </div>
    </Card>
  );
}
</file>

<file path="src/features/onboarding/components/step-audience.tsx">
"use client";

import { UseFormReturn } from "react-hook-form";
import {
  FormField,
  FormItem,
  FormLabel,
  FormControl,
  FormMessage,
  FormDescription,
} from "@/components/ui/form";
import { Textarea } from "@/components/ui/textarea";
import { OnboardingFormData } from "../lib/onboarding-schema";

interface StepAudienceProps {
  form: UseFormReturn<OnboardingFormData>;
}

export function StepAudience({ form }: StepAudienceProps) {
  return (
    <div className="space-y-6">
      <div>
        <h2
          className="text-2xl font-semibold"
          style={{ color: "#111827" }}
        >
          타겟 독자 정의
        </h2>
        <p className="mt-2 text-sm" style={{ color: "#6B7280" }}>
          어떤 독자를 위한 콘텐츠인지 알려주세요
        </p>
      </div>

      {/* Target Audience */}
      <FormField
        control={form.control}
        name="targetAudience"
        render={({ field }) => (
          <FormItem>
            <FormLabel>타겟 독자</FormLabel>
            <FormControl>
              <Textarea
                placeholder="예: 스타트업 창업자, 프리랜서 개발자, 마케팅 담당자 등&#10;&#10;독자의 특성, 관심사, 직업 등을 자세히 설명해주세요"
                {...field}
                className="min-h-[150px] resize-y"
                style={{
                  borderColor: "#E1E5EA",
                  borderRadius: "6px",
                }}
              />
            </FormControl>
            <FormDescription>
              타겟 독자의 특성을 구체적으로 설명할수록 더 맞춤화된 콘텐츠를 생성할 수 있습니다
            </FormDescription>
            <FormMessage />
          </FormItem>
        )}
      />

      {/* Pain Points */}
      <FormField
        control={form.control}
        name="painPoints"
        render={({ field }) => (
          <FormItem>
            <FormLabel>해결하려는 문제</FormLabel>
            <FormControl>
              <Textarea
                placeholder="예: 시간 부족, 콘텐츠 작성의 어려움, 일관성 유지 등&#10;&#10;독자들이 겪고 있는 문제나 니즈를 설명해주세요"
                {...field}
                className="min-h-[150px] resize-y"
                style={{
                  borderColor: "#E1E5EA",
                  borderRadius: "6px",
                }}
              />
            </FormControl>
            <FormDescription>
              독자가 해결하고 싶어하는 문제나 달성하고 싶은 목표를 설명해주세요
            </FormDescription>
            <FormMessage />
          </FormItem>
        )}
      />

      <div
        className="rounded-lg p-4"
        style={{
          backgroundColor: "#F5F7FA",
          borderLeft: "4px solid #3BA2F8",
        }}
      >
        <p className="text-sm font-medium" style={{ color: "#111827" }}>
          💡 팁
        </p>
        <p className="mt-2 text-sm" style={{ color: "#6B7280" }}>
          타겟 독자를 구체적으로 정의할수록 더 효과적인 콘텐츠를 만들 수 있습니다.
          인구통계학적 정보(나이, 직업)와 심리학적 정보(관심사, 가치관)를 모두
          고려해보세요.
        </p>
      </div>
    </div>
  );
}
</file>

<file path="src/features/onboarding/components/step-brand-voice.tsx">
"use client";

import { UseFormReturn } from "react-hook-form";
import {
  FormField,
  FormItem,
  FormLabel,
  FormControl,
  FormMessage,
  FormDescription,
} from "@/components/ui/form";
import { Input } from "@/components/ui/input";
import { Textarea } from "@/components/ui/textarea";
import { Checkbox } from "@/components/ui/checkbox";
import { Label } from "@/components/ui/label";
import { OnboardingFormData } from "../lib/onboarding-schema";
import { PERSONALITY_OPTIONS, FORMALITY_OPTIONS } from "../lib/constants";

interface StepBrandVoiceProps {
  form: UseFormReturn<OnboardingFormData>;
}

export function StepBrandVoice({ form }: StepBrandVoiceProps) {
  return (
    <div className="space-y-6">
      <div>
        <h2
          className="text-2xl font-semibold"
          style={{ color: "#111827" }}
        >
          브랜드 보이스 설정
        </h2>
        <p className="mt-2 text-sm" style={{ color: "#6B7280" }}>
          브랜드의 개성과 목소리를 정의해주세요
        </p>
      </div>

      {/* Brand Name */}
      <FormField
        control={form.control}
        name="brandName"
        render={({ field }) => (
          <FormItem>
            <FormLabel>브랜드 이름</FormLabel>
            <FormControl>
              <Input
                placeholder="예: ContentCraft AI"
                {...field}
                className="h-10"
                style={{
                  borderColor: "#E1E5EA",
                  borderRadius: "6px",
                }}
              />
            </FormControl>
            <FormMessage />
          </FormItem>
        )}
      />

      {/* Brand Description */}
      <FormField
        control={form.control}
        name="brandDescription"
        render={({ field }) => (
          <FormItem>
            <FormLabel>브랜드 설명</FormLabel>
            <FormControl>
              <Textarea
                placeholder="브랜드가 무엇을 하는지, 어떤 가치를 제공하는지 설명해주세요"
                {...field}
                className="min-h-[120px] resize-y"
                style={{
                  borderColor: "#E1E5EA",
                  borderRadius: "6px",
                }}
              />
            </FormControl>
            <FormDescription>
              최소 10자 이상 입력해주세요
            </FormDescription>
            <FormMessage />
          </FormItem>
        )}
      />

      {/* Personality */}
      <FormField
        control={form.control}
        name="personality"
        render={() => (
          <FormItem>
            <div className="mb-4">
              <FormLabel>브랜드 성격 (최대 3개)</FormLabel>
              <FormDescription>
                브랜드의 개성을 가장 잘 나타내는 단어를 선택하세요
              </FormDescription>
            </div>
            <div className="grid grid-cols-2 gap-3 sm:grid-cols-3">
              {PERSONALITY_OPTIONS.map((option) => (
                <FormField
                  key={option.value}
                  control={form.control}
                  name="personality"
                  render={({ field }) => {
                    return (
                      <FormItem
                        key={option.value}
                        className="flex flex-row items-start space-x-3 space-y-0"
                      >
                        <FormControl>
                          <Checkbox
                            checked={field.value?.includes(option.value)}
                            onCheckedChange={(checked) => {
                              const currentValue = field.value || [];
                              const newValue = checked
                                ? [...currentValue, option.value]
                                : currentValue.filter(
                                    (value) => value !== option.value
                                  );
                              // Limit to 3 selections
                              if (newValue.length <= 3) {
                                field.onChange(newValue);
                              }
                            }}
                          />
                        </FormControl>
                        <Label
                          className="cursor-pointer font-normal"
                          style={{ color: "#374151" }}
                        >
                          {option.label}
                        </Label>
                      </FormItem>
                    );
                  }}
                />
              ))}
            </div>
            <FormMessage />
          </FormItem>
        )}
      />

      {/* Formality */}
      <FormField
        control={form.control}
        name="formality"
        render={({ field }) => (
          <FormItem>
            <FormLabel>격식 수준</FormLabel>
            <FormDescription>
              브랜드 커뮤니케이션의 격식 수준을 선택하세요
            </FormDescription>
            <div className="space-y-3">
              {FORMALITY_OPTIONS.map((option) => (
                <div
                  key={option.value}
                  className="flex items-start space-x-3"
                >
                  <FormControl>
                    <input
                      type="radio"
                      value={option.value}
                      checked={field.value === option.value}
                      onChange={() => field.onChange(option.value)}
                      className="mt-1 h-4 w-4 cursor-pointer"
                      style={{
                        accentColor: "#3BA2F8",
                      }}
                    />
                  </FormControl>
                  <div className="flex-1">
                    <Label
                      className="cursor-pointer font-medium"
                      style={{ color: "#111827" }}
                    >
                      {option.label}
                    </Label>
                    <p className="text-sm" style={{ color: "#6B7280" }}>
                      {option.description}
                    </p>
                  </div>
                </div>
              ))}
            </div>
            <FormMessage />
          </FormItem>
        )}
      />
    </div>
  );
}
</file>

<file path="src/features/onboarding/components/step-indicator.tsx">
"use client";

import { Progress } from "@/components/ui/progress";
import { STEP_NAMES, TOTAL_STEPS } from "../lib/constants";

interface StepIndicatorProps {
  currentStep: number;
}

export function StepIndicator({ currentStep }: StepIndicatorProps) {
  const progressPercentage = (currentStep / TOTAL_STEPS) * 100;

  return (
    <div className="w-full space-y-4">
      {/* Progress bar */}
      <div className="space-y-2">
        <div className="flex items-center justify-between text-sm">
          <span className="font-medium" style={{ color: "#374151" }}>
            {STEP_NAMES[currentStep - 1]}
          </span>
          <span className="text-sm" style={{ color: "#6B7280" }}>
            {currentStep} / {TOTAL_STEPS}
          </span>
        </div>
        <Progress
          value={progressPercentage}
          className="h-2"
          style={{
            backgroundColor: "#E1E5EA",
          }}
          aria-label={`진행률: ${Math.round(progressPercentage)}%`}
        />
      </div>

      {/* Step dots */}
      <div className="flex items-center justify-between">
        {Array.from({ length: TOTAL_STEPS }, (_, index) => {
          const stepNumber = index + 1;
          const isCompleted = stepNumber < currentStep;
          const isCurrent = stepNumber === currentStep;

          return (
            <div
              key={stepNumber}
              className="flex flex-col items-center gap-2"
            >
              <div
                className="flex h-8 w-8 items-center justify-center rounded-full text-xs font-medium transition-colors"
                style={{
                  backgroundColor: isCompleted || isCurrent ? "#3BA2F8" : "#E1E5EA",
                  color: isCompleted || isCurrent ? "#FFFFFF" : "#6B7280",
                }}
                aria-current={isCurrent ? "step" : undefined}
                aria-label={`Step ${stepNumber}: ${STEP_NAMES[index]}`}
              >
                {stepNumber}
              </div>
              <span
                className="hidden text-xs sm:block"
                style={{
                  color: isCurrent ? "#111827" : "#6B7280",
                  fontWeight: isCurrent ? 500 : 400,
                }}
              >
                {STEP_NAMES[index]}
              </span>
            </div>
          );
        })}
      </div>
    </div>
  );
}
</file>

<file path="src/features/onboarding/components/step-language.tsx">
"use client";

import { UseFormReturn } from "react-hook-form";
import {
  FormField,
  FormItem,
  FormLabel,
  FormControl,
  FormMessage,
  FormDescription,
} from "@/components/ui/form";
import { Label } from "@/components/ui/label";
import { OnboardingFormData } from "../lib/onboarding-schema";
import { LANGUAGE_OPTIONS } from "../lib/constants";

interface StepLanguageProps {
  form: UseFormReturn<OnboardingFormData>;
}

export function StepLanguage({ form }: StepLanguageProps) {
  return (
    <div className="space-y-6">
      <div>
        <h2
          className="text-2xl font-semibold"
          style={{ color: "#111827" }}
        >
          언어 설정
        </h2>
        <p className="mt-2 text-sm" style={{ color: "#6B7280" }}>
          주로 사용할 언어를 선택해주세요
        </p>
      </div>

      {/* Language Selection */}
      <FormField
        control={form.control}
        name="language"
        render={({ field }) => (
          <FormItem>
            <FormLabel>콘텐츠 언어</FormLabel>
            <FormDescription>
              생성될 콘텐츠의 기본 언어를 선택하세요
            </FormDescription>
            <div className="grid gap-4 sm:grid-cols-2">
              {LANGUAGE_OPTIONS.map((option) => (
                <div
                  key={option.value}
                  onClick={() => field.onChange(option.value)}
                  className="group relative cursor-pointer rounded-lg border-2 p-6 transition-all hover:shadow-md"
                  style={{
                    borderColor:
                      field.value === option.value ? "#3BA2F8" : "#E1E5EA",
                    backgroundColor:
                      field.value === option.value ? "#F0F9FF" : "#FFFFFF",
                  }}
                  role="radio"
                  aria-checked={field.value === option.value}
                  tabIndex={0}
                  onKeyDown={(e) => {
                    if (e.key === "Enter" || e.key === " ") {
                      e.preventDefault();
                      field.onChange(option.value);
                    }
                  }}
                >
                  <FormControl>
                    <input
                      type="radio"
                      value={option.value}
                      checked={field.value === option.value}
                      onChange={() => field.onChange(option.value)}
                      className="absolute left-4 top-4 h-4 w-4 cursor-pointer"
                      style={{
                        accentColor: "#3BA2F8",
                      }}
                    />
                  </FormControl>
                  <div className="ml-6">
                    <Label
                      className="cursor-pointer text-lg font-semibold"
                      style={{
                        color:
                          field.value === option.value ? "#1E2A38" : "#111827",
                      }}
                    >
                      {option.label}
                    </Label>
                    <p
                      className="mt-1 text-sm"
                      style={{ color: "#6B7280" }}
                    >
                      {option.description}
                    </p>
                  </div>
                </div>
              ))}
            </div>
            <FormMessage />
          </FormItem>
        )}
      />

      <div
        className="rounded-lg p-4"
        style={{
          backgroundColor: "#F5F7FA",
          borderLeft: "4px solid #3BA2F8",
        }}
      >
        <p className="text-sm font-medium" style={{ color: "#111827" }}>
          💡 팁
        </p>
        <p className="mt-2 text-sm" style={{ color: "#6B7280" }}>
          기본 언어를 설정한 후에도 콘텐츠 생성 시 다른 언어를 선택할 수
          있습니다. 이 설정은 기본값으로만 사용됩니다.
        </p>
      </div>
    </div>
  );
}
</file>

<file path="src/features/onboarding/components/step-style.tsx">
"use client";

import { UseFormReturn } from "react-hook-form";
import {
  FormField,
  FormItem,
  FormLabel,
  FormControl,
  FormMessage,
  FormDescription,
} from "@/components/ui/form";
import {
  Select,
  SelectContent,
  SelectItem,
  SelectTrigger,
  SelectValue,
} from "@/components/ui/select";
import { OnboardingFormData } from "../lib/onboarding-schema";
import {
  TONE_OPTIONS,
  CONTENT_LENGTH_OPTIONS,
  READING_LEVEL_OPTIONS,
} from "../lib/constants";

interface StepStyleProps {
  form: UseFormReturn<OnboardingFormData>;
}

export function StepStyle({ form }: StepStyleProps) {
  return (
    <div className="space-y-6">
      <div>
        <h2
          className="text-2xl font-semibold"
          style={{ color: "#111827" }}
        >
          스타일 설정
        </h2>
        <p className="mt-2 text-sm" style={{ color: "#6B7280" }}>
          콘텐츠의 톤과 길이를 설정해주세요
        </p>
      </div>

      {/* Tone */}
      <FormField
        control={form.control}
        name="tone"
        render={({ field }) => (
          <FormItem>
            <FormLabel>콘텐츠 톤</FormLabel>
            <Select onValueChange={field.onChange} defaultValue={field.value}>
              <FormControl>
                <SelectTrigger
                  className="h-10"
                  style={{
                    borderColor: "#E1E5EA",
                    borderRadius: "6px",
                  }}
                >
                  <SelectValue placeholder="톤을 선택하세요" />
                </SelectTrigger>
              </FormControl>
              <SelectContent>
                {TONE_OPTIONS.map((option) => (
                  <SelectItem key={option.value} value={option.value}>
                    <div className="flex flex-col">
                      <span className="font-medium">{option.label}</span>
                      <span
                        className="text-xs"
                        style={{ color: "#6B7280" }}
                      >
                        {option.description}
                      </span>
                    </div>
                  </SelectItem>
                ))}
              </SelectContent>
            </Select>
            <FormDescription>
              콘텐츠의 전반적인 분위기와 어조를 결정합니다
            </FormDescription>
            <FormMessage />
          </FormItem>
        )}
      />

      {/* Content Length */}
      <FormField
        control={form.control}
        name="contentLength"
        render={({ field }) => (
          <FormItem>
            <FormLabel>콘텐츠 길이</FormLabel>
            <Select onValueChange={field.onChange} defaultValue={field.value}>
              <FormControl>
                <SelectTrigger
                  className="h-10"
                  style={{
                    borderColor: "#E1E5EA",
                    borderRadius: "6px",
                  }}
                >
                  <SelectValue placeholder="길이를 선택하세요" />
                </SelectTrigger>
              </FormControl>
              <SelectContent>
                {CONTENT_LENGTH_OPTIONS.map((option) => (
                  <SelectItem key={option.value} value={option.value}>
                    <div className="flex flex-col">
                      <span className="font-medium">{option.label}</span>
                      <span
                        className="text-xs"
                        style={{ color: "#6B7280" }}
                      >
                        {option.description}
                      </span>
                    </div>
                  </SelectItem>
                ))}
              </SelectContent>
            </Select>
            <FormDescription>
              생성될 콘텐츠의 평균 길이를 설정합니다
            </FormDescription>
            <FormMessage />
          </FormItem>
        )}
      />

      {/* Reading Level */}
      <FormField
        control={form.control}
        name="readingLevel"
        render={({ field }) => (
          <FormItem>
            <FormLabel>읽기 수준</FormLabel>
            <Select onValueChange={field.onChange} defaultValue={field.value}>
              <FormControl>
                <SelectTrigger
                  className="h-10"
                  style={{
                    borderColor: "#E1E5EA",
                    borderRadius: "6px",
                  }}
                >
                  <SelectValue placeholder="수준을 선택하세요" />
                </SelectTrigger>
              </FormControl>
              <SelectContent>
                {READING_LEVEL_OPTIONS.map((option) => (
                  <SelectItem key={option.value} value={option.value}>
                    <div className="flex flex-col">
                      <span className="font-medium">{option.label}</span>
                      <span
                        className="text-xs"
                        style={{ color: "#6B7280" }}
                      >
                        {option.description}
                      </span>
                    </div>
                  </SelectItem>
                ))}
              </SelectContent>
            </Select>
            <FormDescription>
              독자의 전문성 수준에 맞는 용어와 표현을 사용합니다
            </FormDescription>
            <FormMessage />
          </FormItem>
        )}
      />

      <div
        className="rounded-lg p-4"
        style={{
          backgroundColor: "#F5F7FA",
          borderLeft: "4px solid #3BA2F8",
        }}
      >
        <p className="text-sm font-medium" style={{ color: "#111827" }}>
          💡 팁
        </p>
        <p className="mt-2 text-sm" style={{ color: "#6B7280" }}>
          이 설정은 기본값으로 사용되며, 각 콘텐츠 생성 시 개별적으로 조정할 수
          있습니다.
        </p>
      </div>
    </div>
  );
}
</file>

<file path="src/features/onboarding/components/style-guide-card.tsx">
"use client";

import { Card } from "@/components/ui/card";
import { Button } from "@/components/ui/button";
import { Edit2, Trash2, Eye } from "lucide-react";
import type { StyleGuideResponse } from "@/features/onboarding/backend/schema";

interface StyleGuideCardProps {
  guide: StyleGuideResponse;
  onEdit: (guide: StyleGuideResponse) => void;
  onDelete: (id: string) => void;
  onPreview: (guide: StyleGuideResponse) => void;
}

export function StyleGuideCard({
  guide,
  onEdit,
  onDelete,
  onPreview,
}: StyleGuideCardProps) {
  const getBadgeColor = (tone: string) => {
    const colors: Record<string, string> = {
      professional: "#3BA2F8",
      friendly: "#10B981",
      inspirational: "#F59E0B",
      educational: "#8B5CF6",
    };
    return colors[tone] || "#6B7280";
  };

  const getContentLengthLabel = (length: string) => {
    const labels: Record<string, string> = {
      short: "짧음",
      medium: "중간",
      long: "긴",
    };
    return labels[length] || length;
  };

  const getReadingLevelLabel = (level: string) => {
    const labels: Record<string, string> = {
      beginner: "초보자",
      intermediate: "중급",
      advanced: "고급",
    };
    return labels[level] || level;
  };

  return (
    <Card
      className="p-6"
      style={{
        borderColor: "#E1E5EA",
        borderRadius: "12px",
      }}
    >
      <div className="space-y-4">
        {/* Header */}
        <div className="flex items-start justify-between">
          <div className="flex-1">
            <h3 className="text-lg font-semibold" style={{ color: "#1F2937" }}>
              {guide.brandName}
            </h3>
            <p className="mt-1 text-sm" style={{ color: "#6B7280" }}>
              {guide.brandDescription}
            </p>
          </div>
        </div>

        {/* Badges */}
        <div className="flex flex-wrap gap-2">
          {/* Tone Badge */}
          <div
            className="px-3 py-1 rounded-full text-xs font-medium text-white"
            style={{ backgroundColor: getBadgeColor(guide.tone) }}
          >
            {guide.tone}
          </div>

          {/* Language Badge */}
          <div
            className="px-3 py-1 rounded-full text-xs font-medium text-white"
            style={{ backgroundColor: "#6366F1" }}
          >
            {guide.language === "ko" ? "한국어" : "English"}
          </div>

          {/* Content Length Badge */}
          <div
            className="px-3 py-1 rounded-full text-xs font-medium text-white"
            style={{ backgroundColor: "#EC4899" }}
          >
            {getContentLengthLabel(guide.contentLength)}
          </div>

          {/* Reading Level Badge */}
          <div
            className="px-3 py-1 rounded-full text-xs font-medium text-white"
            style={{ backgroundColor: "#14B8A6" }}
          >
            {getReadingLevelLabel(guide.readingLevel)}
          </div>
        </div>

        {/* Metadata */}
        <div className="space-y-2 text-sm" style={{ color: "#6B7280" }}>
          <p>
            <span className="font-semibold">대상 독자:</span> {guide.targetAudience}
          </p>
          {guide.personality && guide.personality.length > 0 && (
            <p>
              <span className="font-semibold">성격:</span> {guide.personality.join(", ")}
            </p>
          )}
        </div>

        {/* Action Buttons */}
        <div className="flex gap-2 pt-4 border-t">
          <Button
            variant="outline"
            size="sm"
            onClick={() => onPreview(guide)}
            className="flex-1"
          >
            <Eye className="mr-2 h-4 w-4" />
            미리보기
          </Button>
          <Button
            variant="outline"
            size="sm"
            onClick={() => onEdit(guide)}
            className="flex-1"
          >
            <Edit2 className="mr-2 h-4 w-4" />
            편집
          </Button>
          <Button
            variant="outline"
            size="sm"
            onClick={() => onDelete(guide.id)}
            className="flex-1 text-red-600"
          >
            <Trash2 className="mr-2 h-4 w-4" />
            삭제
          </Button>
        </div>
      </div>
    </Card>
  );
}
</file>

<file path="src/features/onboarding/components/style-guide-preview-modal.tsx">
"use client";

import {
  Dialog,
  DialogContent,
  DialogDescription,
  DialogHeader,
  DialogTitle,
  DialogFooter,
} from "@/components/ui/dialog";
import { Button } from "@/components/ui/button";
import { X } from "lucide-react";
import type { StyleGuideResponse } from "@/features/onboarding/backend/schema";

interface StyleGuidePreviewModalProps {
  guide: StyleGuideResponse | null;
  isOpen: boolean;
  onClose: () => void;
}

export function StyleGuidePreviewModal({
  guide,
  isOpen,
  onClose,
}: StyleGuidePreviewModalProps) {
  if (!guide) return null;

  const getFormattedDate = (dateString: string) => {
    return new Date(dateString).toLocaleDateString("ko-KR", {
      year: "numeric",
      month: "long",
      day: "numeric",
    });
  };

  const getToneLabel = (tone: string) => {
    const labels: Record<string, string> = {
      professional: "전문적이고 신뢰감 있는",
      friendly: "친근하고 대화하는 듯한",
      inspirational: "영감을 주고 동기부여하는",
      educational: "교육적이고 정보 전달에 충실한",
    };
    return labels[tone] || tone;
  };

  const getContentLengthLabel = (length: string) => {
    const labels: Record<string, string> = {
      short: "짧음 (1000-1500자)",
      medium: "중간 (2000-3000자)",
      long: "긴 (4000-6000자)",
    };
    return labels[length] || length;
  };

  const getReadingLevelLabel = (level: string) => {
    const labels: Record<string, string> = {
      beginner: "초보자도 쉽게 이해할 수 있는",
      intermediate: "중급 수준의",
      advanced: "전문적이고 심화된",
    };
    return labels[level] || level;
  };

  const getFormalityLabel = (formality: string) => {
    const labels: Record<string, string> = {
      casual: "캐주얼",
      neutral: "중립적",
      formal: "격식있는",
    };
    return labels[formality] || formality;
  };

  return (
    <Dialog open={isOpen} onOpenChange={onClose}>
      <DialogContent
        className="max-w-2xl max-h-[90vh] overflow-y-auto"
        style={{
          backgroundColor: "#FFFFFF",
          borderColor: "#E1E5EA",
        }}
      >
        <DialogHeader>
          <DialogTitle style={{ color: "#1F2937" }}>
            {guide.brandName} - 상세보기
          </DialogTitle>
          <DialogDescription>
            생성일: {getFormattedDate(guide.createdAt)} | 수정일:{" "}
            {getFormattedDate(guide.updatedAt)}
          </DialogDescription>
        </DialogHeader>

        <div className="space-y-6 py-4">
          {/* 브랜드 정보 */}
          <div className="space-y-3">
            <h3 className="font-semibold text-lg" style={{ color: "#1F2937" }}>
              브랜드 정보
            </h3>
            <div className="space-y-2 text-sm" style={{ color: "#6B7280" }}>
              <p>
                <span className="font-semibold">브랜드 이름:</span>{" "}
                {guide.brandName}
              </p>
              <p>
                <span className="font-semibold">설명:</span>{" "}
                {guide.brandDescription}
              </p>
              {guide.personality && guide.personality.length > 0 && (
                <p>
                  <span className="font-semibold">성격 특성:</span>{" "}
                  {guide.personality.join(", ")}
                </p>
              )}
              <p>
                <span className="font-semibold">격식 수준:</span>{" "}
                {getFormalityLabel(guide.formality)}
              </p>
            </div>
          </div>

          {/* 타겟 독자 정보 */}
          <div className="space-y-3 border-t pt-4">
            <h3 className="font-semibold text-lg" style={{ color: "#1F2937" }}>
              타겟 독자
            </h3>
            <div className="space-y-2 text-sm" style={{ color: "#6B7280" }}>
              <p>
                <span className="font-semibold">대상 독자:</span>{" "}
                {guide.targetAudience}
              </p>
              <p>
                <span className="font-semibold">해결하려는 문제:</span>{" "}
                {guide.painPoints}
              </p>
            </div>
          </div>

          {/* 콘텐츠 스타일 정보 */}
          <div className="space-y-3 border-t pt-4">
            <h3 className="font-semibold text-lg" style={{ color: "#1F2937" }}>
              콘텐츠 스타일
            </h3>
            <div className="space-y-2 text-sm" style={{ color: "#6B7280" }}>
              <p>
                <span className="font-semibold">언어:</span>{" "}
                {guide.language === "ko" ? "한국어" : "English"}
              </p>
              <p>
                <span className="font-semibold">톤:</span>{" "}
                {getToneLabel(guide.tone)}
              </p>
              <p>
                <span className="font-semibold">글 길이:</span>{" "}
                {getContentLengthLabel(guide.contentLength)}
              </p>
              <p>
                <span className="font-semibold">읽기 수준:</span>{" "}
                {getReadingLevelLabel(guide.readingLevel)}
              </p>
            </div>
          </div>

          {/* 추가 메모 */}
          {guide.notes && (
            <div className="space-y-3 border-t pt-4">
              <h3 className="font-semibold text-lg" style={{ color: "#1F2937" }}>
                추가 메모
              </h3>
              <p
                className="text-sm p-3 rounded"
                style={{
                  backgroundColor: "#F9FAFB",
                  color: "#6B7280",
                }}
              >
                {guide.notes}
              </p>
            </div>
          )}
        </div>

        <DialogFooter>
          <Button
            variant="outline"
            onClick={onClose}
            className="w-full sm:w-auto"
          >
            <X className="mr-2 h-4 w-4" />
            닫기
          </Button>
        </DialogFooter>
      </DialogContent>
    </Dialog>
  );
}
</file>

<file path="src/features/onboarding/lib/constants.ts">
// Step configuration
export const TOTAL_STEPS = 5;

export const STEP_NAMES = [
  "브랜드 보이스",
  "타겟 독자",
  "언어 설정",
  "스타일 설정",
  "최종 검토",
] as const;

export const STEP_DESCRIPTIONS = [
  "브랜드의 개성과 목소리를 정의해주세요",
  "어떤 독자를 위한 콘텐츠인지 알려주세요",
  "주로 사용할 언어를 선택해주세요",
  "콘텐츠의 톤과 길이를 설정해주세요",
  "설정을 검토하고 완료해주세요",
] as const;

// Step 1: Brand Voice Options
export const PERSONALITY_OPTIONS = [
  { value: "innovative", label: "혁신적인" },
  { value: "trustworthy", label: "신뢰할 수 있는" },
  { value: "playful", label: "재미있는" },
  { value: "professional", label: "전문적인" },
  { value: "approachable", label: "친근한" },
  { value: "bold", label: "대담한" },
  { value: "authentic", label: "진정성 있는" },
  { value: "sophisticated", label: "세련된" },
] as const;

export const FORMALITY_OPTIONS = [
  { value: "casual", label: "캐주얼", description: "편안하고 일상적인 대화체" },
  {
    value: "neutral",
    label: "중립",
    description: "격식과 편안함의 균형",
  },
  {
    value: "formal",
    label: "격식 있는",
    description: "전문적이고 공식적인 어조",
  },
] as const;

// Step 3: Language Options
export const LANGUAGE_OPTIONS = [
  { value: "ko", label: "한국어", description: "Korean" },
  { value: "en", label: "영어", description: "English" },
] as const;

// Step 4: Style Options
export const TONE_OPTIONS = [
  {
    value: "professional",
    label: "전문적",
    description: "비즈니스와 전문성 강조",
  },
  {
    value: "friendly",
    label: "친근한",
    description: "따뜻하고 접근하기 쉬운",
  },
  {
    value: "inspirational",
    label: "영감을 주는",
    description: "동기부여와 긍정적 메시지",
  },
  {
    value: "educational",
    label: "교육적",
    description: "학습과 지식 전달 중심",
  },
] as const;

export const CONTENT_LENGTH_OPTIONS = [
  {
    value: "short",
    label: "짧게",
    description: "300-500자 (빠른 읽기)",
  },
  {
    value: "medium",
    label: "보통",
    description: "500-1000자 (균형잡힌 길이)",
  },
  {
    value: "long",
    label: "길게",
    description: "1000자 이상 (심층 분석)",
  },
] as const;

export const READING_LEVEL_OPTIONS = [
  {
    value: "beginner",
    label: "초급",
    description: "쉬운 단어와 간단한 문장",
  },
  {
    value: "intermediate",
    label: "중급",
    description: "일반적인 수준의 어휘",
  },
  {
    value: "advanced",
    label: "고급",
    description: "전문 용어와 복잡한 개념",
  },
] as const;

// Preview templates
export const PREVIEW_TEMPLATES = {
  ko: {
    casual:
      "{brandName}는 {personality}한 브랜드예요. 우리는 {targetAudience}를 위해 콘텐츠를 만들어요.",
    neutral:
      "{brandName}는 {personality} 브랜드입니다. {targetAudience}를 위한 콘텐츠를 제공합니다.",
    formal:
      "{brandName}는 {personality} 브랜드로서, {targetAudience}를 대상으로 전문 콘텐츠를 제공하고 있습니다.",
  },
  en: {
    casual:
      "{brandName} is a {personality} brand. We create content for {targetAudience}.",
    neutral:
      "{brandName} is a {personality} brand. We provide content for {targetAudience}.",
    formal:
      "{brandName} is a {personality} brand that provides professional content for {targetAudience}.",
  },
} as const;
</file>

<file path="src/features/onboarding/lib/onboarding-schema.ts">
import { z } from "zod";

// Step 1: Brand Voice Schema
export const brandVoiceSchema = z.object({
  brandName: z
    .string()
    .min(1, "브랜드 이름을 입력해주세요")
    .max(50, "브랜드 이름은 50자 이내로 입력해주세요"),
  brandDescription: z
    .string()
    .min(10, "브랜드 설명은 최소 10자 이상 입력해주세요")
    .max(500, "브랜드 설명은 500자 이내로 입력해주세요"),
  personality: z
    .array(z.string())
    .min(1, "최소 1개의 성격을 선택해주세요")
    .max(3, "최대 3개까지 선택 가능합니다"),
  formality: z.enum(["casual", "neutral", "formal"], {
    errorMap: () => ({ message: "격식 수준을 선택해주세요" }),
  }),
});

// Step 2: Target Audience Schema
export const targetAudienceSchema = z.object({
  targetAudience: z
    .string()
    .min(10, "타겟 독자에 대한 설명을 최소 10자 이상 입력해주세요")
    .max(300, "타겟 독자 설명은 300자 이내로 입력해주세요"),
  painPoints: z
    .string()
    .min(10, "해결하려는 문제를 최소 10자 이상 입력해주세요")
    .max(300, "문제 설명은 300자 이내로 입력해주세요"),
});

// Step 3: Language Schema
export const languageSchema = z.object({
  language: z.enum(["ko", "en"], {
    errorMap: () => ({ message: "언어를 선택해주세요" }),
  }),
});

// Step 4: Style Schema
export const styleSchema = z.object({
  tone: z.enum(["professional", "friendly", "inspirational", "educational"], {
    errorMap: () => ({ message: "톤을 선택해주세요" }),
  }),
  contentLength: z.enum(["short", "medium", "long"], {
    errorMap: () => ({ message: "콘텐츠 길이를 선택해주세요" }),
  }),
  readingLevel: z.enum(["beginner", "intermediate", "advanced"], {
    errorMap: () => ({ message: "읽기 수준을 선택해주세요" }),
  }),
});

// Step 5: Review Schema
export const reviewSchema = z.object({
  notes: z.string().max(500, "메모는 500자 이내로 입력해주세요").optional(),
});

// Full Onboarding Schema (all steps combined)
export const onboardingSchema = z.object({
  ...brandVoiceSchema.shape,
  ...targetAudienceSchema.shape,
  ...languageSchema.shape,
  ...styleSchema.shape,
  ...reviewSchema.shape,
});

// Export Types
export type BrandVoiceFormData = z.infer<typeof brandVoiceSchema>;
export type TargetAudienceFormData = z.infer<typeof targetAudienceSchema>;
export type LanguageFormData = z.infer<typeof languageSchema>;
export type StyleFormData = z.infer<typeof styleSchema>;
export type ReviewFormData = z.infer<typeof reviewSchema>;
export type OnboardingFormData = z.infer<typeof onboardingSchema>;

// Default values for the form
export const defaultOnboardingValues: OnboardingFormData = {
  brandName: "",
  brandDescription: "",
  personality: [],
  formality: "neutral",
  targetAudience: "",
  painPoints: "",
  language: "ko",
  tone: "professional",
  contentLength: "medium",
  readingLevel: "intermediate",
  notes: "",
};
</file>

<file path="src/hooks/use-toast.ts">
"use client"

// Inspired by react-hot-toast library
import * as React from "react"

import type {
  ToastActionElement,
  ToastProps,
} from "@/components/ui/toast"

const TOAST_LIMIT = 1
const TOAST_REMOVE_DELAY = 1000000

type ToasterToast = ToastProps & {
  id: string
  title?: React.ReactNode
  description?: React.ReactNode
  action?: ToastActionElement
}

const actionTypes = {
  ADD_TOAST: "ADD_TOAST",
  UPDATE_TOAST: "UPDATE_TOAST",
  DISMISS_TOAST: "DISMISS_TOAST",
  REMOVE_TOAST: "REMOVE_TOAST",
} as const

let count = 0

function genId() {
  count = (count + 1) % Number.MAX_SAFE_INTEGER
  return count.toString()
}

type ActionType = typeof actionTypes

type Action =
  | {
      type: ActionType["ADD_TOAST"]
      toast: ToasterToast
    }
  | {
      type: ActionType["UPDATE_TOAST"]
      toast: Partial<ToasterToast>
    }
  | {
      type: ActionType["DISMISS_TOAST"]
      toastId?: ToasterToast["id"]
    }
  | {
      type: ActionType["REMOVE_TOAST"]
      toastId?: ToasterToast["id"]
    }

interface State {
  toasts: ToasterToast[]
}

const toastTimeouts = new Map<string, ReturnType<typeof setTimeout>>()

const addToRemoveQueue = (toastId: string) => {
  if (toastTimeouts.has(toastId)) {
    return
  }

  const timeout = setTimeout(() => {
    toastTimeouts.delete(toastId)
    dispatch({
      type: "REMOVE_TOAST",
      toastId: toastId,
    })
  }, TOAST_REMOVE_DELAY)

  toastTimeouts.set(toastId, timeout)
}

export const reducer = (state: State, action: Action): State => {
  switch (action.type) {
    case "ADD_TOAST":
      return {
        ...state,
        toasts: [action.toast, ...state.toasts].slice(0, TOAST_LIMIT),
      }

    case "UPDATE_TOAST":
      return {
        ...state,
        toasts: state.toasts.map((t) =>
          t.id === action.toast.id ? { ...t, ...action.toast } : t
        ),
      }

    case "DISMISS_TOAST": {
      const { toastId } = action

      // ! Side effects ! - This could be extracted into a dismissToast() action,
      // but I'll keep it here for simplicity
      if (toastId) {
        addToRemoveQueue(toastId)
      } else {
        state.toasts.forEach((toast) => {
          addToRemoveQueue(toast.id)
        })
      }

      return {
        ...state,
        toasts: state.toasts.map((t) =>
          t.id === toastId || toastId === undefined
            ? {
                ...t,
                open: false,
              }
            : t
        ),
      }
    }
    case "REMOVE_TOAST":
      if (action.toastId === undefined) {
        return {
          ...state,
          toasts: [],
        }
      }
      return {
        ...state,
        toasts: state.toasts.filter((t) => t.id !== action.toastId),
      }
  }
}

const listeners: Array<(state: State) => void> = []

let memoryState: State = { toasts: [] }

function dispatch(action: Action) {
  memoryState = reducer(memoryState, action)
  listeners.forEach((listener) => {
    listener(memoryState)
  })
}

type Toast = Omit<ToasterToast, "id">

function toast({ ...props }: Toast) {
  const id = genId()

  const update = (props: ToasterToast) =>
    dispatch({
      type: "UPDATE_TOAST",
      toast: { ...props, id },
    })
  const dismiss = () => dispatch({ type: "DISMISS_TOAST", toastId: id })

  dispatch({
    type: "ADD_TOAST",
    toast: {
      ...props,
      id,
      open: true,
      onOpenChange: (open) => {
        if (!open) dismiss()
      },
    },
  })

  return {
    id: id,
    dismiss,
    update,
  }
}

function useToast() {
  const [state, setState] = React.useState<State>(memoryState)

  React.useEffect(() => {
    listeners.push(setState)
    return () => {
      const index = listeners.indexOf(setState)
      if (index > -1) {
        listeners.splice(index, 1)
      }
    }
  }, [state])

  return {
    ...state,
    toast,
    dismiss: (toastId?: string) => dispatch({ type: "DISMISS_TOAST", toastId }),
  }
}

export { useToast, toast }
</file>

<file path="src/lib/remote/api-client.ts">
import axios, { isAxiosError } from "axios";

const apiClient = axios.create({
  baseURL: process.env.NEXT_PUBLIC_API_BASE_URL ?? "",
  headers: {
    "Content-Type": "application/json",
  },
});

type ErrorPayload = {
  error?: {
    message?: string;
  };
  message?: string;
};

export const extractApiErrorMessage = (
  error: unknown,
  fallbackMessage = "API request failed."
) => {
  if (isAxiosError(error)) {
    const payload = error.response?.data as ErrorPayload | undefined;

    if (typeof payload?.error?.message === "string") {
      return payload.error.message;
    }

    if (typeof payload?.message === "string") {
      return payload.message;
    }
  }

  if (error instanceof Error && error.message) {
    return error.message;
  }

  return fallbackMessage;
};

export { apiClient, isAxiosError };
</file>

<file path="src/lib/supabase/browser-client.ts">
"use client";

import { createBrowserClient } from "@supabase/ssr";
import type { SupabaseClient } from "@supabase/supabase-js";
import { env } from "@/constants/env";
import type { Database } from "./types";

let client: SupabaseClient<Database> | null = null;

export const getSupabaseBrowserClient = () => {
  if (!client) {
    client = createBrowserClient<Database>(
      env.NEXT_PUBLIC_SUPABASE_URL,
      env.NEXT_PUBLIC_SUPABASE_ANON_KEY
    );
  }

  return client;
};
</file>

<file path="src/lib/supabase/client.ts">
import { createBrowserClient } from "@supabase/ssr";

export function createClient() {
  return createBrowserClient(
    process.env.NEXT_PUBLIC_SUPABASE_URL!,
    process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY!
  );
}
</file>

<file path="src/lib/supabase/server-client.ts">
import { cookies } from "next/headers";
import { createServerClient } from "@supabase/ssr";
import type { SupabaseClient } from "@supabase/supabase-js";
import { env } from "@/constants/env";
import type { Database } from "./types";

type WritableCookieStore = Awaited<ReturnType<typeof cookies>> & {
  set?: (options: {
    name: string;
    value: string;
    path?: string;
    expires?: Date;
    maxAge?: number;
    httpOnly?: boolean;
    sameSite?: "lax" | "strict" | "none";
    secure?: boolean;
  }) => void;
};

export const createSupabaseServerClient = async (): Promise<
  SupabaseClient<Database>
> => {
  const cookieStore = (await cookies()) as WritableCookieStore;

  return createServerClient<Database>(
    env.NEXT_PUBLIC_SUPABASE_URL,
    env.NEXT_PUBLIC_SUPABASE_ANON_KEY,
    {
      cookies: {
        getAll() {
          return cookieStore.getAll();
        },
        setAll(cookiesToSet) {
          cookiesToSet.forEach(({ name, value, options }) => {
            if (typeof cookieStore.set === "function") {
              cookieStore.set({ name, value, ...options });
            }
          });
        },
      },
    }
  );
};
</file>

<file path="src/lib/supabase/server.ts">
import "server-only";

import { createServerClient } from "@supabase/ssr";
import { cookies } from "next/headers";

export async function createClient() {
  const cookieStore = await cookies();

  return createServerClient(
    process.env.NEXT_PUBLIC_SUPABASE_URL!,
    process.env.SUPABASE_SERVICE_ROLE_KEY!,
    {
      cookies: {
        getAll() {
          return cookieStore.getAll();
        },
        setAll(cookiesToSet) {
          try {
            cookiesToSet.forEach(({ name, value, options }) =>
              cookieStore.set(name, value, options)
            );
          } catch {
            // The `setAll` method was called from a Server Component.
            // This can be ignored if you have middleware refreshing
            // user sessions.
          }
        },
      },
    }
  );
}

export async function createPureClient() {
  return createServerClient(
    process.env.NEXT_PUBLIC_SUPABASE_URL!,
    process.env.SUPABASE_SERVICE_ROLE_KEY!,
    {
      cookies: {
        getAll() {
          return [];
        },
        setAll() {},
      },
    }
  );
}
</file>

<file path="src/lib/supabase/types.ts">
export type Database = Record<string, never>;

export type SupabaseUserMetadata = Record<string, unknown>;
</file>

<file path="src/lib/clerk-theme.ts">
import type { Appearance } from "@clerk/types";

export const clerkAppearance: Appearance = {
  layout: {
    socialButtonsPlacement: "bottom",
    socialButtonsVariant: "iconButton",
  },
  variables: {
    // Colors from design guide
    colorPrimary: "#3BA2F8", // Accent Blue
    colorBackground: "#FCFCFD", // Off-White
    colorText: "#111827", // Gray 900
    colorTextSecondary: "#374151", // Gray 700
    colorInputBackground: "#FFFFFF",
    colorInputText: "#111827",
    colorDanger: "#EF4444", // Error Red

    // Border radius
    borderRadius: "8px",

    // Typography
    fontFamily: "Pretendard Variable, -apple-system, sans-serif",
    fontWeight: {
      normal: 400,
      medium: 500,
      semibold: 600,
      bold: 700,
    },
  },
  elements: {
    // Root container
    rootBox: {
      width: "100%",
      maxWidth: "420px",
    },

    // Card
    card: {
      backgroundColor: "#FFFFFF",
      border: "1px solid #E1E5EA",
      borderRadius: "12px",
      boxShadow: "0 4px 6px rgba(0, 0, 0, 0.07)",
      padding: "32px 24px",
    },

    // Header
    headerTitle: {
      fontSize: "24px",
      fontWeight: 600,
      color: "#111827",
      letterSpacing: "-0.025em",
    },
    headerSubtitle: {
      fontSize: "14px",
      fontWeight: 400,
      color: "#6B7280",
      marginTop: "8px",
    },

    // Social buttons
    socialButtonsBlockButton: {
      border: "1px solid #E1E5EA",
      borderRadius: "8px",
      "&:hover": {
        backgroundColor: "#F3F4F6",
      },
    },

    // Form elements
    formFieldLabel: {
      fontSize: "14px",
      fontWeight: 500,
      color: "#374151",
      marginBottom: "8px",
    },
    formFieldInput: {
      height: "40px",
      padding: "12px 16px",
      border: "1px solid #D1D5DB",
      borderRadius: "6px",
      fontSize: "16px",
      "&:focus": {
        borderColor: "#3BA2F8",
        boxShadow: "0 0 0 3px rgba(59, 162, 248, 0.1)",
      },
      "&::placeholder": {
        color: "#D1D5DB",
      },
    },
    formFieldInputShowPasswordButton: {
      color: "#6B7280",
    },

    // Buttons
    formButtonPrimary: {
      height: "48px",
      backgroundColor: "#3BA2F8",
      borderRadius: "8px",
      fontSize: "16px",
      fontWeight: 600,
      padding: "0 24px",
      "&:hover": {
        backgroundColor: "#2E91E5",
      },
      "&:active": {
        backgroundColor: "#2680D0",
      },
    },

    // Footer
    footer: {
      marginTop: "24px",
    },
    footerActionLink: {
      color: "#3BA2F8",
      fontWeight: 500,
      "&:hover": {
        color: "#2E91E5",
      },
    },

    // Divider
    dividerLine: {
      backgroundColor: "#E1E5EA",
    },
    dividerText: {
      color: "#6B7280",
      fontSize: "14px",
    },

    // Alert
    alertText: {
      fontSize: "14px",
    },

    // Identifier
    identityPreviewText: {
      fontSize: "14px",
      fontWeight: 500,
    },

    // Links
    formFieldAction: {
      color: "#3BA2F8",
      fontSize: "14px",
      fontWeight: 500,
      "&:hover": {
        color: "#2E91E5",
      },
    },
  },
};
</file>

<file path="src/lib/slug.ts">
/**
 * Generates a URL-friendly slug from a given string
 * Handles both Korean and English text
 */
export const generateSlug = (text: string): string => {
  return text
    .toLowerCase()
    .trim()
    // Replace Korean characters with romanization (basic approach)
    .replace(/[\u3131-\uD79D]/g, '') // Remove Korean characters for now
    // Replace spaces and special characters with hyphens
    .replace(/[^\w\s-]/g, '')
    .replace(/[\s_]+/g, '-')
    .replace(/^-+|-+$/g, '');
};

/**
 * Generates a unique slug by appending a random string
 */
export const generateUniqueSlug = (text: string): string => {
  const baseSlug = generateSlug(text);
  const randomSuffix = Math.random().toString(36).substring(2, 8);
  return `${baseSlug}-${randomSuffix}`;
};
</file>

<file path="src/lib/utils.ts">
import { clsx, type ClassValue } from "clsx";
import { twMerge } from "tailwind-merge";

export function cn(...inputs: ClassValue[]) {
  return twMerge(clsx(inputs));
}
</file>

<file path="src/types/globals.d.ts">
export {}

declare global {
  interface CustomJwtSessionClaims {
    metadata: {
      onboardingCompleted?: boolean
    }
  }
}
</file>

<file path="supabase/migrations/0001_create_example_table.sql">
-- Migration: create example table for backend reference implementation
-- Ensures pgcrypto available for gen_random_uuid
create extension if not exists "pgcrypto";

create table if not exists public.example (
  id uuid primary key default gen_random_uuid(),
  full_name text,
  avatar_url text,
  bio text,
  updated_at timestamptz not null default now()
);

comment on table public.example is 'Example table used by the hono + next.js starter backend layer.';

insert into public.example (full_name, avatar_url, bio)
values
  (
    'Jane Example',
    'https://picsum.photos/seed/jane-example/200/200',
    'Demonstration record generated by the starter migration.'
  )
  on conflict do nothing;

ALTER TABLE IF EXISTS public.example DISABLE ROW LEVEL SECURITY;
</file>

<file path="supabase/migrations/0002_create_style_guides_table.sql">
-- Migration: create style_guides table for storing user onboarding data
-- This table stores the brand voice, style preferences, and content guidelines
-- for each user to personalize their AI-generated content

-- Ensures pgcrypto available for gen_random_uuid
create extension if not exists "pgcrypto";

-- Create enum types for style guide fields
create type formality_level as enum ('casual', 'neutral', 'formal');
create type language_code as enum ('ko', 'en');
create type content_tone as enum ('professional', 'friendly', 'inspirational', 'educational');
create type content_length_preference as enum ('short', 'medium', 'long');
create type reading_level as enum ('beginner', 'intermediate', 'advanced');

-- Create style_guides table
create table if not exists public.style_guides (
  -- Primary key
  id uuid primary key default gen_random_uuid(),

  -- User reference (one style guide per user for MVP)
  clerk_user_id text not null unique,

  -- Brand Voice fields (Step 1)
  brand_name text not null,
  brand_description text not null,
  personality text[] not null check (array_length(personality, 1) between 1 and 3),
  formality formality_level not null default 'neutral',

  -- Target Audience fields (Step 2)
  target_audience text not null,
  pain_points text not null,

  -- Language field (Step 3)
  language language_code not null default 'ko',

  -- Style fields (Step 4)
  tone content_tone not null default 'professional',
  content_length content_length_preference not null default 'medium',
  reading_level reading_level not null default 'intermediate',

  -- Review/Notes field (Step 5)
  notes text,

  -- Metadata
  is_default boolean not null default true,
  created_at timestamptz not null default now(),
  updated_at timestamptz not null default now()
);

-- Add index for faster lookups by user
create index if not exists idx_style_guides_clerk_user_id
  on public.style_guides(clerk_user_id);

-- Add helpful comments
comment on table public.style_guides is
  'Stores user onboarding data including brand voice, target audience, language preferences, and content style settings. Each user has one style guide for MVP.';

comment on column public.style_guides.clerk_user_id is
  'Reference to Clerk user ID. Unique constraint ensures one style guide per user in MVP.';

comment on column public.style_guides.personality is
  'Array of personality traits (1-3 items). Examples: innovative, trustworthy, playful, etc.';

comment on column public.style_guides.is_default is
  'Flag to mark this as the default style guide for the user. Always true for MVP (single guide per user).';

-- Create trigger function to auto-update updated_at timestamp
create or replace function update_style_guides_updated_at()
returns trigger as $$
begin
  new.updated_at = now();
  return new;
end;
$$ language plpgsql;

-- Create trigger
create trigger set_style_guides_updated_at
  before update on public.style_guides
  for each row
  execute function update_style_guides_updated_at();

-- Disable Row Level Security (RLS)
-- Backend API uses service role key which bypasses RLS
alter table public.style_guides disable row level security;
</file>

<file path="supabase/migrations/0003_create_articles_table.sql">
-- Migration: create articles table for storing AI-generated blog posts
-- This table stores article drafts, published posts, metadata, and SEO information
-- with references to the user's style guide

-- Ensures pgcrypto available for gen_random_uuid
create extension if not exists "pgcrypto";

-- Create enum type for article status
create type article_status as enum ('draft', 'published', 'archived');

-- Create articles table
create table if not exists public.articles (
  -- Primary key
  id uuid primary key default gen_random_uuid(),

  -- User reference
  clerk_user_id text not null,

  -- Basic article information
  title text not null,
  slug text not null,
  keywords text[] not null default array[]::text[],
  description text,
  content text not null,

  -- Style guide reference (nullable for flexibility)
  style_guide_id uuid references public.style_guides(id) on delete set null,

  -- Content style overrides (from style_guides enum types)
  tone content_tone,
  content_length content_length_preference,
  reading_level reading_level,

  -- SEO metadata
  meta_title text,
  meta_description text,

  -- Status and publishing
  status article_status not null default 'draft',
  published_at timestamptz,

  -- Timestamps
  created_at timestamptz not null default now(),
  updated_at timestamptz not null default now()
);

-- Add indexes for faster lookups
create index if not exists idx_articles_clerk_user_id
  on public.articles(clerk_user_id);

create index if not exists idx_articles_slug
  on public.articles(slug);

create index if not exists idx_articles_status
  on public.articles(status);

create index if not exists idx_articles_style_guide_id
  on public.articles(style_guide_id);

create index if not exists idx_articles_published_at
  on public.articles(published_at desc);

-- Add composite index for user's published articles
create index if not exists idx_articles_user_published
  on public.articles(clerk_user_id, status, published_at desc)
  where status = 'published';

-- Add helpful comments
comment on table public.articles is
  'Stores AI-generated blog articles including drafts, published posts, and archived content. Each article can reference a style guide and override specific style settings.';

comment on column public.articles.clerk_user_id is
  'Reference to Clerk user ID. Identifies the article owner.';

comment on column public.articles.slug is
  'URL-friendly slug for the article. Should be unique per user.';

comment on column public.articles.keywords is
  'Array of keywords/tags for SEO and categorization.';

comment on column public.articles.style_guide_id is
  'Optional reference to style guide. If null, uses default style guide.';

comment on column public.articles.tone is
  'Content tone override. If null, uses style guide tone.';

comment on column public.articles.content_length is
  'Content length preference override. If null, uses style guide preference.';

comment on column public.articles.reading_level is
  'Reading level override. If null, uses style guide level.';

comment on column public.articles.status is
  'Article lifecycle status: draft (being edited), published (live), archived (removed from public view).';

comment on column public.articles.published_at is
  'Timestamp when the article was first published. Null for drafts.';

-- Create trigger function to auto-update updated_at timestamp
create or replace function update_articles_updated_at()
returns trigger as $$
begin
  new.updated_at = now();
  return new;
end;
$$ language plpgsql;

-- Create trigger
create trigger set_articles_updated_at
  before update on public.articles
  for each row
  execute function update_articles_updated_at();

-- Disable Row Level Security (RLS)
-- Backend API uses service role key which bypasses RLS
alter table public.articles disable row level security;
</file>

<file path="supabase/migrations/0004_create_generation_quota_table.sql">
-- Create generation_quota table for tracking AI article generation usage
-- Migration: 0004_create_generation_quota_table.sql

BEGIN;

-- Create enum for tier types
CREATE TYPE tier_type AS ENUM ('free', 'pro');

-- Create generation_quota table
CREATE TABLE IF NOT EXISTS generation_quota (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    clerk_user_id TEXT NOT NULL UNIQUE,
    tier tier_type NOT NULL DEFAULT 'free',
    generation_count INTEGER NOT NULL DEFAULT 0,
    last_reset_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);

-- Create index on clerk_user_id for fast lookups
CREATE INDEX IF NOT EXISTS idx_generation_quota_clerk_user_id
    ON generation_quota(clerk_user_id);

-- Create updated_at trigger function if not exists
CREATE OR REPLACE FUNCTION update_updated_at_column()
RETURNS TRIGGER AS $$
BEGIN
    NEW.updated_at = NOW();
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

-- Create trigger to automatically update updated_at
DROP TRIGGER IF EXISTS update_generation_quota_updated_at ON generation_quota;
CREATE TRIGGER update_generation_quota_updated_at
    BEFORE UPDATE ON generation_quota
    FOR EACH ROW
    EXECUTE FUNCTION update_updated_at_column();

-- Disable RLS (Row Level Security)
ALTER TABLE generation_quota DISABLE ROW LEVEL SECURITY;

-- Add comments for documentation
COMMENT ON TABLE generation_quota IS 'Tracks AI article generation quota and usage per user';
COMMENT ON COLUMN generation_quota.clerk_user_id IS 'Clerk user ID (unique identifier)';
COMMENT ON COLUMN generation_quota.tier IS 'User subscription tier (free/pro)';
COMMENT ON COLUMN generation_quota.generation_count IS 'Number of articles generated in current period';
COMMENT ON COLUMN generation_quota.last_reset_at IS 'Timestamp of last quota reset (monthly)';

COMMIT;
</file>

<file path="supabase/migrations/0005_add_onboarding_completed_to_style_guides.sql">
-- Migration: add onboarding_completed column to style_guides table
-- Replaces Clerk metadata with database source of truth for middleware onboarding checks
-- This solves Clerk's session cache delay issue

-- Add onboarding_completed column to style_guides table
ALTER TABLE IF EXISTS public.style_guides
ADD COLUMN IF NOT EXISTS onboarding_completed boolean NOT NULL DEFAULT true;

-- Add comment explaining the column
COMMENT ON COLUMN public.style_guides.onboarding_completed IS
  'Indicates whether the user has completed the onboarding process. Set to true when style guide is first created during onboarding.';

-- The column defaults to true because it is only created when a user completes onboarding,
-- so all existing and new records represent completed onboarding
</file>

<file path=".cursorignore">
pnpm-lock.yaml
yarn.lock
package-lock.json
</file>

<file path=".env.test">
# Test environment variables
NEXT_PUBLIC_SUPABASE_URL=http://localhost:54321
NEXT_PUBLIC_SUPABASE_ANON_KEY=test-anon-key
</file>

<file path="components.json">
{
  "$schema": "https://ui.shadcn.com/schema.json",
  "style": "default",
  "rsc": true,
  "tsx": true,
  "tailwind": {
    "config": "",
    "css": "src/app/globals.css",
    "baseColor": "neutral",
    "cssVariables": true,
    "prefix": ""
  },
  "aliases": {
    "components": "@/components",
    "utils": "@/lib/utils",
    "ui": "@/components/ui",
    "lib": "@/lib",
    "hooks": "@/hooks"
  }
}
</file>

<file path="eslint.config.mjs">
import { dirname } from 'path';
import { fileURLToPath } from 'url';
import { FlatCompat } from '@eslint/eslintrc';

const __filename = fileURLToPath(import.meta.url);
const __dirname = dirname(__filename);

const compat = new FlatCompat({
  baseDirectory: __dirname,
});

const eslintConfig = [
  ...compat.extends('next/core-web-vitals', 'next/typescript'),
  {
    rules: {
      '@typescript-eslint/no-empty-object-type': 'off',
      '@typescript-eslint/no-explicit-any': 'off',
      '@typescript-eslint/no-unused-vars': 'off',
    },
  },
];

export default eslintConfig;
</file>

<file path="next.config.ts">
import type { NextConfig } from 'next';

const nextConfig: NextConfig = {
  /* config options here */
  eslint: {
    ignoreDuringBuilds: true,
  },
  images: {
    remotePatterns: [
      {
        hostname: '**',
      },
    ],
  },
};

export default nextConfig;
</file>

<file path="playwright.config.ts">
import { defineConfig, devices } from '@playwright/test';

/**
 * See https://playwright.dev/docs/test-configuration.
 */
export default defineConfig({
  testDir: './e2e',
  /* Run tests in files in parallel */
  fullyParallel: true,
  /* Fail the build on CI if you accidentally left test.only in the source code. */
  forbidOnly: !!process.env.CI,
  /* Retry on CI only */
  retries: process.env.CI ? 2 : 0,
  /* Opt out of parallel tests on CI. */
  workers: process.env.CI ? 1 : undefined,
  /* Reporter to use. See https://playwright.dev/docs/test-reporters */
  reporter: 'html',
  /* Shared settings for all the projects below. See https://playwright.dev/docs/api/class-testoptions. */
  use: {
    /* Base URL to use in actions like `await page.goto('/')`. */
    baseURL: process.env.PLAYWRIGHT_BASE_URL || 'http://localhost:3000',
    /* Collect trace when retrying the failed test. See https://playwright.dev/docs/trace-viewer */
    trace: 'on-first-retry',
  },

  /* Configure projects for major browsers */
  projects: [
    {
      name: 'chromium',
      use: { ...devices['Desktop Chrome'] },
    },
  ],

  /* Run your local dev server before starting the tests */
  webServer: {
    command: 'npm run dev',
    url: 'http://localhost:3000',
    reuseExistingServer: !process.env.CI,
    env: {
      NEXT_PUBLIC_SUPABASE_URL: process.env.NEXT_PUBLIC_SUPABASE_URL || 'http://localhost:54321',
      NEXT_PUBLIC_SUPABASE_ANON_KEY: process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY || 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6InRlc3QiLCJyb2xlIjoiYW5vbiIsImlhdCI6MTYwMzk2ODgzNCwiZXhwIjoxOTYwMzk2ODM0fQ.xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx',
    },
  },
});
</file>

<file path="postcss.config.mjs">
/** @type {import('postcss-load-config').Config} */
const config = {
  plugins: {
    '@tailwindcss/postcss': {},
  },
};

export default config;
</file>

<file path="tsconfig.json">
{
  "compilerOptions": {
    "target": "ES2017",
    "lib": ["dom", "dom.iterable", "esnext"],
    "allowJs": true,
    "skipLibCheck": true,
    "strict": true,
    "noEmit": true,
    "esModuleInterop": true,
    "strictNullChecks": false,
    "module": "esnext",
    "moduleResolution": "bundler",
    "resolveJsonModule": true,
    "isolatedModules": true,
    "noImplicitAny": false,
    "jsx": "preserve",
    "incremental": true,
    "plugins": [
      {
        "name": "next"
      }
    ],
    "paths": {
      "@/*": ["./src/*"]
    }
  },
  "include": ["next-env.d.ts", "**/*.ts", "**/*.tsx", ".next/types/**/*.ts"],
  "exclude": ["node_modules"]
}
</file>

<file path="vitest.config.ts">
import { defineConfig } from 'vitest/config';
import react from '@vitejs/plugin-react';
import path from 'path';
import { fileURLToPath } from 'url';

const __dirname = path.dirname(fileURLToPath(import.meta.url));

export default defineConfig({
  plugins: [react()],
  test: {
    globals: true,
    environment: 'happy-dom',
    setupFiles: ['./vitest.setup.ts'],
    exclude: ['**/node_modules/**', '**/e2e/**'],
    coverage: {
      provider: 'v8',
      reporter: ['text', 'json', 'html'],
      exclude: [
        'node_modules/**',
        'e2e/**',
        '**/*.config.{js,ts}',
        '**/types.ts',
        '**/*.d.ts',
      ],
    },
  },
  resolve: {
    alias: {
      '@': path.resolve(__dirname, './src'),
    },
  },
});
</file>

<file path="vitest.d.ts">
import 'vitest';
import type { TestingLibraryMatchers } from '@testing-library/jest-dom/matchers';

declare module 'vitest' {
  interface Assertion<T = any> extends TestingLibraryMatchers<typeof expect.stringContaining, T> {}
  interface AsymmetricMatchersContaining extends TestingLibraryMatchers {}
}
</file>

<file path="vitest.setup.ts">
import { expect, afterEach } from 'vitest';
import { cleanup } from '@testing-library/react';
import * as matchers from '@testing-library/jest-dom/matchers';

// Extend Vitest matchers with Testing Library
expect.extend(matchers);

// Cleanup after each test
afterEach(() => {
  cleanup();
});
</file>

<file path=".ruler/ruler.toml">
# Ruler Configuration File
# See https://ai.intellectronica.net/ruler for documentation.

# To specify which agents are active by default when --agents is not used,
# uncomment and populate the following line. If omitted, all agents are active.
default_agents = ["cursor", "codex", "claude"]

# Enable nested rule loading from nested .ruler directories
# When enabled, ruler will search for and process .ruler directories throughout the project hierarchy
# nested = false

# --- Agent Specific Configurations ---
# You can enable/disable agents and override their default output paths here.
# Use lowercase agent identifiers: amp, copilot, claude, codex, cursor, windsurf, cline, aider, kilocode

# [agents.copilot]
# enabled = true
# output_path = ".github/copilot-instructions.md"

# [agents.aider]
# enabled = true
# output_path_instructions = "AGENTS.md"
# output_path_config = ".aider.conf.yml"

# [agents.gemini-cli]
# enabled = true

# --- MCP Servers ---
# Define Model Context Protocol servers here. Two examples:
# 1. A stdio server (local executable)
# 2. A remote server (HTTP-based)

# [mcp_servers.example_stdio]
# command = "node"
# args = ["scripts/your-mcp-server.js"]
# env = { API_KEY = "replace_me" }

# [mcp_servers.example_remote]
# url = "https://api.example.com/mcp"
# headers = { Authorization = "Bearer REPLACE_ME" }
</file>

<file path=".vooster/project.json">
{
  "uid": "6G09",
  "name": "IndieBlog",
  "description": "키워드만 입력하면 5분 내에 영어와 한국어 블로그 글, SEO 메타데이터, 브랜드 톤까지 자동 완성하는 AI 콘텐츠 생성 SaaS입니다.",
  "connectedAt": "2025-11-08T10:13:51.896Z"
}
</file>

<file path="src/app/(protected)/articles/[id]/edit/page.tsx">
'use client';

import { useState, useEffect, use } from 'react';
import dynamic from 'next/dynamic';
import { useRouter } from 'next/navigation';
import { Card } from '@/components/ui/card';
import { Button } from '@/components/ui/button';
import { Input } from '@/components/ui/input';
import { Label } from '@/components/ui/label';
import { Tabs, TabsContent, TabsList, TabsTrigger } from '@/components/ui/tabs';
import { useToast } from '@/hooks/use-toast';
import { ArrowLeft, Eye, Edit, List, X, Download, Copy, Check } from 'lucide-react';
import { useArticle } from '@/features/articles/hooks/useArticle';
import { useAutoSave } from '@/features/articles/hooks/useAutoSave';
import { AutoSaveIndicator } from '@/features/articles/components/auto-save-indicator';
import { MarkdownPreview } from '@/features/articles/components/markdown-preview';
import { TableOfContents } from '@/features/articles/components/table-of-contents';
import { extractHeadings, downloadMarkdown, copyToClipboard } from '@/features/articles/lib/markdown-utils';

// 동적 임포트 (SSR 방지)
const MDEditor = dynamic(() => import('@uiw/react-md-editor'), { ssr: false });

type EditorPageProps = {
  params: Promise<{ id: string }>;
};

export default function EditorPage({ params }: EditorPageProps) {
  const resolvedParams = use(params);
  const articleId = resolvedParams.id;
  const router = useRouter();
  const { toast } = useToast();

  const { data: article, isLoading, isError } = useArticle(articleId);

  const [title, setTitle] = useState('');
  const [slug, setSlug] = useState('');
  const [content, setContent] = useState('');
  const [description, setDescription] = useState('');
  const [keywords, setKeywords] = useState('');
  const [showToc, setShowToc] = useState(false);
  const [copySuccess, setCopySuccess] = useState(false);

  // 초기 데이터 로드
  useEffect(() => {
    if (article) {
      setTitle(article.title || '');
      setSlug(article.slug || '');
      setContent(article.content || '');
      setDescription(article.description || '');
      // keywords는 배열이므로 쉼표로 구분된 문자열로 변환
      setKeywords(Array.isArray(article.keywords) ? article.keywords.join(', ') : '');
    }
  }, [article]);

  // 자동 저장 - keywords를 배열로 변환
  const autoSave = useAutoSave(articleId, {
    title,
    slug,
    content,
    description,
    keywords: keywords
      .split(',')
      .map((k) => k.trim())
      .filter((k) => k.length > 0),
  });

  // 헤딩 추출
  const headings = extractHeadings(content);

  const handleDownloadMarkdown = () => {
    downloadMarkdown(title || 'article', content);
    toast({
      title: '다운로드 완료',
      description: '마크다운 파일이 다운로드되었습니다.',
    });
  };

  const handleCopyMarkdown = async () => {
    try {
      await copyToClipboard(content);
      setCopySuccess(true);
      toast({
        title: '복사 완료',
        description: '마크다운이 클립보드에 복사되었습니다.',
      });
      setTimeout(() => setCopySuccess(false), 2000);
    } catch (error) {
      toast({
        title: '복사 실패',
        description: '마크다운을 복사하는 중 오류가 발생했습니다.',
        variant: 'destructive',
      });
    }
  };

  if (isLoading) {
    return (
      <div className="flex items-center justify-center min-h-screen">
        <div className="text-center">
          <div className="animate-spin rounded-full h-12 w-12 border-b-2 border-primary mx-auto mb-4"></div>
          <p className="text-muted-foreground">로딩 중...</p>
        </div>
      </div>
    );
  }

  if (isError) {
    return (
      <div className="flex flex-col items-center justify-center min-h-screen gap-4">
        <p className="text-red-500">글을 불러오는 데 실패했습니다.</p>
        <Button onClick={() => router.push('/dashboard')}>
          대시보드로 돌아가기
        </Button>
      </div>
    );
  }

  return (
    <div className="min-h-screen" style={{ backgroundColor: '#FCFCFD' }}>
      <div className="container mx-auto max-w-[1600px] px-4 py-8">
        {/* 헤더 */}
        <div className="mb-6 flex items-center justify-between">
          <div className="flex items-center gap-4">
            <Button variant="ghost" onClick={() => router.back()}>
              <ArrowLeft className="mr-2 h-4 w-4" />
              뒤로
            </Button>
            <div>
              <h1 className="text-2xl font-bold">글 편집</h1>
              <AutoSaveIndicator {...autoSave} />
            </div>
          </div>
          <Button
            onClick={() => setShowToc(!showToc)}
            variant="outline"
            className="hidden lg:flex"
          >
            {showToc ? (
              <>
                <X className="mr-2 h-4 w-4" />
                목차 숨기기
              </>
            ) : (
              <>
                <List className="mr-2 h-4 w-4" />
                목차 보기
              </>
            )}
          </Button>
        </div>

        {/* Desktop: 2컬럼 + 옵션 사이드바 */}
        <div className="hidden lg:flex lg:gap-6">
          {/* 목차 사이드바 */}
          {showToc && (
            <div className="w-64 flex-shrink-0">
              <div className="sticky top-8">
                <TableOfContents headings={headings} />
              </div>
            </div>
          )}

          {/* 에디터 */}
          <Card className="flex-1 p-6 space-y-4">
            <div>
              <Label htmlFor="title">제목</Label>
              <Input
                id="title"
                value={title}
                onChange={(e) => setTitle(e.target.value)}
                placeholder="글 제목을 입력하세요"
                className="mt-1"
              />
            </div>
            <div>
              <Label htmlFor="slug">슬러그 (URL)</Label>
              <Input
                id="slug"
                value={slug}
                onChange={(e) => setSlug(e.target.value)}
                placeholder="url-friendly-slug"
                className="mt-1"
              />
            </div>
            <div>
              <Label htmlFor="keywords">키워드 (쉼표로 구분)</Label>
              <Input
                id="keywords"
                value={keywords}
                onChange={(e) => setKeywords(e.target.value)}
                placeholder="키워드1, 키워드2, 키워드3"
                className="mt-1"
              />
            </div>
            <div>
              <Label htmlFor="description">요약</Label>
              <Input
                id="description"
                value={description}
                onChange={(e) => setDescription(e.target.value)}
                placeholder="글 요약을 입력하세요"
                className="mt-1"
              />
            </div>
            <div>
              <Label htmlFor="content">본문 (마크다운)</Label>
              <div data-color-mode="light" className="mt-1">
                <MDEditor
                  value={content}
                  onChange={(val) => setContent(val || '')}
                  height={500}
                  preview="edit"
                />
              </div>
              {/* 내보내기 버튼 */}
              <div className="flex gap-2 mt-4">
                <Button
                  type="button"
                  variant="outline"
                  size="sm"
                  onClick={handleDownloadMarkdown}
                  className="flex-1"
                >
                  <Download className="mr-2 h-4 w-4" />
                  다운로드
                </Button>
                <Button
                  type="button"
                  variant="outline"
                  size="sm"
                  onClick={handleCopyMarkdown}
                  className="flex-1"
                >
                  {copySuccess ? (
                    <>
                      <Check className="mr-2 h-4 w-4" />
                      복사됨
                    </>
                  ) : (
                    <>
                      <Copy className="mr-2 h-4 w-4" />
                      복사
                    </>
                  )}
                </Button>
              </div>
            </div>
          </Card>

          {/* 미리보기 */}
          <Card
            className="flex-1 p-6 overflow-auto"
            style={{ maxHeight: '800px' }}
          >
            <h2 className="text-xl font-bold mb-4">{title || '제목 없음'}</h2>
            {description && (
              <p className="text-muted-foreground mb-6">{description}</p>
            )}
            <MarkdownPreview content={content} />
          </Card>
        </div>

        {/* Tablet/Mobile: 탭 */}
        <div className="lg:hidden">
          <Tabs defaultValue="edit">
            <TabsList className="grid w-full grid-cols-2">
              <TabsTrigger value="edit">
                <Edit className="mr-2 h-4 w-4" />
                편집
              </TabsTrigger>
              <TabsTrigger value="preview">
                <Eye className="mr-2 h-4 w-4" />
                미리보기
              </TabsTrigger>
            </TabsList>
            <TabsContent value="edit" className="mt-4">
              <Card className="p-4 space-y-4">
                <div>
                  <Label htmlFor="title-mobile">제목</Label>
                  <Input
                    id="title-mobile"
                    value={title}
                    onChange={(e) => setTitle(e.target.value)}
                    placeholder="글 제목을 입력하세요"
                    className="mt-1"
                  />
                </div>
                <div>
                  <Label htmlFor="slug-mobile">슬러그</Label>
                  <Input
                    id="slug-mobile"
                    value={slug}
                    onChange={(e) => setSlug(e.target.value)}
                    placeholder="url-friendly-slug"
                    className="mt-1"
                  />
                </div>
                <div>
                  <Label htmlFor="keywords-mobile">키워드</Label>
                  <Input
                    id="keywords-mobile"
                    value={keywords}
                    onChange={(e) => setKeywords(e.target.value)}
                    placeholder="키워드1, 키워드2"
                    className="mt-1"
                  />
                </div>
                <div>
                  <Label htmlFor="description-mobile">요약</Label>
                  <Input
                    id="description-mobile"
                    value={description}
                    onChange={(e) => setDescription(e.target.value)}
                    placeholder="글 요약"
                    className="mt-1"
                  />
                </div>
                <div>
                  <Label htmlFor="content-mobile">본문</Label>
                  <div data-color-mode="light" className="mt-1">
                    <MDEditor
                      value={content}
                      onChange={(val) => setContent(val || '')}
                      height={400}
                    />
                  </div>
                  {/* 내보내기 버튼 */}
                  <div className="flex gap-2 mt-4">
                    <Button
                      type="button"
                      variant="outline"
                      size="sm"
                      onClick={handleDownloadMarkdown}
                      className="flex-1"
                    >
                      <Download className="mr-2 h-3 w-3" />
                      다운로드
                    </Button>
                    <Button
                      type="button"
                      variant="outline"
                      size="sm"
                      onClick={handleCopyMarkdown}
                      className="flex-1"
                    >
                      {copySuccess ? (
                        <>
                          <Check className="mr-2 h-3 w-3" />
                          복사됨
                        </>
                      ) : (
                        <>
                          <Copy className="mr-2 h-3 w-3" />
                          복사
                        </>
                      )}
                    </Button>
                  </div>
                </div>
              </Card>
            </TabsContent>
            <TabsContent value="preview" className="mt-4">
              <Card className="p-4">
                <h2 className="text-xl font-bold mb-4">{title || '제목 없음'}</h2>
                {description && (
                  <p className="text-muted-foreground mb-6">{description}</p>
                )}
                <MarkdownPreview content={content} />
              </Card>
            </TabsContent>
          </Tabs>
        </div>
      </div>
    </div>
  );
}
</file>

<file path="src/app/(protected)/style-guide/page.tsx">
"use client";

import { useState, useEffect } from "react";
import { useRouter } from "next/navigation";
import { useQuery, useQueryClient } from "@tanstack/react-query";
import { Button } from "@/components/ui/button";
import { Plus, Loader2 } from "lucide-react";
import { useToast } from "@/hooks/use-toast";
import { StyleGuideCard } from "@/features/onboarding/components/style-guide-card";
import { StyleGuidePreviewModal } from "@/features/onboarding/components/style-guide-preview-modal";
import type { StyleGuideResponse } from "@/features/onboarding/backend/schema";
import { getUserStyleGuide, deleteStyleGuideAction } from "@/features/articles/actions/article-actions";

type StyleGuidePageProps = {
  params: Promise<Record<string, never>>;
};

export default function StyleGuidePage({ params }: StyleGuidePageProps) {
  void params;
  const router = useRouter();
  const { toast } = useToast();
  const queryClient = useQueryClient();

  const [previewGuide, setPreviewGuide] = useState<StyleGuideResponse | null>(
    null
  );
  const [isPreviewOpen, setIsPreviewOpen] = useState(false);

  // Refetch on page focus to ensure fresh data
  useEffect(() => {
    const handleFocus = () => {
      queryClient.invalidateQueries({ queryKey: ["userStyleGuide"] });
    };

    window.addEventListener("focus", handleFocus);
    return () => window.removeEventListener("focus", handleFocus);
  }, [queryClient]);

  // Fetch user's style guide
  const { data: guide, isLoading, isError, refetch } = useQuery<StyleGuideResponse | null>({
    queryKey: ["userStyleGuide"],
    queryFn: getUserStyleGuide,
    retry: false,
    gcTime: 0, // Disable cache
  });

  const handlePreview = (guide: StyleGuideResponse) => {
    setPreviewGuide(guide);
    setIsPreviewOpen(true);
  };

  const handleEdit = (guide: StyleGuideResponse) => {
    router.push(`/style-guides/${guide.id}/edit`);
  };

  const handleDelete = async (id: string) => {
    // Show confirmation dialog
    if (!window.confirm("이 스타일 가이드를 삭제하시겠습니까? 이 작업은 되돌릴 수 없습니다.")) {
      return;
    }

    try {
      await deleteStyleGuideAction(id);
      toast({
        title: "삭제 완료",
        description: "스타일 가이드가 삭제되었습니다.",
      });
      // Clear cache and refetch
      await queryClient.invalidateQueries({ queryKey: ["userStyleGuide"] });
      await refetch();
    } catch (error) {
      toast({
        title: "오류",
        description:
          error instanceof Error
            ? error.message
            : "스타일 가이드 삭제에 실패했습니다.",
        variant: "destructive",
      });
    }
  };

  const handleCreateNew = () => {
    router.push("/style-guides/new");
  };

  if (isLoading) {
    return (
      <div className="min-h-screen" style={{ backgroundColor: "#FCFCFD" }}>
        <div className="container mx-auto max-w-4xl px-4 py-8">
          <div className="flex items-center justify-center min-h-[400px]">
            <div className="flex flex-col items-center gap-4">
              <Loader2 className="h-8 w-8 animate-spin text-primary" />
              <p className="text-muted-foreground">로딩 중...</p>
            </div>
          </div>
        </div>
      </div>
    );
  }

  if (isError) {
    return (
      <div className="min-h-screen" style={{ backgroundColor: "#FCFCFD" }}>
        <div className="container mx-auto max-w-4xl px-4 py-8">
          <div className="flex flex-col items-center justify-center min-h-[400px] gap-4">
            <p className="text-red-500">스타일 가이드를 불러오는 데 실패했습니다.</p>
            <Button onClick={() => router.refresh()}>다시 시도</Button>
          </div>
        </div>
      </div>
    );
  }

  return (
    <div className="min-h-screen" style={{ backgroundColor: "#FCFCFD" }}>
      <div className="container mx-auto max-w-4xl px-4 py-8">
        {/* 헤더 */}
        <div className="mb-8 flex items-center justify-between">
          <div>
            <h1 className="text-3xl font-bold" style={{ color: "#1F2937" }}>
              스타일 가이드
            </h1>
            <p className="mt-2 text-muted-foreground">
              AI 글 생성에 사용할 블로그의 스타일 가이드를 관리합니다.
            </p>
          </div>
          <Button onClick={handleCreateNew} size="lg">
            <Plus className="mr-2 h-4 w-4" />
            새 가이드 생성
          </Button>
        </div>

        {/* 가이드 목록 */}
        {guide ? (
          <div className="space-y-4">
            <StyleGuideCard
              guide={guide}
              onEdit={handleEdit}
              onDelete={handleDelete}
              onPreview={handlePreview}
            />
          </div>
        ) : (
          <div
            className="rounded-lg border border-dashed p-12 text-center"
            style={{ borderColor: "#E1E5EA" }}
          >
            <p className="mb-4 text-muted-foreground">
              아직 생성된 스타일 가이드가 없습니다.
            </p>
            <Button onClick={handleCreateNew}>스타일 가이드 생성하기</Button>
          </div>
        )}
      </div>

      {/* 미리보기 모달 */}
      <StyleGuidePreviewModal
        guide={previewGuide}
        isOpen={isPreviewOpen}
        onClose={() => setIsPreviewOpen(false)}
      />
    </div>
  );
}
</file>

<file path="src/app/(public)/page.tsx">
"use client";

import { HeroSection } from "@/features/landing/components/hero-section";
import { FeaturesSection } from "@/features/landing/components/features-section";
import { HowItWorksSection } from "@/features/landing/components/how-it-works-section";
import { UseCasesSection } from "@/features/landing/components/use-cases-section";
import { PricingSection } from "@/features/landing/components/pricing-section";
import { FinalCtaSection } from "@/features/landing/components/final-cta-section";

export default function HomePage() {
  return (
    <main className="min-h-screen bg-[#FCFCFD]">
      <HeroSection />
      <FeaturesSection />
      <HowItWorksSection />
      <UseCasesSection />
      <PricingSection />
      <FinalCtaSection />
    </main>
  );
}
</file>

<file path="src/app/api/articles/generate/route.ts">
import { auth } from '@clerk/nextjs/server';
import { streamText } from 'ai';
import { createGoogleGenerativeAI } from '@ai-sdk/google';
import type { SupabaseClient } from '@supabase/supabase-js';
import { createClient } from '@supabase/supabase-js';
import type { GenerateArticleRequest } from '@/features/articles/backend/schema';
import {
  checkQuota,
} from '@/features/articles/backend/quota-service';
import { articleErrorCodes } from '@/features/articles/backend/error';

type StyleGuideResponse = {
  id: string;
  clerkUserId: string;
  brandName: string;
  brandDescription: string;
  personality: string[];
  formality: string;
  targetAudience: string;
  painPoints: string;
  language: string;
  tone: string;
  contentLength: string;
  readingLevel: string;
  notes?: string;
  isDefault: boolean;
  createdAt: string;
  updatedAt: string;
};

const STYLE_GUIDES_TABLE = 'style_guides';

/**
 * Gets style guide by ID or default style guide for user
 */
const getStyleGuide = async (
  client: SupabaseClient,
  clerkUserId: string,
  styleGuideId?: string,
): Promise<StyleGuideResponse | null> => {
  let query = client.from(STYLE_GUIDES_TABLE).select('*').eq('clerk_user_id', clerkUserId);

  if (styleGuideId) {
    query = query.eq('id', styleGuideId);
  } else {
    query = query.eq('is_default', true);
  }

  const { data, error } = await query.single();

  if (error || !data) {
    return null;
  }

  // Map snake_case to camelCase
  return {
    id: data.id,
    clerkUserId: data.clerk_user_id,
    brandName: data.brand_name,
    brandDescription: data.brand_description,
    personality: data.personality,
    formality: data.formality,
    targetAudience: data.target_audience,
    painPoints: data.pain_points,
    language: data.language,
    tone: data.tone,
    contentLength: data.content_length,
    readingLevel: data.reading_level,
    notes: data.notes,
    isDefault: data.is_default,
    createdAt: data.created_at,
    updatedAt: data.updated_at,
  };
};

/**
 * Builds AI prompt based on topic, style guide, and keywords
 */
const buildPrompt = (
  topic: string,
  styleGuide: StyleGuideResponse | null,
  keywords: string[],
  additionalInstructions?: string,
): string => {
  const language = styleGuide?.language || 'ko';
  const isKorean = language === 'ko';

  const contentLengthGuide = {
    short: isKorean ? '1000-1500자' : '500-800 words',
    medium: isKorean ? '2000-3000자' : '1000-1500 words',
    long: isKorean ? '4000-6000자' : '2000-3000 words',
  };

  const readingLevelGuide = {
    beginner: isKorean ? '초보자도 쉽게 이해할 수 있는' : 'beginner-friendly',
    intermediate: isKorean ? '중급 수준의' : 'intermediate-level',
    advanced: isKorean ? '전문적이고 심화된' : 'advanced and in-depth',
  };

  const toneGuide = {
    professional: isKorean ? '전문적이고 신뢰감 있는' : 'professional and trustworthy',
    friendly: isKorean ? '친근하고 대화하는 듯한' : 'friendly and conversational',
    inspirational: isKorean ? '영감을 주고 동기부여하는' : 'inspirational and motivating',
    educational: isKorean ? '교육적이고 정보 전달에 충실한' : 'educational and informative',
  };

  const promptTemplate = isKorean
    ? `
당신은 전문 블로그 콘텐츠 작가입니다. 다음 조건에 맞춰 고품질 블로그 글을 작성해주세요.

**주제**: ${topic}

**브랜드 정보**:
${styleGuide ? `- 브랜드명: ${styleGuide.brandName}
- 브랜드 설명: ${styleGuide.brandDescription}
- 브랜드 성격: ${styleGuide.personality.join(', ')}
- 격식 수준: ${styleGuide.formality}
- 타겟 독자: ${styleGuide.targetAudience}
- 독자의 고민: ${styleGuide.painPoints}` : '일반적인 블로그 스타일로 작성'}

**작성 스타일**:
- 어조: ${styleGuide ? toneGuide[styleGuide.tone as keyof typeof toneGuide] : '친근하고 전문적인'}
- 글 길이: ${styleGuide ? contentLengthGuide[styleGuide.contentLength as keyof typeof contentLengthGuide] : '2000-3000자'}
- 난이도: ${styleGuide ? readingLevelGuide[styleGuide.readingLevel as keyof typeof readingLevelGuide] : '중급 수준의'}

**키워드**: ${keywords.length > 0 ? keywords.join(', ') : '주제와 관련된 키워드를 자연스럽게 포함'}

${additionalInstructions ? `**추가 지시사항**: ${additionalInstructions}` : ''}

**작성 요구사항**:
1. 제목은 SEO에 최적화되고 클릭을 유도할 수 있도록 작성
2. 본문은 Markdown 형식으로 작성 (제목, 소제목, 목록, 강조 등 활용)
3. 서론, 본론, 결론 구조를 갖추되 자연스럽게 전개
4. 실용적이고 실행 가능한 정보 제공
5. 독자의 고민을 해결하는 데 집중
6. Meta Description은 160자 이내로 요약
7. 주요 키워드를 자연스럽게 본문에 포함
8. 소제목(headings)은 명확하고 구조적으로 구성

**출력 형식**:
- title: 블로그 글 제목
- content: Markdown 형식의 본문 (제목 제외)
- metaDescription: SEO를 위한 메타 설명 (160자 이내)
- keywords: 관련 키워드 배열 (5-10개)
- headings: 본문의 주요 소제목 배열
`
    : `
You are a professional blog content writer. Create a high-quality blog post according to the following requirements.

**Topic**: ${topic}

**Brand Information**:
${styleGuide ? `- Brand Name: ${styleGuide.brandName}
- Brand Description: ${styleGuide.brandDescription}
- Brand Personality: ${styleGuide.personality.join(', ')}
- Formality Level: ${styleGuide.formality}
- Target Audience: ${styleGuide.targetAudience}
- Audience Pain Points: ${styleGuide.painPoints}` : 'Write in a general blog style'}

**Writing Style**:
- Tone: ${styleGuide ? toneGuide[styleGuide.tone as keyof typeof toneGuide] : 'friendly and professional'}
- Content Length: ${styleGuide ? contentLengthGuide[styleGuide.contentLength as keyof typeof contentLengthGuide] : '1000-1500 words'}
- Reading Level: ${styleGuide ? readingLevelGuide[styleGuide.readingLevel as keyof typeof readingLevelGuide] : 'intermediate-level'}

**Keywords**: ${keywords.length > 0 ? keywords.join(', ') : 'Naturally include relevant keywords'}

${additionalInstructions ? `**Additional Instructions**: ${additionalInstructions}` : ''}

**Writing Requirements**:
1. Create an SEO-optimized title that encourages clicks
2. Write the body in Markdown format (use headings, subheadings, lists, emphasis, etc.)
3. Structure with introduction, body, and conclusion in a natural flow
4. Provide practical and actionable information
5. Focus on solving the reader's pain points
6. Summarize in Meta Description (max 160 characters)
7. Naturally incorporate main keywords throughout the content
8. Organize headings clearly and structurally

**Output Format**:
- title: Blog post title
- content: Markdown-formatted body (excluding title)
- metaDescription: SEO meta description (max 160 chars)
- keywords: Array of relevant keywords (5-10)
- headings: Array of main subheadings from the content
`;

  return promptTemplate;
};

export async function POST(req: Request) {
  try {
    // Authenticate user
    const { userId } = await auth();

    if (!userId) {
      return new Response(
        JSON.stringify({
          error: {
            code: articleErrorCodes.unauthorized,
            message: 'Unauthorized',
          },
        }),
        { status: 401, headers: { 'Content-Type': 'application/json' } }
      );
    }

    // Parse request body - expects direct GenerateArticleRequest
    const body = await req.json();
    const { topic, styleGuideId, keywords = [], additionalInstructions } = body as GenerateArticleRequest;

    if (!topic) {
      return new Response(
        JSON.stringify({
          error: {
            code: articleErrorCodes.validationError,
            message: 'Topic is required',
          },
        }),
        { status: 400, headers: { 'Content-Type': 'application/json' } }
      );
    }

    // Initialize Supabase client
    const supabaseUrl = process.env.NEXT_PUBLIC_SUPABASE_URL;
    const supabaseServiceKey = process.env.SUPABASE_SERVICE_ROLE_KEY;

    if (!supabaseUrl || !supabaseServiceKey) {
      return new Response(
        JSON.stringify({
          error: {
            code: articleErrorCodes.aiGenerationFailed,
            message: 'Server configuration error',
          },
        }),
        { status: 500, headers: { 'Content-Type': 'application/json' } }
      );
    }

    const supabase = createClient(supabaseUrl, supabaseServiceKey);

    // Check quota
    const quotaCheckResult = await checkQuota(supabase, userId);

    if (!quotaCheckResult.ok) {
      return new Response(
        JSON.stringify({
          error: {
            code: (quotaCheckResult as any).error?.code || articleErrorCodes.quotaCheckFailed,
            message: (quotaCheckResult as any).error?.message || 'Quota check failed',
            details: (quotaCheckResult as any).error?.details,
          },
        }),
        { status: 500, headers: { 'Content-Type': 'application/json' } }
      );
    }

    if (!quotaCheckResult.data.allowed) {
      return new Response(
        JSON.stringify({
          error: {
            code: articleErrorCodes.quotaExceeded,
            message: `Generation quota exceeded. You have used ${quotaCheckResult.data.currentCount}/${quotaCheckResult.data.limit} generations.`,
            details: {
              tier: quotaCheckResult.data.tier,
              currentCount: quotaCheckResult.data.currentCount,
              limit: quotaCheckResult.data.limit,
            },
          },
        }),
        { status: 429, headers: { 'Content-Type': 'application/json' } }
      );
    }

    // Get style guide
    const styleGuide = await getStyleGuide(supabase, userId, styleGuideId);

    if (styleGuideId && !styleGuide) {
      return new Response(
        JSON.stringify({
          error: {
            code: articleErrorCodes.styleGuideNotFound,
            message: 'Style guide not found',
          },
        }),
        { status: 404, headers: { 'Content-Type': 'application/json' } }
      );
    }

    // Build prompt
    const systemPrompt = buildPrompt(topic, styleGuide, keywords || [], additionalInstructions);

    // Get API key
    const apiKey = process.env.GOOGLE_GENERATIVE_AI_API_KEY;

    if (!apiKey) {
      return new Response(
        JSON.stringify({
          error: {
            code: articleErrorCodes.aiGenerationFailed,
            message: 'Server configuration error',
          },
        }),
        { status: 500, headers: { 'Content-Type': 'application/json' } }
      );
    }

    const google = createGoogleGenerativeAI({ apiKey });

    // Stream text generation with simple prompt
    const result = streamText({
      model: google('gemini-2.5-flash'),
      system: systemPrompt,
      messages: [
        {
          role: 'user',
          content: '위의 조건에 따라 블로그 글을 작성해주세요.',
        },
      ],
    });

    // Return stream response
    return result.toTextStreamResponse();
  } catch (error) {
    console.error('Error generating article:', error);

    return new Response(
      JSON.stringify({
        error: {
          code: articleErrorCodes.aiGenerationFailed,
          message: error instanceof Error ? error.message : 'AI generation failed',
        },
      }),
      { status: 500, headers: { 'Content-Type': 'application/json' } }
    );
  }
}
</file>

<file path="src/app/auth/after/page.tsx">
import { auth } from "@clerk/nextjs/server";
import { redirect } from "next/navigation";

export default async function AfterAuthPage() {
  const { userId, sessionClaims } = await auth();

  // 인증되지 않은 경우 로그인 페이지로 리디렉트
  if (!userId) {
    redirect("/sign-in");
  }

  // 온보딩 완료 여부 확인
  const onboardingCompleted = sessionClaims?.metadata?.onboardingCompleted === true;

  if (onboardingCompleted) {
    // 온보딩 완료 시 대시보드로 리디렉트
    redirect("/dashboard");
  } else {
    // 온보딩 미완료 시 온보딩 페이지로 리디렉트
    redirect("/auth/onboarding");
  }
}
</file>

<file path="src/app/login/page.tsx">
import { redirect } from "next/navigation";

export default function LoginPage() {
  redirect("/sign-in");
}
</file>

<file path="src/app/sign-in/[[...sign-in]]/page.tsx">
import { SignIn } from "@clerk/nextjs";
import { clerkAppearance } from "@/lib/clerk-theme";

export default function Page() {
  return (
    <div className="flex min-h-screen items-center justify-center" style={{ backgroundColor: "#FCFCFD" }}>
      <div className="w-full max-w-md px-4">
        <div className="mb-8 text-center">
          <h1 className="text-2xl font-bold text-gray-900 mb-2">ContentCraft AI</h1>
          <p className="text-sm text-gray-600">AI 기반 콘텐츠 생성 플랫폼</p>
        </div>
        <SignIn appearance={clerkAppearance} />
      </div>
    </div>
  );
}
</file>

<file path="src/app/sign-up/[[...sign-up]]/page.tsx">
import { SignUp } from "@clerk/nextjs";
import { clerkAppearance } from "@/lib/clerk-theme";

export default function Page() {
  return (
    <div className="flex min-h-screen items-center justify-center" style={{ backgroundColor: "#FCFCFD" }}>
      <div className="w-full max-w-md px-4">
        <div className="mb-8 text-center">
          <h1 className="text-2xl font-bold text-gray-900 mb-2">ContentCraft AI</h1>
          <p className="text-sm text-gray-600">AI 기반 콘텐츠 생성 플랫폼</p>
        </div>
        <SignUp appearance={clerkAppearance} />
      </div>
    </div>
  );
}
</file>

<file path="src/app/signup/page.tsx">
import { redirect } from "next/navigation";

export default function SignupPage() {
  redirect("/sign-up");
}
</file>

<file path="src/app/providers.tsx">
// In Next.js, this file would be called: app/providers.tsx
"use client";

// Since QueryClientProvider relies on useContext under the hood, we have to put 'use client' on top
import {
  isServer,
  QueryClient,
  QueryClientProvider,
} from "@tanstack/react-query";
import { ThemeProvider } from "next-themes";
import { Toaster } from "@/components/ui/sonner";

function makeQueryClient() {
  return new QueryClient({
    defaultOptions: {
      queries: {
        // With SSR, we usually want to set some default staleTime
        // above 0 to avoid refetching immediately on the client
        staleTime: 60 * 1000,
      },
    },
  });
}

let browserQueryClient: QueryClient | undefined = undefined;

function getQueryClient() {
  if (isServer) {
    // Server: always make a new query client
    return makeQueryClient();
  } else {
    // Browser: make a new query client if we don't already have one
    // This is very important, so we don't re-make a new client if React
    // suspends during the initial render. This may not be needed if we
    // have a suspense boundary BELOW the creation of the query client
    if (!browserQueryClient) browserQueryClient = makeQueryClient();
    return browserQueryClient;
  }
}

export default function Providers({ children }: { children: React.ReactNode }) {
  // NOTE: Avoid useState when initializing the query client if you don't
  //       have a suspense boundary between this and the code that may
  //       suspend because React will throw away the client on the initial
  //       render if it suspends and there is no boundary
  const queryClient = getQueryClient();

  return (
    <ThemeProvider
      attribute="class"
      defaultTheme="system"
      enableSystem
      forcedTheme="light"
      disableTransitionOnChange
    >
      <QueryClientProvider client={queryClient}>
        {children}
        <Toaster />
      </QueryClientProvider>
    </ThemeProvider>
  );
}
</file>

<file path="src/backend/config/index.ts">
import { z } from 'zod';
import type { AppConfig } from '@/backend/hono/context';

const envSchema = z.object({
  SUPABASE_URL: z.string().url(),
  SUPABASE_SERVICE_ROLE_KEY: z.string().min(1),
  GOOGLE_GENERATIVE_AI_API_KEY: z.string().min(1),
});

let cachedConfig: AppConfig | null = null;

export const getAppConfig = (): AppConfig => {
  if (cachedConfig) {
    return cachedConfig;
  }

  const parsed = envSchema.safeParse({
    SUPABASE_URL: process.env.SUPABASE_URL,
    SUPABASE_SERVICE_ROLE_KEY: process.env.SUPABASE_SERVICE_ROLE_KEY,
    GOOGLE_GENERATIVE_AI_API_KEY: process.env.GOOGLE_GENERATIVE_AI_API_KEY,
  });

  if (!parsed.success) {
    const messages = parsed.error.issues
      .map((issue) => `${issue.path.join('.') || 'config'}: ${issue.message}`)
      .join('; ');
    throw new Error(`Invalid backend configuration: ${messages}`);
  }

  cachedConfig = {
    supabase: {
      url: parsed.data.SUPABASE_URL,
      serviceRoleKey: parsed.data.SUPABASE_SERVICE_ROLE_KEY,
    },
    google: {
      generativeAiApiKey: parsed.data.GOOGLE_GENERATIVE_AI_API_KEY,
    },
  } satisfies AppConfig;

  return cachedConfig;
};
</file>

<file path="src/backend/hono/context.ts">
import type { Context } from 'hono';
import type { SupabaseClient } from '@supabase/supabase-js';

export type AppLogger = Pick<Console, 'info' | 'error' | 'warn' | 'debug'>;

export type AppConfig = {
  supabase: {
    url: string;
    serviceRoleKey: string;
  };
  google: {
    generativeAiApiKey: string;
  };
};

export type AppVariables = {
  supabase: SupabaseClient;
  logger: AppLogger;
  config: AppConfig;
};

export type AppEnv = {
  Variables: AppVariables;
};

export type AppContext = Context<AppEnv>;

export const contextKeys = {
  supabase: 'supabase',
  logger: 'logger',
  config: 'config',
} as const satisfies Record<keyof AppVariables, keyof AppVariables>;

export const getSupabase = (c: AppContext) =>
  c.get(contextKeys.supabase) as SupabaseClient;

export const getLogger = (c: AppContext) =>
  c.get(contextKeys.logger) as AppLogger;

export const getConfig = (c: AppContext) =>
  c.get(contextKeys.config) as AppConfig;
</file>

<file path="src/components/layout/header.tsx">
"use client";

import { SignedIn, SignedOut, SignInButton, UserButton } from "@clerk/nextjs";
import { Logo } from "@/components/brand/logo";
import { Sidebar } from "./sidebar";
import { Button } from "@/components/ui/button";

export function Header() {
  return (
    <header className="flex h-16 items-center justify-between border-b border-gray-200 bg-white px-6">
      <div className="flex items-center gap-4">
        <div className="md:hidden">
          <Sidebar />
        </div>
        <div className="hidden md:block">
          <Logo />
        </div>
      </div>

      <div className="flex items-center gap-4">
        <SignedIn>
          <UserButton
            appearance={{
              elements: {
                avatarBox: "h-9 w-9",
                userButtonTrigger: "focus:shadow-none",
              },
            }}
            afterSignOutUrl="/sign-in"
          />
        </SignedIn>
        <SignedOut>
          <SignInButton mode="modal">
            <Button
              variant="default"
              className="h-10 bg-[#3BA2F8] hover:bg-[#2E91E5] px-6 font-semibold"
            >
              로그인
            </Button>
          </SignInButton>
        </SignedOut>
      </div>
    </header>
  );
}
</file>

<file path="src/constants/auth.ts">
import { match } from "ts-pattern";

const PUBLIC_PATHS = ["/", "/sign-in", "/sign-up"] as const;
const PUBLIC_PREFIXES = ["/_next", "/api", "/favicon", "/static", "/docs", "/images"] as const;

export const LOGIN_PATH = "/sign-in";
export const SIGNUP_PATH = "/sign-up";
export const AUTH_ENTRY_PATHS = [LOGIN_PATH, SIGNUP_PATH] as const;
export const isAuthEntryPath = (
  pathname: string
): pathname is (typeof AUTH_ENTRY_PATHS)[number] =>
  AUTH_ENTRY_PATHS.includes(pathname as (typeof AUTH_ENTRY_PATHS)[number]);

export const isAuthPublicPath = (pathname: string) => {
  const normalized = pathname.toLowerCase();

  return match(normalized)
    .when(
      (path) => PUBLIC_PATHS.some((publicPath) => publicPath === path),
      () => true
    )
    .when(
      (path) => PUBLIC_PREFIXES.some((prefix) => path.startsWith(prefix)),
      () => true
    )
    .otherwise(() => false);
};

export const shouldProtectPath = (pathname: string) => !isAuthPublicPath(pathname);
</file>

<file path="src/features/articles/backend/error.ts">
export const articleErrorCodes = {
  unauthorized: 'ARTICLE_UNAUTHORIZED',
  notFound: 'ARTICLE_NOT_FOUND',
  validationError: 'ARTICLE_VALIDATION_ERROR',
  createError: 'ARTICLE_CREATE_ERROR',
  updateError: 'ARTICLE_UPDATE_ERROR',
  deleteError: 'ARTICLE_DELETE_ERROR',
  fetchError: 'ARTICLE_FETCH_ERROR',
  quotaExceeded: 'QUOTA_EXCEEDED',
  aiGenerationFailed: 'AI_GENERATION_FAILED',
  styleGuideNotFound: 'STYLE_GUIDE_NOT_FOUND',
  quotaCheckFailed: 'QUOTA_CHECK_FAILED',
  quotaIncrementFailed: 'QUOTA_INCREMENT_FAILED',
} as const;

type ArticleErrorValue =
  (typeof articleErrorCodes)[keyof typeof articleErrorCodes];

export type ArticleServiceError = ArticleErrorValue;
</file>

<file path="src/features/articles/backend/route.ts">
import type { Hono } from 'hono';
import {
  failure,
  success,
  respond,
  type ErrorResult,
} from '@/backend/http/response';
import {
  getLogger,
  getSupabase,
  getConfig,
  type AppEnv,
} from '@/backend/hono/context';
import {
  CreateArticleRequestSchema,
  UpdateArticleRequestSchema,
  GenerateArticleRequestSchema,
} from '@/features/articles/backend/schema';
import {
  createArticle,
  getArticleById,
  updateArticle,
  deleteArticle,
} from './service';
import {
  articleErrorCodes,
  type ArticleServiceError,
} from './error';
import { generateArticleContent } from './ai-service';
import { checkQuota, incrementQuota } from './quota-service';
import { generateUniqueSlug } from '@/lib/slug';

export const registerArticlesRoutes = (app: Hono<AppEnv>) => {
  /**
   * POST /api/articles/draft
   * Creates a new article draft
   *
   * Request body: CreateArticleRequest
   * Headers: x-clerk-user-id (required)
   */
  app.post('/api/articles/draft', async (c) => {
    // Get userId from header (passed from server action)
    const userId = c.req.header('x-clerk-user-id');

    if (!userId) {
      return respond(
        c,
        failure(
          401,
          articleErrorCodes.unauthorized,
          'User ID is required. Please provide x-clerk-user-id header.',
        ),
      );
    }

    // Parse and validate request body
    const body = await c.req.json();
    const parsedBody = CreateArticleRequestSchema.safeParse(body);

    if (!parsedBody.success) {
      return respond(
        c,
        failure(
          400,
          articleErrorCodes.validationError,
          'Invalid request body. Please check your input.',
          parsedBody.error.format(),
        ),
      );
    }

    const supabase = getSupabase(c);
    const logger = getLogger(c);

    // Create article draft
    const result = await createArticle(supabase, userId, parsedBody.data);

    if (!result.ok) {
      const errorResult = result as ErrorResult<ArticleServiceError, unknown>;
      logger.error('Failed to create article draft', errorResult.error.message);
      return respond(c, result);
    }

    logger.info('Article draft created successfully', { userId, articleId: result.data.id });
    return respond(c, result);
  });

  /**
   * GET /api/articles/:id
   * Gets an article by ID
   *
   * URL params: id (article UUID)
   * Headers: x-clerk-user-id (required)
   */
  app.get('/api/articles/:id', async (c) => {
    // Get userId from header
    const userId = c.req.header('x-clerk-user-id');

    if (!userId) {
      return respond(
        c,
        failure(
          401,
          articleErrorCodes.unauthorized,
          'User ID is required. Please provide x-clerk-user-id header.',
        ),
      );
    }

    const articleId = c.req.param('id');

    if (!articleId) {
      return respond(
        c,
        failure(
          400,
          articleErrorCodes.validationError,
          'Article ID is required.',
        ),
      );
    }

    const supabase = getSupabase(c);
    const logger = getLogger(c);

    // Get article
    const result = await getArticleById(supabase, userId, articleId);

    if (!result.ok) {
      const errorResult = result as ErrorResult<ArticleServiceError, unknown>;
      logger.error('Failed to get article', errorResult.error.message);
      return respond(c, result);
    }

    logger.info('Article retrieved successfully', { userId, articleId });
    return respond(c, result);
  });

  /**
   * PATCH /api/articles/:id
   * Updates an article
   *
   * URL params: id (article UUID)
   * Request body: UpdateArticleRequest
   * Headers: x-clerk-user-id (required)
   */
  app.patch('/api/articles/:id', async (c) => {
    // Get userId from header
    const userId = c.req.header('x-clerk-user-id');

    if (!userId) {
      return respond(
        c,
        failure(
          401,
          articleErrorCodes.unauthorized,
          'User ID is required. Please provide x-clerk-user-id header.',
        ),
      );
    }

    const articleId = c.req.param('id');

    if (!articleId) {
      return respond(
        c,
        failure(
          400,
          articleErrorCodes.validationError,
          'Article ID is required.',
        ),
      );
    }

    // Parse and validate request body
    const body = await c.req.json();
    const parsedBody = UpdateArticleRequestSchema.safeParse(body);

    if (!parsedBody.success) {
      return respond(
        c,
        failure(
          400,
          articleErrorCodes.validationError,
          'Invalid request body. Please check your input.',
          parsedBody.error.format(),
        ),
      );
    }

    const supabase = getSupabase(c);
    const logger = getLogger(c);

    // Update article
    const result = await updateArticle(
      supabase,
      userId,
      articleId,
      parsedBody.data,
    );

    if (!result.ok) {
      const errorResult = result as ErrorResult<ArticleServiceError, unknown>;
      logger.error('Failed to update article', errorResult.error.message);
      return respond(c, result);
    }

    logger.info('Article updated successfully', { userId, articleId });
    return respond(c, result);
  });

  /**
   * DELETE /api/articles/:id
   * Deletes an article
   *
   * URL params: id (article UUID)
   * Headers: x-clerk-user-id (required)
   */
  app.delete('/api/articles/:id', async (c) => {
    // Get userId from header
    const userId = c.req.header('x-clerk-user-id');

    if (!userId) {
      return respond(
        c,
        failure(
          401,
          articleErrorCodes.unauthorized,
          'User ID is required. Please provide x-clerk-user-id header.',
        ),
      );
    }

    const articleId = c.req.param('id');

    if (!articleId) {
      return respond(
        c,
        failure(
          400,
          articleErrorCodes.validationError,
          'Article ID is required.',
        ),
      );
    }

    const supabase = getSupabase(c);
    const logger = getLogger(c);

    // Delete article
    const result = await deleteArticle(supabase, userId, articleId);

    if (!result.ok) {
      const errorResult = result as ErrorResult<ArticleServiceError, unknown>;
      logger.error('Failed to delete article', errorResult.error.message);
      return respond(c, result);
    }

    logger.info('Article deleted successfully', { userId, articleId });
    return respond(c, result);
  });

  /**
   * POST /api/articles/generate
   * Generates a new article using AI (Google Gemini)
   *
   * Request body: GenerateArticleRequest
   * Headers: x-clerk-user-id (required)
   */
  app.post('/api/articles/generate', async (c) => {
    // Get userId from header
    const userId = c.req.header('x-clerk-user-id');

    if (!userId) {
      return respond(
        c,
        failure(
          401,
          articleErrorCodes.unauthorized,
          'User ID is required. Please provide x-clerk-user-id header.',
        ),
      );
    }

    // Parse and validate request body
    const body = await c.req.json();
    const parsedBody = GenerateArticleRequestSchema.safeParse(body);

    if (!parsedBody.success) {
      return respond(
        c,
        failure(
          400,
          articleErrorCodes.validationError,
          'Invalid request body. Please check your input.',
          parsedBody.error.format(),
        ),
      );
    }

    const supabase = getSupabase(c);
    const logger = getLogger(c);
    const config = getConfig(c);

    // Step 1: Check quota
    const quotaCheckResult = await checkQuota(supabase, userId);

    if (!quotaCheckResult.ok) {
      const errorResult = quotaCheckResult as ErrorResult<ArticleServiceError, unknown>;
      logger.error('Quota check failed', errorResult.error.message);
      return respond(c, quotaCheckResult);
    }

    if (!quotaCheckResult.data.allowed) {
      return respond(
        c,
        failure(
          429,
          articleErrorCodes.quotaExceeded,
          `Generation quota exceeded. You have used ${quotaCheckResult.data.currentCount}/${quotaCheckResult.data.limit} generations.`,
          {
            tier: quotaCheckResult.data.tier,
            currentCount: quotaCheckResult.data.currentCount,
            limit: quotaCheckResult.data.limit,
          },
        ),
      );
    }

    // Step 2: Generate article content using AI
    const generationResult = await generateArticleContent(
      supabase,
      userId,
      config.google.generativeAiApiKey,
      parsedBody.data,
    );

    if (!generationResult.ok) {
      const errorResult = generationResult as ErrorResult<ArticleServiceError, unknown>;
      logger.error('AI generation failed', errorResult.error.message);
      return respond(c, generationResult);
    }

    const generatedContent = generationResult.data;

    // Step 3: Create article in database
    const slug = generateUniqueSlug(generatedContent.title);

    const createArticleData = {
      title: generatedContent.title,
      slug,
      keywords: generatedContent.keywords,
      description: generatedContent.metaDescription,
      content: generatedContent.content,
      styleGuideId: parsedBody.data.styleGuideId,
      metaTitle: generatedContent.title,
      metaDescription: generatedContent.metaDescription,
    };

    const articleResult = await createArticle(supabase, userId, createArticleData);

    if (!articleResult.ok) {
      const errorResult = articleResult as ErrorResult<ArticleServiceError, unknown>;
      logger.error('Failed to save generated article', errorResult.error.message);
      return respond(c, articleResult);
    }

    // Step 4: Increment quota
    const incrementResult = await incrementQuota(supabase, userId);

    if (!incrementResult.ok) {
      const errorResult = incrementResult as ErrorResult<ArticleServiceError, unknown>;
      logger.warn('Failed to increment quota after article creation', errorResult.error.message);
      // Continue anyway since article was created successfully
    }

    const quotaRemaining = incrementResult.ok
      ? incrementResult.data.remaining
      : quotaCheckResult.data.remaining - 1;

    logger.info('Article generated successfully', {
      userId,
      articleId: articleResult.data.id,
      quotaRemaining,
    });

    // Return response
    return respond(
      c,
      success(
        {
          article: articleResult.data,
          generatedContent,
          quotaRemaining,
        },
        201,
      ),
    );
  });
};
</file>

<file path="src/features/articles/backend/schema.ts">
import { z } from 'zod';

// Article status enum
export const ArticleStatusSchema = z.enum(['draft', 'published', 'archived']);

// Reuse enums from style_guides (defined in onboarding schema)
export const ContentToneSchema = z.enum([
  'professional',
  'friendly',
  'inspirational',
  'educational',
]);

export const ContentLengthSchema = z.enum(['short', 'medium', 'long']);

export const ReadingLevelSchema = z.enum([
  'beginner',
  'intermediate',
  'advanced',
]);

// Create Article Request Schema
export const CreateArticleRequestSchema = z.object({
  title: z
    .string()
    .min(1, '제목을 입력해주세요')
    .max(200, '제목은 200자 이내로 입력해주세요'),
  slug: z
    .string()
    .min(1, 'URL 슬러그를 입력해주세요')
    .max(200, '슬러그는 200자 이내로 입력해주세요')
    .regex(
      /^[a-z0-9]+(?:-[a-z0-9]+)*$/,
      '슬러그는 소문자, 숫자, 하이픈(-)만 사용 가능합니다',
    ),
  keywords: z.array(z.string()).default([]),
  description: z.string().max(500, '설명은 500자 이내로 입력해주세요').optional(),
  content: z.string().min(1, '내용을 입력해주세요'),
  styleGuideId: z.string().uuid('유효하지 않은 스타일 가이드 ID입니다').optional(),
  tone: ContentToneSchema.optional(),
  contentLength: ContentLengthSchema.optional(),
  readingLevel: ReadingLevelSchema.optional(),
  metaTitle: z.string().max(60, 'Meta 제목은 60자 이내로 입력해주세요').optional(),
  metaDescription: z
    .string()
    .max(160, 'Meta 설명은 160자 이내로 입력해주세요')
    .optional(),
});

export type CreateArticleRequest = z.infer<typeof CreateArticleRequestSchema>;

// Update Article Request Schema
export const UpdateArticleRequestSchema = z.object({
  title: z
    .string()
    .min(1, '제목을 입력해주세요')
    .max(200, '제목은 200자 이내로 입력해주세요')
    .optional(),
  slug: z
    .string()
    .min(1, 'URL 슬러그를 입력해주세요')
    .max(200, '슬러그는 200자 이내로 입력해주세요')
    .regex(
      /^[a-z0-9]+(?:-[a-z0-9]+)*$/,
      '슬러그는 소문자, 숫자, 하이픈(-)만 사용 가능합니다',
    )
    .optional(),
  keywords: z.array(z.string()).optional(),
  description: z.string().max(500, '설명은 500자 이내로 입력해주세요').optional(),
  content: z.string().min(1, '내용을 입력해주세요').optional(),
  styleGuideId: z.string().uuid('유효하지 않은 스타일 가이드 ID입니다').optional(),
  tone: ContentToneSchema.optional(),
  contentLength: ContentLengthSchema.optional(),
  readingLevel: ReadingLevelSchema.optional(),
  metaTitle: z.string().max(60, 'Meta 제목은 60자 이내로 입력해주세요').optional(),
  metaDescription: z
    .string()
    .max(160, 'Meta 설명은 160자 이내로 입력해주세요')
    .optional(),
  status: ArticleStatusSchema.optional(),
});

export type UpdateArticleRequest = z.infer<typeof UpdateArticleRequestSchema>;

// Database row schema (snake_case to match database columns)
export const ArticleTableRowSchema = z.object({
  id: z.string().uuid(),
  clerk_user_id: z.string(),
  title: z.string(),
  slug: z.string(),
  keywords: z.array(z.string()),
  description: z.string().nullable(),
  content: z.string(),
  style_guide_id: z.string().uuid().nullable(),
  tone: ContentToneSchema.nullable(),
  content_length: ContentLengthSchema.nullable(),
  reading_level: ReadingLevelSchema.nullable(),
  meta_title: z.string().nullable(),
  meta_description: z.string().nullable(),
  status: ArticleStatusSchema,
  published_at: z.string().nullable(),
  created_at: z.string(),
  updated_at: z.string(),
});

export type ArticleRow = z.infer<typeof ArticleTableRowSchema>;

// Response schema (camelCase for API responses)
export const ArticleResponseSchema = z.object({
  id: z.string().uuid(),
  clerkUserId: z.string(),
  title: z.string(),
  slug: z.string(),
  keywords: z.array(z.string()),
  description: z.string().nullable(),
  content: z.string(),
  styleGuideId: z.string().uuid().nullable(),
  tone: ContentToneSchema.nullable(),
  contentLength: ContentLengthSchema.nullable(),
  readingLevel: ReadingLevelSchema.nullable(),
  metaTitle: z.string().nullable(),
  metaDescription: z.string().nullable(),
  status: ArticleStatusSchema,
  publishedAt: z.string().nullable(),
  createdAt: z.string(),
  updatedAt: z.string(),
});

export type ArticleResponse = z.infer<typeof ArticleResponseSchema>;

// Generate Article Request Schema
export const GenerateArticleRequestSchema = z.object({
  topic: z
    .string()
    .min(1, '주제를 입력해주세요')
    .max(200, '주제는 200자 이내로 입력해주세요'),
  styleGuideId: z
    .string()
    .uuid('유효하지 않은 스타일 가이드 ID입니다')
    .optional(),
  keywords: z.array(z.string()).optional().default([]),
  additionalInstructions: z
    .string()
    .max(1000, '추가 지시사항은 1000자 이내로 입력해주세요')
    .optional(),
});

export type GenerateArticleRequest = z.infer<typeof GenerateArticleRequestSchema>;

// AI Generated Content Schema (from Gemini)
export const AIGeneratedContentSchema = z.object({
  title: z.string(),
  content: z.string(),
  metaDescription: z.string(),
  keywords: z.array(z.string()),
  headings: z.array(z.string()),
});

export type AIGeneratedContent = z.infer<typeof AIGeneratedContentSchema>;

// Generate Article Response Schema
export const GenerateArticleResponseSchema = z.object({
  article: ArticleResponseSchema,
  generatedContent: AIGeneratedContentSchema,
  quotaRemaining: z.number(),
});

export type GenerateArticleResponse = z.infer<typeof GenerateArticleResponseSchema>;
</file>

<file path="src/features/articles/hooks/useGenerateArticle.ts">
'use client';

import { useState, useCallback } from 'react';
import { useQueryClient } from '@tanstack/react-query';
import type { GenerateArticleRequest } from '../lib/dto';

export const useGenerateArticle = () => {
  const queryClient = useQueryClient();
  const [completion, setCompletion] = useState('');
  const [isLoading, setIsLoading] = useState(false);
  const [error, setError] = useState<Error | null>(null);

  const generateArticle = useCallback(
    async (request: GenerateArticleRequest) => {
      setIsLoading(true);
      setError(null);
      setCompletion('');

      try {
        // Call the API with direct request body
        const response = await fetch('/api/articles/generate', {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json',
          },
          body: JSON.stringify(request),
        });

        if (!response.ok) {
          const errorData = await response.json().catch(() => ({}));
          throw new Error(
            errorData.error?.message || 'Failed to generate article'
          );
        }

        // Read the streaming response
        const reader = response.body?.getReader();
        if (!reader) throw new Error('No response body');

        const decoder = new TextDecoder();
        let buffer = '';
        let fullText = '';

        while (true) {
          const { done, value } = await reader.read();
          if (done) break;

          buffer += decoder.decode(value, { stream: true });
          const lines = buffer.split('\n');

          // Process complete lines
          for (let i = 0; i < lines.length - 1; i++) {
            const line = lines[i].trim();
            if (line.startsWith('0:"')) {
              // Parse streaming text chunks from Vercel AI SDK format
              const content = line.slice(2, -1); // Remove 0:" and trailing "
              fullText += content;
              setCompletion(fullText);
            }
          }

          // Keep incomplete line in buffer
          buffer = lines[lines.length - 1];
        }

        // Add final buffer if exists
        if (buffer.trim().startsWith('0:"')) {
          const content = buffer.trim().slice(2, -1);
          fullText += content;
          setCompletion(fullText);
        }

        // Invalidate queries
        queryClient.invalidateQueries({ queryKey: ['articles'] });
      } catch (err) {
        const error = err instanceof Error ? err : new Error('Unknown error');
        setError(error);
        throw error;
      } finally {
        setIsLoading(false);
      }
    },
    [queryClient]
  );

  return {
    generateArticle,
    completion,
    isLoading,
    error,
  };
};
</file>

<file path="src/features/articles/lib/dto.ts">
// Re-export backend schemas for use in frontend (React Query hooks, etc.)
export {
  CreateArticleRequestSchema,
  UpdateArticleRequestSchema,
  ArticleResponseSchema,
  ArticleStatusSchema,
  ContentToneSchema,
  ContentLengthSchema,
  ReadingLevelSchema,
  GenerateArticleRequestSchema,
  GenerateArticleResponseSchema,
  AIGeneratedContentSchema,
  type CreateArticleRequest,
  type UpdateArticleRequest,
  type ArticleResponse,
  type GenerateArticleRequest,
  type GenerateArticleResponse,
  type AIGeneratedContent,
} from '@/features/articles/backend/schema';
</file>

<file path="src/features/articles/lib/markdown-utils.ts">
export interface Heading {
  level: number;
  text: string;
  id: string;
}

export function extractHeadings(markdown: string): Heading[] {
  const headingRegex = /^(#{1,6})\s+(.+)$/gm;
  const headings: Heading[] = [];
  let match;

  while ((match = headingRegex.exec(markdown)) !== null) {
    const level = match[1].length;
    const text = match[2].trim();
    const id = text
      .toLowerCase()
      .replace(/[^a-z0-9가-힣]+/g, '-')
      .replace(/^-+|-+$/g, '');
    headings.push({ level, text, id });
  }

  return headings;
}

/**
 * 마크다운을 .md 파일로 다운로드
 */
export function downloadMarkdown(filename: string, content: string): void {
  const blob = new Blob([content], { type: 'text/markdown;charset=utf-8;' });
  const link = document.createElement('a');
  const url = URL.createObjectURL(blob);

  link.setAttribute('href', url);
  link.setAttribute('download', `${filename}.md`);
  link.style.visibility = 'hidden';

  document.body.appendChild(link);
  link.click();
  document.body.removeChild(link);

  URL.revokeObjectURL(url);
}

/**
 * 마크다운을 클립보드에 복사
 */
export async function copyToClipboard(content: string): Promise<void> {
  if (navigator?.clipboard?.writeText) {
    await navigator.clipboard.writeText(content);
  } else {
    // Fallback for older browsers
    const textArea = document.createElement('textarea');
    textArea.value = content;
    textArea.style.position = 'fixed';
    textArea.style.left = '-999999px';
    document.body.appendChild(textArea);
    textArea.focus();
    textArea.select();

    try {
      document.execCommand('copy');
    } finally {
      document.body.removeChild(textArea);
    }
  }
}
</file>

<file path="src/features/auth/context/current-user-context.tsx">
"use client";

import {
  createContext,
  useCallback,
  useContext,
  useMemo,
  useState,
  type ReactNode,
} from "react";
import { useQueryClient } from "@tanstack/react-query";
import { useUser } from "@clerk/nextjs";
import type {
  CurrentUserContextValue,
  CurrentUserSnapshot,
} from "../types";

const CurrentUserContext = createContext<CurrentUserContextValue | null>(null);

type CurrentUserProviderProps = {
  children: ReactNode;
  initialState: CurrentUserSnapshot;
};

export const CurrentUserProvider = ({
  children,
  initialState,
}: CurrentUserProviderProps) => {
  const queryClient = useQueryClient();
  const { user: clerkUser, isLoaded } = useUser();
  const [snapshot, setSnapshot] = useState<CurrentUserSnapshot>(initialState);

  const refresh = useCallback(async () => {
    if (!isLoaded) return;

    const nextSnapshot: CurrentUserSnapshot = clerkUser
      ? {
          status: "authenticated",
          user: {
            id: clerkUser.id,
            email: clerkUser.emailAddresses[0]?.emailAddress ?? null,
            appMetadata: {},
            userMetadata: {},
          },
        }
      : { status: "unauthenticated", user: null };

    setSnapshot(nextSnapshot);
    queryClient.setQueryData(["currentUser"], nextSnapshot);
  }, [clerkUser, isLoaded, queryClient]);

  const value = useMemo<CurrentUserContextValue>(() => {
    const currentSnapshot: CurrentUserSnapshot = clerkUser
      ? {
          status: "authenticated",
          user: {
            id: clerkUser.id,
            email: clerkUser.emailAddresses[0]?.emailAddress ?? null,
            appMetadata: {},
            userMetadata: {},
          },
        }
      : isLoaded
        ? { status: "unauthenticated", user: null }
        : snapshot;

    return {
      ...currentSnapshot,
      refresh,
      isAuthenticated: currentSnapshot.status === "authenticated",
      isLoading: !isLoaded,
    };
  }, [clerkUser, isLoaded, refresh, snapshot]);

  return (
    <CurrentUserContext.Provider value={value}>
      {children}
    </CurrentUserContext.Provider>
  );
};

export const useCurrentUserContext = () => {
  const value = useContext(CurrentUserContext);

  if (!value) {
    throw new Error("CurrentUserProvider가 트리 상단에 필요합니다.");
  }

  return value;
};
</file>

<file path="src/features/onboarding/backend/error.ts">
export const styleGuideErrorCodes = {
  unauthorized: 'STYLE_GUIDE_UNAUTHORIZED',
  notFound: 'STYLE_GUIDE_NOT_FOUND',
  createError: 'STYLE_GUIDE_CREATE_ERROR',
  validationError: 'STYLE_GUIDE_VALIDATION_ERROR',
  upsertError: 'STYLE_GUIDE_UPSERT_ERROR',
  fetchError: 'STYLE_GUIDE_FETCH_ERROR',
} as const;

type StyleGuideErrorValue = (typeof styleGuideErrorCodes)[keyof typeof styleGuideErrorCodes];

export type StyleGuideServiceError = StyleGuideErrorValue;
</file>

<file path="src/features/onboarding/components/onboarding-wizard.tsx">
"use client";

import { useState, useEffect, useCallback } from "react";
import { useForm } from "react-hook-form";
import { zodResolver } from "@hookform/resolvers/zod";
import { Form } from "@/components/ui/form";
import { Button } from "@/components/ui/button";
import {
  Accordion,
  AccordionContent,
  AccordionItem,
  AccordionTrigger,
} from "@/components/ui/accordion";
import { ChevronLeft, ChevronRight } from "lucide-react";
import { StepIndicator } from "./step-indicator";
import { PreviewPanel } from "./preview-panel";
import { StepBrandVoice } from "./step-brand-voice";
import { StepAudience } from "./step-audience";
import { StepLanguage } from "./step-language";
import { StepStyle } from "./step-style";
import { StepReview } from "./step-review";
import {
  onboardingSchema,
  brandVoiceSchema,
  targetAudienceSchema,
  languageSchema,
  styleSchema,
  reviewSchema,
  defaultOnboardingValues,
  type OnboardingFormData,
} from "../lib/onboarding-schema";
import { TOTAL_STEPS } from "../lib/constants";

interface OnboardingWizardProps {
  onComplete: (data: OnboardingFormData) => Promise<void>;
}

export function OnboardingWizard({ onComplete }: OnboardingWizardProps) {
  const [currentStep, setCurrentStep] = useState(1);
  const [isSubmitting, setIsSubmitting] = useState(false);

  const form = useForm<OnboardingFormData>({
    resolver: zodResolver(onboardingSchema),
    defaultValues: defaultOnboardingValues,
    mode: "onChange",
  });

  // Get step-specific schema for validation
  const getStepSchema = (step: number) => {
    switch (step) {
      case 1:
        return brandVoiceSchema;
      case 2:
        return targetAudienceSchema;
      case 3:
        return languageSchema;
      case 4:
        return styleSchema;
      case 5:
        return reviewSchema;
      default:
        return onboardingSchema;
    }
  };

  // Validate current step before proceeding
  const validateCurrentStep = useCallback(async () => {
    const stepSchema = getStepSchema(currentStep);
    const values = form.getValues();

    try {
      await stepSchema.parseAsync(values);
      return true;
    } catch (error) {
      // Trigger validation to show errors
      await form.trigger();
      return false;
    }
  }, [currentStep, form]);

  const handleNext = useCallback(async () => {
    const isValid = await validateCurrentStep();

    if (isValid && currentStep < TOTAL_STEPS) {
      setCurrentStep((prev) => prev + 1);
      // Focus on the top of the form
      window.scrollTo({ top: 0, behavior: "smooth" });

      // Announce step change for screen readers
      const announcement = `Step ${currentStep + 1} of ${TOTAL_STEPS}`;
      announceToScreenReader(announcement);
    }
  }, [currentStep, validateCurrentStep]);

  const handlePrevious = useCallback(() => {
    if (currentStep > 1) {
      setCurrentStep((prev) => prev - 1);
      window.scrollTo({ top: 0, behavior: "smooth" });

      // Announce step change for screen readers
      const announcement = `Step ${currentStep - 1} of ${TOTAL_STEPS}`;
      announceToScreenReader(announcement);
    }
  }, [currentStep]);

  // Helper function to announce to screen readers
  const announceToScreenReader = (message: string) => {
    const announcement = document.createElement("div");
    announcement.setAttribute("role", "status");
    announcement.setAttribute("aria-live", "polite");
    announcement.className = "sr-only";
    announcement.textContent = message;
    document.body.appendChild(announcement);
    setTimeout(() => document.body.removeChild(announcement), 1000);
  };

  const handleSubmit = async (data: OnboardingFormData) => {
    setIsSubmitting(true);
    try {
      await onComplete(data);
    } catch (error) {
      console.error("Onboarding submission error:", error);
      setIsSubmitting(false);
    }
  };

  // Watch form values for preview
  const formValues = form.watch();

  // Keyboard navigation
  useEffect(() => {
    const handleKeyDown = (e: KeyboardEvent) => {
      // Don't handle if user is typing in an input
      if (
        e.target instanceof HTMLInputElement ||
        e.target instanceof HTMLTextAreaElement
      ) {
        return;
      }

      // Alt + Arrow Right: Next step
      if (e.altKey && e.key === "ArrowRight") {
        e.preventDefault();
        handleNext();
      }

      // Alt + Arrow Left: Previous step
      if (e.altKey && e.key === "ArrowLeft") {
        e.preventDefault();
        handlePrevious();
      }
    };

    window.addEventListener("keydown", handleKeyDown);
    return () => window.removeEventListener("keydown", handleKeyDown);
  }, [currentStep, handleNext, handlePrevious]);

  // Render current step component
  const renderStep = () => {
    switch (currentStep) {
      case 1:
        return <StepBrandVoice form={form} />;
      case 2:
        return <StepAudience form={form} />;
      case 3:
        return <StepLanguage form={form} />;
      case 4:
        return <StepStyle form={form} />;
      case 5:
        return <StepReview form={form} />;
      default:
        return null;
    }
  };

  return (
    <div
      className="min-h-screen py-8"
      style={{ backgroundColor: "#FCFCFD" }}
    >
      <div className="container mx-auto max-w-7xl px-4">
        {/* Step Indicator */}
        <div className="mb-8">
          <StepIndicator currentStep={currentStep} />

          {/* Keyboard shortcut hint */}
          <div className="mt-2 text-center">
            <p className="text-xs" style={{ color: "#9CA3AF" }}>
              <kbd className="rounded px-1.5 py-0.5" style={{ backgroundColor: "#F3F4F6", color: "#6B7280", border: "1px solid #E5E7EB" }}>
                Alt
              </kbd>
              {" + "}
              <kbd className="rounded px-1.5 py-0.5" style={{ backgroundColor: "#F3F4F6", color: "#6B7280", border: "1px solid #E5E7EB" }}>
                ← / →
              </kbd>
              {" "}
              키로 이동 가능
            </p>
          </div>
        </div>

        <Form {...form}>
          <form
            onSubmit={(e) => {
              // Prevent default form submission - we handle it manually
              e.preventDefault();
            }}
            onKeyDown={(e) => {
              // Prevent Enter key from submitting the form
              if (e.key === "Enter" && e.target instanceof HTMLElement) {
                // Allow Enter in textarea for new lines
                if (e.target.tagName !== "TEXTAREA") {
                  e.preventDefault();
                }
              }
            }}
          >
            {/* Desktop: 2-column layout */}
            <div className="hidden lg:grid lg:grid-cols-[1fr,400px] lg:gap-8">
              {/* Left: Form */}
              <div
                className="rounded-lg border p-6"
                style={{
                  backgroundColor: "#FFFFFF",
                  borderColor: "#E1E5EA",
                  borderRadius: "12px",
                }}
              >
                {renderStep()}

                {/* Navigation Buttons */}
                <div className="mt-8 flex items-center justify-between border-t pt-6">
                  <Button
                    type="button"
                    variant="outline"
                    onClick={handlePrevious}
                    disabled={currentStep === 1}
                    className="h-10"
                    style={{
                      borderColor: "#E1E5EA",
                      borderRadius: "8px",
                    }}
                  >
                    <ChevronLeft className="mr-2 h-4 w-4" />
                    이전
                  </Button>

                  {currentStep < TOTAL_STEPS ? (
                    <Button
                      type="button"
                      onClick={handleNext}
                      className="h-10"
                      style={{
                        backgroundColor: "#3BA2F8",
                        borderRadius: "8px",
                      }}
                    >
                      다음
                      <ChevronRight className="ml-2 h-4 w-4" />
                    </Button>
                  ) : (
                    <Button
                      type="button"
                      onClick={async () => {
                        const isValid = await validateCurrentStep();
                        if (isValid) {
                          const formData = form.getValues();
                          await handleSubmit(formData);
                        }
                      }}
                      disabled={isSubmitting}
                      className="h-10"
                      style={{
                        backgroundColor: "#10B981",
                        borderRadius: "8px",
                      }}
                    >
                      {isSubmitting ? "처리 중..." : "완료"}
                    </Button>
                  )}
                </div>
              </div>

              {/* Right: Preview Panel (sticky) */}
              <div>
                <PreviewPanel formData={formValues} />
              </div>
            </div>

            {/* Mobile/Tablet: Single column with accordion preview */}
            <div className="lg:hidden">
              <div
                className="rounded-lg border p-6"
                style={{
                  backgroundColor: "#FFFFFF",
                  borderColor: "#E1E5EA",
                  borderRadius: "12px",
                }}
              >
                {renderStep()}

                {/* Mobile Preview - Accordion */}
                <div className="mt-6">
                  <Accordion type="single" collapsible>
                    <AccordionItem
                      value="preview"
                      style={{ borderColor: "#E1E5EA" }}
                    >
                      <AccordionTrigger
                        className="text-sm font-medium"
                        style={{ color: "#374151" }}
                      >
                        미리보기
                      </AccordionTrigger>
                      <AccordionContent>
                        <div className="pt-2">
                          <PreviewPanel formData={formValues} />
                        </div>
                      </AccordionContent>
                    </AccordionItem>
                  </Accordion>
                </div>

                {/* Navigation Buttons */}
                <div className="mt-8 flex items-center justify-between border-t pt-6">
                  <Button
                    type="button"
                    variant="outline"
                    onClick={handlePrevious}
                    disabled={currentStep === 1}
                    className="h-12 flex-1 sm:h-10 sm:flex-initial"
                    style={{
                      borderColor: "#E1E5EA",
                      borderRadius: "8px",
                    }}
                  >
                    <ChevronLeft className="mr-2 h-4 w-4" />
                    이전
                  </Button>

                  {currentStep < TOTAL_STEPS ? (
                    <Button
                      type="button"
                      onClick={handleNext}
                      className="ml-4 h-12 flex-1 sm:h-10 sm:flex-initial"
                      style={{
                        backgroundColor: "#3BA2F8",
                        borderRadius: "8px",
                      }}
                    >
                      다음
                      <ChevronRight className="ml-2 h-4 w-4" />
                    </Button>
                  ) : (
                    <Button
                      type="button"
                      onClick={async () => {
                        const isValid = await validateCurrentStep();
                        if (isValid) {
                          const formData = form.getValues();
                          await handleSubmit(formData);
                        }
                      }}
                      disabled={isSubmitting}
                      className="ml-4 h-12 flex-1 sm:h-10 sm:flex-initial"
                      style={{
                        backgroundColor: "#10B981",
                        borderRadius: "8px",
                      }}
                    >
                      {isSubmitting ? "처리 중..." : "완료"}
                    </Button>
                  )}
                </div>
              </div>
            </div>
          </form>
        </Form>
      </div>
    </div>
  );
}
</file>

<file path="src/features/onboarding/components/step-review.tsx">
"use client";

import { UseFormReturn } from "react-hook-form";
import {
  FormField,
  FormItem,
  FormLabel,
  FormControl,
  FormMessage,
  FormDescription,
} from "@/components/ui/form";
import { Textarea } from "@/components/ui/textarea";
import { OnboardingFormData } from "../lib/onboarding-schema";
import {
  PERSONALITY_OPTIONS,
  FORMALITY_OPTIONS,
  TONE_OPTIONS,
  CONTENT_LENGTH_OPTIONS,
  READING_LEVEL_OPTIONS,
} from "../lib/constants";

interface StepReviewProps {
  form: UseFormReturn<OnboardingFormData>;
}

export function StepReview({ form }: StepReviewProps) {
  const formValues = form.getValues();

  const getPersonalityLabels = () => {
    return formValues.personality
      .map(
        (p) =>
          PERSONALITY_OPTIONS.find((opt) => opt.value === p)?.label || p
      )
      .join(", ");
  };

  const getFormalityLabel = () => {
    return (
      FORMALITY_OPTIONS.find((opt) => opt.value === formValues.formality)
        ?.label || formValues.formality
    );
  };

  const getToneLabel = () => {
    return (
      TONE_OPTIONS.find((opt) => opt.value === formValues.tone)?.label ||
      formValues.tone
    );
  };

  const getLengthLabel = () => {
    return (
      CONTENT_LENGTH_OPTIONS.find(
        (opt) => opt.value === formValues.contentLength
      )?.label || formValues.contentLength
    );
  };

  const getLevelLabel = () => {
    return (
      READING_LEVEL_OPTIONS.find(
        (opt) => opt.value === formValues.readingLevel
      )?.label || formValues.readingLevel
    );
  };

  return (
    <div className="space-y-6">
      <div>
        <h2
          className="text-2xl font-semibold"
          style={{ color: "#111827" }}
        >
          최종 검토
        </h2>
        <p className="mt-2 text-sm" style={{ color: "#6B7280" }}>
          설정을 검토하고 완료해주세요
        </p>
      </div>

      {/* Summary Cards */}
      <div className="space-y-4">
        {/* Brand Voice Summary */}
        <div
          className="rounded-lg border p-4"
          style={{
            backgroundColor: "#FFFFFF",
            borderColor: "#E1E5EA",
          }}
        >
          <h3
            className="mb-3 font-semibold"
            style={{ color: "#111827" }}
          >
            브랜드 보이스
          </h3>
          <dl className="space-y-2">
            <div className="flex justify-between text-sm">
              <dt style={{ color: "#6B7280" }}>브랜드 이름</dt>
              <dd
                className="font-medium"
                style={{ color: "#111827" }}
              >
                {formValues.brandName}
              </dd>
            </div>
            <div className="text-sm">
              <dt className="mb-1" style={{ color: "#6B7280" }}>
                설명
              </dt>
              <dd style={{ color: "#111827" }}>
                {formValues.brandDescription}
              </dd>
            </div>
            <div className="flex justify-between text-sm">
              <dt style={{ color: "#6B7280" }}>성격</dt>
              <dd
                className="font-medium"
                style={{ color: "#111827" }}
              >
                {getPersonalityLabels()}
              </dd>
            </div>
            <div className="flex justify-between text-sm">
              <dt style={{ color: "#6B7280" }}>격식</dt>
              <dd
                className="font-medium"
                style={{ color: "#111827" }}
              >
                {getFormalityLabel()}
              </dd>
            </div>
          </dl>
        </div>

        {/* Audience Summary */}
        <div
          className="rounded-lg border p-4"
          style={{
            backgroundColor: "#FFFFFF",
            borderColor: "#E1E5EA",
          }}
        >
          <h3
            className="mb-3 font-semibold"
            style={{ color: "#111827" }}
          >
            타겟 독자
          </h3>
          <dl className="space-y-2">
            <div className="text-sm">
              <dt className="mb-1" style={{ color: "#6B7280" }}>
                타겟 독자
              </dt>
              <dd style={{ color: "#111827" }}>
                {formValues.targetAudience}
              </dd>
            </div>
            <div className="text-sm">
              <dt className="mb-1" style={{ color: "#6B7280" }}>
                해결하려는 문제
              </dt>
              <dd style={{ color: "#111827" }}>{formValues.painPoints}</dd>
            </div>
          </dl>
        </div>

        {/* Settings Summary */}
        <div
          className="rounded-lg border p-4"
          style={{
            backgroundColor: "#FFFFFF",
            borderColor: "#E1E5EA",
          }}
        >
          <h3
            className="mb-3 font-semibold"
            style={{ color: "#111827" }}
          >
            콘텐츠 설정
          </h3>
          <dl className="space-y-2">
            <div className="flex justify-between text-sm">
              <dt style={{ color: "#6B7280" }}>언어</dt>
              <dd
                className="font-medium"
                style={{ color: "#111827" }}
              >
                {formValues.language === "ko" ? "한국어" : "English"}
              </dd>
            </div>
            <div className="flex justify-between text-sm">
              <dt style={{ color: "#6B7280" }}>톤</dt>
              <dd
                className="font-medium"
                style={{ color: "#111827" }}
              >
                {getToneLabel()}
              </dd>
            </div>
            <div className="flex justify-between text-sm">
              <dt style={{ color: "#6B7280" }}>길이</dt>
              <dd
                className="font-medium"
                style={{ color: "#111827" }}
              >
                {getLengthLabel()}
              </dd>
            </div>
            <div className="flex justify-between text-sm">
              <dt style={{ color: "#6B7280" }}>읽기 수준</dt>
              <dd
                className="font-medium"
                style={{ color: "#111827" }}
              >
                {getLevelLabel()}
              </dd>
            </div>
          </dl>
        </div>
      </div>

      {/* Optional Notes */}
      <FormField
        control={form.control}
        name="notes"
        render={({ field }) => (
          <FormItem>
            <FormLabel>추가 메모 (선택사항)</FormLabel>
            <FormControl>
              <Textarea
                placeholder="추가로 기억하고 싶은 내용이나 특별한 요구사항을 입력하세요"
                {...field}
                className="min-h-[100px] resize-y"
                style={{
                  borderColor: "#E1E5EA",
                  borderRadius: "6px",
                }}
              />
            </FormControl>
            <FormDescription>
              이 메모는 향후 참고용으로 저장됩니다
            </FormDescription>
            <FormMessage />
          </FormItem>
        )}
      />

      <div
        className="rounded-lg p-4"
        style={{
          backgroundColor: "#F0F9FF",
          borderLeft: "4px solid #3BA2F8",
        }}
      >
        <p className="text-sm font-medium" style={{ color: "#111827" }}>
          준비 완료!
        </p>
        <p className="mt-2 text-sm" style={{ color: "#374151" }}>
          모든 설정이 완료되었습니다. &ldquo;완료&rdquo; 버튼을 클릭하면 대시보드로
          이동하여 콘텐츠 생성을 시작할 수 있습니다.
        </p>
      </div>
    </div>
  );
}
</file>

<file path=".env.example">
# Supabase Configuration
NEXT_PUBLIC_SUPABASE_URL=your-supabase-url
NEXT_PUBLIC_SUPABASE_ANON_KEY=your-supabase-anon-key
SUPABASE_URL=your-supabase-url
SUPABASE_SERVICE_ROLE_KEY=your-supabase-service-role-key

# Google Generative AI Configuration
GOOGLE_GENERATIVE_AI_API_KEY=your-google-api-key
</file>

<file path=".gitignore">
# See https://help.github.com/articles/ignoring-files/ for more about ignoring files.

# dependencies
/node_modules
/.pnp
.pnp.*
.yarn/*
!.yarn/patches
!.yarn/plugins
!.yarn/releases
!.yarn/versions

# testing
/coverage
playwright-report
test-results

# next.js
/.next/
/out/

# production
/build

# misc
.DS_Store
*.pem

# debug
npm-debug.log*
yarn-debug.log*
yarn-error.log*
.pnpm-debug.log*

# env files (can opt-in for committing if needed)
.env*
!.env.example
!.env.test

# vercel
.vercel

# EasyNext
.easynext

# typescript
*.tsbuildinfo
next-env.d.ts


# START Ruler Generated Files
/.codex/config.toml
/.codex/config.toml.bak
/.cursor/rules/ruler_cursor_instructions.mdc
/.cursor/rules/ruler_cursor_instructions.mdc.bak
/AGENTS.md
/AGENTS.md.bak
/CLAUDE.md
/CLAUDE.md.bak
# END Ruler Generated Files
</file>

<file path="tailwind.config.ts">
import type { Config } from "tailwindcss";

const config: Config = {
  darkMode: "class",
  content: [
    "./src/pages/**/*.{js,ts,jsx,tsx,mdx}",
    "./src/components/**/*.{js,ts,jsx,tsx,mdx}",
    "./src/app/**/*.{js,ts,jsx,tsx,mdx}",
  ],
  theme: {
    extend: {
      colors: {
        primary: {
          DEFAULT: "hsl(var(--primary))",
          foreground: "hsl(var(--primary-foreground))",
        },
        secondary: {
          DEFAULT: "hsl(var(--secondary))",
          foreground: "hsl(var(--secondary-foreground))",
        },
        accent: {
          DEFAULT: "hsl(var(--accent))",
          foreground: "hsl(var(--accent-foreground))",
        },
        background: "hsl(var(--background))",
        foreground: "hsl(var(--foreground))",
        card: {
          DEFAULT: "hsl(var(--card))",
          foreground: "hsl(var(--card-foreground))",
        },
        muted: {
          DEFAULT: "hsl(var(--muted))",
          foreground: "hsl(var(--muted-foreground))",
        },
        border: "hsl(var(--border))",
        input: "hsl(var(--input))",
        ring: "hsl(var(--ring))",
        destructive: {
          DEFAULT: "hsl(var(--destructive))",
          foreground: "hsl(var(--destructive-foreground))",
        },
      },
      fontFamily: {
        sans: ["Pretendard Variable", "sans-serif"],
      },
      fontSize: {
        sm: "14px",
        base: "16px",
        lg: "18px",
        xl: "20px",
        "2xl": "24px",
        "3xl": "30px",
        "4xl": "36px",
      },
      borderRadius: {
        lg: "var(--radius)",
        md: "calc(var(--radius) - 2px)",
        sm: "calc(var(--radius) - 4px)",
      },
      keyframes: {
        "accordion-down": {
          from: { height: "0" },
          to: { height: "var(--radix-accordion-content-height)" },
        },
        "accordion-up": {
          from: { height: "var(--radix-accordion-content-height)" },
          to: { height: "0" },
        },
      },
      animation: {
        "accordion-down": "accordion-down 0.2s ease-out",
        "accordion-up": "accordion-up 0.2s ease-out",
      },
    },
  },
  plugins: [require("tailwindcss-animate")],
};

export default config;
</file>

<file path="src/app/auth/onboarding/page.tsx">
"use client";

import { toast } from "sonner";
import { OnboardingWizard } from "@/features/onboarding/components/onboarding-wizard";
import { completeOnboarding } from "@/features/onboarding/actions/complete-onboarding";
import { OnboardingFormData } from "@/features/onboarding/lib/onboarding-schema";

export default function OnboardingPage() {

  const handleComplete = async (data: OnboardingFormData) => {
    try {
      console.log("[ONBOARDING] Starting completion with data:", data);

      // Call server action
      const result = await completeOnboarding(data);

      console.log("[ONBOARDING] Server action result:", result);

      if (result.success) {
        console.log("[ONBOARDING] Success! Redirecting to dashboard with query params");
        // Navigate to dashboard with special query param to bypass middleware onboarding check
        // The middleware will allow access and then clean up the param on redirect
        // This works around Clerk's session caching delay
        const redirectUrl = "/dashboard?onboarding_completed=true&welcome=true";
        console.log("[ONBOARDING] Redirect URL:", redirectUrl);
        window.location.href = redirectUrl;
      } else {
        console.log("[ONBOARDING] Server action failed");
      }
    } catch (error) {
      console.error("[ONBOARDING] Error during completion:", error);
      // Show error message
      toast.error("오류가 발생했습니다", {
        description:
          error instanceof Error
            ? error.message
            : "온보딩 완료 중 문제가 발생했습니다",
      });
      throw error;
    }
  };

  return <OnboardingWizard onComplete={handleComplete} />;
}
</file>

<file path="src/app/globals.css">
@import "tailwindcss";

@plugin "@tailwindcss/typography";
@plugin "tailwindcss-animate";

@custom-variant dark (&:where(.dark, .dark *));

@utility container {
  margin-inline: auto;
  width: 100%;
  padding-inline: 2rem;
  @media (width >= 1400px) {
    max-width: 1400px;
  }
}

@theme {
  --color-border: hsl(var(--border));
  --color-input: hsl(var(--input));
  --color-ring: hsl(var(--ring));
  --color-background: hsl(var(--background));
  --color-foreground: hsl(var(--foreground));

  --color-primary: hsl(var(--primary));
  --color-primary-foreground: hsl(var(--primary-foreground));

  --color-secondary: hsl(var(--secondary));
  --color-secondary-foreground: hsl(var(--secondary-foreground));

  --color-destructive: hsl(var(--destructive));
  --color-destructive-foreground: hsl(var(--destructive-foreground));

  --color-muted: hsl(var(--muted));
  --color-muted-foreground: hsl(var(--muted-foreground));

  --color-accent: hsl(var(--accent));
  --color-accent-foreground: hsl(var(--accent-foreground));

  --color-popover: hsl(var(--popover));
  --color-popover-foreground: hsl(var(--popover-foreground));

  --color-card: hsl(var(--card));
  --color-card-foreground: hsl(var(--card-foreground));

  --radius-lg: var(--radius);
  --radius-md: calc(var(--radius) - 2px);
  --radius-sm: calc(var(--radius) - 4px);

  --animate-accordion-down: accordion-down 0.2s ease-out;
  --animate-accordion-up: accordion-up 0.2s ease-out;

  @keyframes accordion-down {
    from {
      height: 0;
    }
    to {
      height: var(--radix-accordion-content-height);
    }
  }
  @keyframes accordion-up {
    from {
      height: var(--radix-accordion-content-height);
    }
    to {
      height: 0;
    }
  }
}

/*
  The default border color has changed to `currentcolor` in Tailwind CSS v4,
  so we've added these compatibility styles to make sure everything still
  looks the same as it did with Tailwind CSS v3.

  If we ever want to remove these styles, we need to add an explicit border
  color utility to any element that depends on these defaults.
*/
@layer base {
  *,
  ::after,
  ::before,
  ::backdrop,
  ::file-selector-button {
    border-color: var(--color-gray-200, currentcolor);
  }
}

@layer base {
  :root {
    --background: 0 0% 100%;
    --foreground: 240 10% 3.9%;
    --card: 0 0% 100%;
    --card-foreground: 240 10% 3.9%;
    --popover: 0 0% 100%;
    --popover-foreground: 240 10% 3.9%;
    --primary: 240 5.9% 10%;
    --primary-foreground: 60 9.1% 97.8%;
    --secondary: 240 4.8% 95.9%;
    --secondary-foreground: 240 5.9% 10%;
    --muted: 240 4.8% 95.9%;
    --muted-foreground: 240 3.8% 46.1%;
    --accent: 240 4.8% 95.9%;
    --accent-foreground: 240 5.9% 10%;
    --destructive: 0 84.2% 60.2%;
    --destructive-foreground: 60 9.1% 97.8%;
    --border: 240 5.9% 90%;
    --input: 240 5.9% 90%;
    --ring: 240 10% 3.9%;
    --radius: 0.5rem;
    --chart-1: 12 76% 61%;
    --chart-2: 173 58% 39%;
    --chart-3: 197 37% 24%;
    --chart-4: 43 74% 66%;
    --chart-5: 27 87% 67%;
  }

  .dark {
    --background: 0 0% 3.9%;
    --foreground: 0 0% 98%;
    --card: 0 0% 3.9%;
    --card-foreground: 0 0% 98%;
    --popover: 0 0% 3.9%;
    --popover-foreground: 0 0% 98%;
    --primary: 0 0% 98%;
    --primary-foreground: 0 0% 9%;
    --secondary: 0 0% 14.9%;
    --secondary-foreground: 0 0% 98%;
    --muted: 0 0% 14.9%;
    --muted-foreground: 0 0% 63.9%;
    --accent: 0 0% 14.9%;
    --accent-foreground: 0 0% 98%;
    --destructive: 0 62.8% 30.6%;
    --destructive-foreground: 0 0% 98%;
    --border: 0 0% 14.9%;
    --input: 0 0% 14.9%;
    --ring: 0 0% 83.1%;
    --chart-1: 220 70% 50%;
    --chart-2: 160 60% 45%;
    --chart-3: 30 80% 55%;
    --chart-4: 280 65% 60%;
    --chart-5: 340 75% 55%;
  }
}

@layer base {
  * {
    @apply border-border;
  }
  body {
    @apply bg-background text-foreground;
  }
}

/* Screen reader only utility */
.sr-only {
  position: absolute;
  width: 1px;
  height: 1px;
  padding: 0;
  margin: -1px;
  overflow: hidden;
  clip: rect(0, 0, 0, 0);
  white-space: nowrap;
  border-width: 0;
}
</file>

<file path="src/backend/hono/app.ts">
import { Hono } from 'hono';
import { errorBoundary } from '@/backend/middleware/error';
import { withAppContext } from '@/backend/middleware/context';
import { withSupabase } from '@/backend/middleware/supabase';
import { registerExampleRoutes } from '@/features/example/backend/route';
import { registerOnboardingRoutes } from '@/features/onboarding/backend/route';
import { registerArticlesRoutes } from '@/features/articles/backend/route';
import type { AppEnv } from '@/backend/hono/context';

let singletonApp: Hono<AppEnv> | null = null;

export const createHonoApp = () => {
  // In development, always recreate the app to support HMR
  // In production, use singleton pattern for performance
  const isDevelopment = process.env.NODE_ENV === 'development';

  if (!isDevelopment && singletonApp) {
    return singletonApp;
  }

  const app = new Hono<AppEnv>();

  app.use('*', errorBoundary());
  app.use('*', withAppContext());
  app.use('*', withSupabase());

  registerExampleRoutes(app);
  registerOnboardingRoutes(app);
  registerArticlesRoutes(app);

  // Only cache in production
  if (!isDevelopment) {
    singletonApp = app;
  }

  return app;
};
</file>

<file path="src/features/auth/server/load-current-user.ts">
import "server-only";

import { currentUser } from "@clerk/nextjs/server";
import type { CurrentUserSnapshot } from "../types";

export const loadCurrentUser = async (): Promise<CurrentUserSnapshot> => {
  try {
    const user = await currentUser();

    if (user) {
      return {
        status: "authenticated",
        user: {
          id: user.id,
          email: user.emailAddresses[0]?.emailAddress ?? null,
          appMetadata: {},
          userMetadata: {},
        },
      };
    }

    return { status: "unauthenticated", user: null };
  } catch (error) {
    // If currentUser() fails (e.g., called outside clerkMiddleware scope),
    // treat as unauthenticated
    console.warn("Failed to load current user:", error);
    return { status: "unauthenticated", user: null };
  }
};
</file>

<file path="src/features/onboarding/actions/complete-onboarding.ts">
"use server";

import { auth, clerkClient } from "@clerk/nextjs/server";
import { revalidatePath } from "next/cache";
import { OnboardingFormData } from "../lib/onboarding-schema";

/**
 * Complete the onboarding process
 * Saves data to Supabase and updates Clerk metadata
 */
export async function completeOnboarding(data: OnboardingFormData) {
  try {
    console.log("[SERVER ACTION] Starting completeOnboarding");

    // Get authenticated user
    const { userId } = await auth();

    console.log("[SERVER ACTION] userId:", userId);

    if (!userId) {
      console.log("[SERVER ACTION] No userId, throwing Unauthorized error");
      throw new Error("Unauthorized");
    }

    // Save onboarding data to Supabase via Hono API
    const apiUrl = `${process.env.NEXT_PUBLIC_APP_URL}/api/style-guides`;
    console.log("[SERVER ACTION] Saving style guide to API:", apiUrl);

    const response = await fetch(apiUrl, {
      method: "POST",
      headers: {
        "Content-Type": "application/json",
        "x-clerk-user-id": userId,
      },
      body: JSON.stringify(data),
    });

    console.log("[SERVER ACTION] API response status:", response.status);

    if (!response.ok) {
      const errorData = await response.json().catch(() => ({}));
      console.error("[SERVER ACTION] Failed to save style guide:", errorData);
      throw new Error(
        errorData.error?.message || "스타일 가이드 저장에 실패했습니다"
      );
    }

    const savedData = await response.json();
    console.log("[SERVER ACTION] Style guide saved successfully:", savedData);

    // Update Clerk metadata only after successful Supabase save
    console.log("[SERVER ACTION] Updating Clerk metadata for user:", userId);
    const client = await clerkClient();
    await client.users.updateUser(userId, {
      publicMetadata: {
        onboardingCompleted: true,
      },
    });

    console.log("[SERVER ACTION] Clerk metadata updated successfully");

    // Also update the database to mark onboarding as completed
    // This ensures the middleware can check completion status from DB instead of relying on Clerk's session cache
    console.log("[SERVER ACTION] Updating database onboarding_completed status");
    const updateApiUrl = `${process.env.NEXT_PUBLIC_APP_URL}/api/onboarding/complete`;
    const updateResponse = await fetch(updateApiUrl, {
      method: "PATCH",
      headers: {
        "Content-Type": "application/json",
        "x-clerk-user-id": userId,
      },
      body: JSON.stringify({ onboarding_completed: true }),
    });

    if (!updateResponse.ok) {
      console.warn("[SERVER ACTION] Failed to update onboarding status in DB (non-critical)", updateResponse.status);
    } else {
      console.log("[SERVER ACTION] Database onboarding_completed status updated successfully");
    }

    console.log("[SERVER ACTION] Onboarding completed successfully for user:", userId);

    // Revalidate the dashboard path to ensure fresh middleware checks
    // This is safe because we're not on /auth/onboarding anymore when this runs
    console.log("[SERVER ACTION] Revalidating cache paths");
    revalidatePath("/dashboard", "page");
    revalidatePath("/", "layout");

    const result = { success: true, redirectUrl: "/dashboard?welcome=true" };
    console.log("[SERVER ACTION] Returning result:", result);
    return result;
  } catch (error) {
    console.error("[SERVER ACTION] Error completing onboarding:", error);
    throw new Error(
      error instanceof Error
        ? error.message
        : "온보딩 완료 중 오류가 발생했습니다"
    );
  }
}
</file>

<file path="src/app/(protected)/layout.tsx">
import { type ReactNode } from "react";
import { ClerkProvider } from "@clerk/nextjs";
import { Sidebar } from "@/components/layout/sidebar";
import { Header } from "@/components/layout/header";
import { loadCurrentUser } from "@/features/auth/server/load-current-user";
import { CurrentUserProvider } from "@/features/auth/context/current-user-context";

type ProtectedLayoutProps = {
  children: ReactNode;
};

/**
 * Protected Layout
 *
 * This layout wraps all authenticated routes with ClerkProvider and user context.
 *
 * Authentication and onboarding guards are handled by middleware.ts
 * This layout provides:
 * - ClerkProvider for authentication context
 * - CurrentUserProvider for user data
 * - UI structure for authenticated, onboarded users
 *
 * Middleware ensures:
 * - User is authenticated
 * - User has completed onboarding
 * - Unauthenticated users are redirected to /sign-in
 * - Users without onboarding are redirected to /auth/onboarding
 *
 * By placing ClerkProvider here instead of root layout:
 * - 404 pages and error routes work without Clerk context
 * - Static asset requests don't trigger Clerk middleware errors
 * - Clerk only runs on routes matched by clerkMiddleware()
 */
export default async function ProtectedLayout({
  children,
}: ProtectedLayoutProps) {
  const currentUser = await loadCurrentUser();

  return (
    <ClerkProvider>
      <CurrentUserProvider initialState={currentUser}>
        <div className="flex h-screen overflow-hidden">
          <Sidebar />
          <div className="flex flex-1 flex-col overflow-hidden">
            <Header />
            <main className="flex-1 overflow-y-auto bg-background p-8">
              {children}
            </main>
          </div>
        </div>
      </CurrentUserProvider>
    </ClerkProvider>
  );
}
</file>

<file path="src/app/layout.tsx">
import type { Metadata } from "next";
import "./globals.css";
import Providers from "./providers";

export const metadata: Metadata = {
  title: "콘텐츠메이커",
  description: "AI 기반 콘텐츠 생성 SaaS",
};

/**
 * Root Layout
 *
 * This layout provides the base HTML structure and global styles.
 * It does NOT include ClerkProvider or authentication logic.
 *
 * Authentication is handled in the (protected) sub-layout to ensure:
 * - 404 pages and error routes work without Clerk context
 * - Static asset requests don't trigger Clerk middleware errors
 * - Clerk only runs on authenticated routes matched by middleware
 */
export default function RootLayout({
  children,
}: Readonly<{
  children: React.ReactNode;
}>) {
  return (
    <html lang="ko" suppressHydrationWarning>
      <head>
        <link
          rel="stylesheet"
          as="style"
          crossOrigin="anonymous"
          href="https://cdn.jsdelivr.net/gh/orioncactus/pretendard@v1.3.9/dist/web/variable/pretendardvariable.min.css"
        />
      </head>
      <body className="antialiased font-sans">
        <Providers>{children}</Providers>
      </body>
    </html>
  );
}
</file>

<file path="src/features/articles/actions/article-actions.ts">
"use server";

import { auth } from "@clerk/nextjs/server";
import type {
  CreateArticleRequest,
  UpdateArticleRequest,
} from "../lib/dto";

const API_BASE_URL = process.env.NEXT_PUBLIC_APP_URL || "http://localhost:3000";

/**
 * Create a new article draft
 */
export async function createArticleDraft(data: CreateArticleRequest) {
  try {
    const { userId } = await auth();

    if (!userId) {
      throw new Error("Unauthorized");
    }

    const response = await fetch(`${API_BASE_URL}/api/articles/draft`, {
      method: "POST",
      headers: {
        "Content-Type": "application/json",
        "x-clerk-user-id": userId,
      },
      body: JSON.stringify(data),
    });

    if (!response.ok) {
      const errorData = await response.json().catch(() => ({}));
      console.error("Failed to create article draft:", errorData);
      throw new Error(
        errorData.error?.message || "글 작성에 실패했습니다"
      );
    }

    const result = await response.json();
    return result;
  } catch (error) {
    console.error("Error creating article draft:", error);
    throw new Error(
      error instanceof Error ? error.message : "글 작성 중 오류가 발생했습니다"
    );
  }
}

/**
 * Update an existing article draft
 */
export async function updateArticleDraft(
  articleId: string,
  data: UpdateArticleRequest
) {
  try {
    const { userId } = await auth();

    if (!userId) {
      throw new Error("Unauthorized");
    }

    const response = await fetch(`${API_BASE_URL}/api/articles/${articleId}`, {
      method: "PATCH",
      headers: {
        "Content-Type": "application/json",
        "x-clerk-user-id": userId,
      },
      body: JSON.stringify(data),
    });

    if (!response.ok) {
      const errorData = await response.json().catch(() => ({}));
      console.error("Failed to update article draft:", errorData);
      throw new Error(
        errorData.error?.message || "글 수정에 실패했습니다"
      );
    }

    const result = await response.json();
    return result;
  } catch (error) {
    console.error("Error updating article draft:", error);
    throw new Error(
      error instanceof Error ? error.message : "글 수정 중 오류가 발생했습니다"
    );
  }
}

/**
 * Get an article by ID
 */
export async function getArticle(articleId: string) {
  try {
    const { userId } = await auth();

    if (!userId) {
      throw new Error("Unauthorized");
    }

    const response = await fetch(`${API_BASE_URL}/api/articles/${articleId}`, {
      method: "GET",
      headers: {
        "x-clerk-user-id": userId,
      },
      cache: "no-store",
    });

    if (!response.ok) {
      const errorData = await response.json().catch(() => ({}));
      console.error("Failed to get article:", errorData);
      throw new Error(
        errorData.error?.message || "글을 불러오는데 실패했습니다"
      );
    }

    const result = await response.json();
    return result;
  } catch (error) {
    console.error("Error getting article:", error);
    throw new Error(
      error instanceof Error
        ? error.message
        : "글을 불러오는 중 오류가 발생했습니다"
    );
  }
}

/**
 * Get user's style guide
 */
export async function getUserStyleGuide() {
  try {
    const { userId } = await auth();

    if (!userId) {
      throw new Error("Unauthorized");
    }

    const response = await fetch(
      `${API_BASE_URL}/api/style-guides/${userId}`,
      {
        method: "GET",
        headers: {
          "x-clerk-user-id": userId,
        },
        cache: "no-store",
      }
    );


    // Handle 404 - return null if not found
    if (response.status === 404) {
      return null;
    }

    if (!response.ok) {
      const errorData = await response.json().catch(() => ({}));
      console.error("Failed to get style guide:", errorData);
      throw new Error(
        errorData.error?.message || "스타일 가이드를 불러오는데 실패했습니다"
      );
    }

    const result = await response.json();

    return result;
  } catch (error) {
    console.error("Error getting style guide:", error);
    throw new Error(
      error instanceof Error
        ? error.message
        : "스타일 가이드를 불러오는 중 오류가 발생했습니다"
    );
  }
}


/**
 * Update a style guide
 */
export async function updateStyleGuideAction(
  guideId: string,
  data: Record<string, any>
) {
  try {
    const { userId } = await auth();

    if (!userId) {
      throw new Error("Unauthorized");
    }

    const response = await fetch(
      `${API_BASE_URL}/api/style-guides/${guideId}`,
      {
        method: "PATCH",
        headers: {
          "Content-Type": "application/json",
          "x-clerk-user-id": userId,
        },
        body: JSON.stringify(data),
      }
    );

    if (!response.ok) {
      const errorData = await response.json().catch(() => ({}));
      console.error("Failed to update style guide:", errorData);
      throw new Error(
        errorData.error?.message || "스타일 가이드 업데이트에 실패했습니다"
      );
    }

    const result = await response.json();
    return result;
  } catch (error) {
    console.error("Error updating style guide:", error);
    throw new Error(
      error instanceof Error
        ? error.message
        : "스타일 가이드 업데이트 중 오류가 발생했습니다"
    );
  }
}

/**
 * Delete a style guide
 */
export async function deleteStyleGuideAction(guideId: string) {
  try {
    const { userId } = await auth();

    if (!userId) {
      throw new Error("Unauthorized");
    }

    const response = await fetch(
      `${API_BASE_URL}/api/style-guides/${guideId}`,
      {
        method: "DELETE",
        headers: {
          "x-clerk-user-id": userId,
        },
      }
    );

    if (!response.ok) {
      const errorData = await response.json().catch(() => ({}));
      console.error("Failed to delete style guide:", errorData);
      throw new Error(
        errorData.error?.message || "스타일 가이드 삭제에 실패했습니다"
      );
    }

    const result = await response.json();
    return result;
  } catch (error) {
    console.error("Error deleting style guide:", error);
    throw new Error(
      error instanceof Error
        ? error.message
        : "스타일 가이드 삭제 중 오류가 발생했습니다"
    );
  }
}
</file>

<file path="src/features/onboarding/backend/route.ts">
import type { Hono } from 'hono';
import {
  failure,
  respond,
  type ErrorResult,
} from '@/backend/http/response';
import {
  getLogger,
  getSupabase,
  type AppEnv,
} from '@/backend/hono/context';
import { CreateStyleGuideRequestSchema } from '@/features/onboarding/backend/schema';
import { upsertStyleGuide, getStyleGuide, updateStyleGuide, deleteStyleGuide, markOnboardingCompleted } from './service';
import {
  styleGuideErrorCodes,
  type StyleGuideServiceError,
} from './error';

export const registerOnboardingRoutes = (app: Hono<AppEnv>) => {
  /**
   * POST /api/style-guides
   * Creates or updates a style guide for a user
   *
   * Request body: OnboardingFormData
   * Headers: x-clerk-user-id (required)
   */
  app.post('/api/style-guides', async (c) => {
    // Get userId from header (passed from server action)
    const userId = c.req.header('x-clerk-user-id');

    if (!userId) {
      return respond(
        c,
        failure(
          401,
          styleGuideErrorCodes.unauthorized,
          'User ID is required. Please provide x-clerk-user-id header.',
        ),
      );
    }

    // Parse and validate request body
    const body = await c.req.json();
    const parsedBody = CreateStyleGuideRequestSchema.safeParse(body);

    if (!parsedBody.success) {
      return respond(
        c,
        failure(
          400,
          styleGuideErrorCodes.validationError,
          'Invalid request body. Please check your input.',
          parsedBody.error.format(),
        ),
      );
    }

    const supabase = getSupabase(c);
    const logger = getLogger(c);

    // Save to database
    const result = await upsertStyleGuide(supabase, userId, parsedBody.data);

    if (!result.ok) {
      const errorResult = result as ErrorResult<StyleGuideServiceError, unknown>;
      logger.error('Failed to save style guide', errorResult.error.message);
      return respond(c, result);
    }

    logger.info('Style guide saved successfully', { userId });
    return respond(c, result);
  });

  /**
   * GET /api/style-guides/:userId
   * Gets the style guide for a user
   *
   * URL params: userId (Clerk user ID)
   * Headers: x-clerk-user-id (required for authorization)
   */
  app.get('/api/style-guides/:userId', async (c) => {
    // Get requesting user ID from header
    const requestingUserId = c.req.header('x-clerk-user-id');

    if (!requestingUserId) {
      return respond(
        c,
        failure(
          401,
          styleGuideErrorCodes.unauthorized,
          'User ID is required. Please provide x-clerk-user-id header.',
        ),
      );
    }

    // Get target user ID from URL param
    const targetUserId = c.req.param('userId');

    if (!targetUserId) {
      return respond(
        c,
        failure(
          400,
          styleGuideErrorCodes.validationError,
          'User ID parameter is required.',
        ),
      );
    }

    // Verify that requesting user can only access their own style guide
    if (requestingUserId !== targetUserId) {
      return respond(
        c,
        failure(
          403,
          styleGuideErrorCodes.unauthorized,
          'You can only access your own style guide.',
        ),
      );
    }

    const supabase = getSupabase(c);
    const logger = getLogger(c);

    // Get style guide
    const result = await getStyleGuide(supabase, targetUserId);

    if (!result.ok) {
      const errorResult = result as ErrorResult<StyleGuideServiceError, unknown>;
      logger.error('Failed to get style guide', errorResult.error.message);
      return respond(c, result);
    }

    logger.info('Style guide retrieved successfully', { userId: targetUserId, result });
    return respond(c, result);
  });

  /**
   * PATCH /api/style-guides/:id
   * Updates a style guide for a user
   *
   * URL params: id (style guide ID)
   * Request body: OnboardingFormData
   * Headers: x-clerk-user-id (required)
   */
  app.patch('/api/style-guides/:id', async (c) => {
    const userId = c.req.header('x-clerk-user-id');
    const guideId = c.req.param('id');

    if (!userId) {
      return respond(
        c,
        failure(
          401,
          styleGuideErrorCodes.unauthorized,
          'User ID is required. Please provide x-clerk-user-id header.',
        ),
      );
    }

    if (!guideId) {
      return respond(
        c,
        failure(
          400,
          styleGuideErrorCodes.validationError,
          'Style guide ID is required.',
        ),
      );
    }

    // Parse and validate request body
    const body = await c.req.json();
    const parsedBody = CreateStyleGuideRequestSchema.safeParse(body);

    if (!parsedBody.success) {
      return respond(
        c,
        failure(
          400,
          styleGuideErrorCodes.validationError,
          'Invalid request body. Please check your input.',
          parsedBody.error.format(),
        ),
      );
    }

    const supabase = getSupabase(c);
    const logger = getLogger(c);

    // Update style guide
    const result = await updateStyleGuide(supabase, guideId, userId, parsedBody.data);

    if (!result.ok) {
      const errorResult = result as ErrorResult<StyleGuideServiceError, unknown>;
      logger.error('Failed to update style guide', errorResult.error.message);
      return respond(c, result);
    }

    logger.info('Style guide updated successfully', { userId, guideId });
    return respond(c, result);
  });

  /**
   * DELETE /api/style-guides/:id
   * Deletes a style guide for a user
   *
   * URL params: id (style guide ID)
   * Headers: x-clerk-user-id (required)
   */
  app.delete('/api/style-guides/:id', async (c) => {
    const userId = c.req.header('x-clerk-user-id');
    const guideId = c.req.param('id');

    if (!userId) {
      return respond(
        c,
        failure(
          401,
          styleGuideErrorCodes.unauthorized,
          'User ID is required. Please provide x-clerk-user-id header.',
        ),
      );
    }

    if (!guideId) {
      return respond(
        c,
        failure(
          400,
          styleGuideErrorCodes.validationError,
          'Style guide ID is required.',
        ),
      );
    }

    const supabase = getSupabase(c);
    const logger = getLogger(c);

    // Delete style guide
    const result = await deleteStyleGuide(supabase, guideId, userId);

    if (!result.ok) {
      const errorResult = result as ErrorResult<StyleGuideServiceError, unknown>;
      logger.error('Failed to delete style guide', errorResult.error.message);
      return respond(c, result);
    }

    logger.info('Style guide deleted successfully', { userId, guideId });
    return respond(c, result);
  });

  /**
   * PATCH /api/onboarding/complete
   * Marks onboarding as completed for a user
   * This ensures the middleware can check completion status from DB
   *
   * Headers: x-clerk-user-id (required)
   */
  app.patch('/api/onboarding/complete', async (c) => {
    // Get userId from header (passed from server action)
    const userId = c.req.header('x-clerk-user-id');

    if (!userId) {
      return respond(
        c,
        failure(
          401,
          styleGuideErrorCodes.unauthorized,
          'User ID is required. Please provide x-clerk-user-id header.',
        ),
      );
    }

    const supabase = getSupabase(c);
    const logger = getLogger(c);

    // Update the onboarding_completed flag
    const result = await markOnboardingCompleted(supabase, userId);

    if (!result.ok) {
      const errorResult = result as ErrorResult<StyleGuideServiceError, unknown>;
      logger.error('Failed to mark onboarding completed', errorResult.error.message);
      return respond(c, result);
    }

    logger.info('Onboarding marked as completed', { userId });
    return respond(c, result);
  });
};
</file>

<file path="src/features/onboarding/backend/service.ts">
import type { SupabaseClient } from '@supabase/supabase-js';
import {
  failure,
  success,
  type HandlerResult,
} from '@/backend/http/response';
import {
  StyleGuideTableRowSchema,
  StyleGuideResponseSchema,
  type StyleGuideResponse,
  type CreateStyleGuideRequest,
} from '@/features/onboarding/backend/schema';
import {
  styleGuideErrorCodes,
  type StyleGuideServiceError,
} from '@/features/onboarding/backend/error';

const STYLE_GUIDES_TABLE = 'style_guides';

/**
 * Creates or updates a style guide for a user
 * Uses UPSERT to handle repeat onboarding flows
 */
export const upsertStyleGuide = async (
  client: SupabaseClient,
  clerkUserId: string,
  data: CreateStyleGuideRequest,
): Promise<HandlerResult<StyleGuideResponse, StyleGuideServiceError, unknown>> => {
  // Map camelCase TypeScript to snake_case database columns
  const dbRecord = {
    clerk_user_id: clerkUserId,
    brand_name: data.brandName,
    brand_description: data.brandDescription,
    personality: data.personality,
    formality: data.formality,
    target_audience: data.targetAudience,
    pain_points: data.painPoints,
    language: data.language,
    tone: data.tone,
    content_length: data.contentLength,
    reading_level: data.readingLevel,
    notes: data.notes || null,
    is_default: true, // Always true for MVP (one guide per user)
  };

  // Use UPSERT to handle users going through onboarding multiple times
  const { data: savedData, error } = await client
    .from(STYLE_GUIDES_TABLE)
    .upsert(dbRecord, {
      onConflict: 'clerk_user_id', // Update if user already exists
      ignoreDuplicates: false,
    })
    .select('*')
    .single();

  if (error) {
    return failure(
      500,
      styleGuideErrorCodes.upsertError,
      `Failed to save style guide: ${error.message}`,
    );
  }

  if (!savedData) {
    return failure(
      500,
      styleGuideErrorCodes.upsertError,
      'Style guide was saved but no data was returned',
    );
  }

  // Validate the database row
  const rowParse = StyleGuideTableRowSchema.safeParse(savedData);

  if (!rowParse.success) {
    return failure(
      500,
      styleGuideErrorCodes.validationError,
      'Style guide row failed validation.',
      rowParse.error.format(),
    );
  }

  // Map snake_case database columns to camelCase response
  const mapped = {
    id: rowParse.data.id,
    clerkUserId: rowParse.data.clerk_user_id,
    brandName: rowParse.data.brand_name,
    brandDescription: rowParse.data.brand_description,
    personality: rowParse.data.personality,
    formality: rowParse.data.formality,
    targetAudience: rowParse.data.target_audience,
    painPoints: rowParse.data.pain_points,
    language: rowParse.data.language,
    tone: rowParse.data.tone,
    contentLength: rowParse.data.content_length,
    readingLevel: rowParse.data.reading_level,
    notes: rowParse.data.notes,
    isDefault: rowParse.data.is_default,
    createdAt: rowParse.data.created_at,
    updatedAt: rowParse.data.updated_at,
  } satisfies StyleGuideResponse;

  // Validate the response
  const parsed = StyleGuideResponseSchema.safeParse(mapped);

  if (!parsed.success) {
    return failure(
      500,
      styleGuideErrorCodes.validationError,
      'Style guide response failed validation.',
      parsed.error.format(),
    );
  }

  return success(parsed.data, 201);
};

/**
 * Gets the style guide for a user
 * Returns the user's default style guide (one guide per user in MVP)
 */
export const getStyleGuide = async (
  client: SupabaseClient,
  clerkUserId: string,
): Promise<HandlerResult<StyleGuideResponse, StyleGuideServiceError, unknown>> => {
  const { data, error } = await client
    .from(STYLE_GUIDES_TABLE)
    .select('*')
    .eq('clerk_user_id', clerkUserId)
    .single();

  if (error) {
    if (error.code === 'PGRST116') {
      return failure(404, styleGuideErrorCodes.notFound, 'Style guide not found');
    }
    return failure(
      500,
      styleGuideErrorCodes.fetchError,
      `Failed to fetch style guide: ${error.message}`,
    );
  }

  if (!data) {
    return failure(404, styleGuideErrorCodes.notFound, 'Style guide not found');
  }

  // Validate the database row
  const rowParse = StyleGuideTableRowSchema.safeParse(data);

  if (!rowParse.success) {
    return failure(
      500,
      styleGuideErrorCodes.validationError,
      'Style guide row failed validation.',
      rowParse.error.format(),
    );
  }

  // Map snake_case database columns to camelCase response
  const mapped = {
    id: rowParse.data.id,
    clerkUserId: rowParse.data.clerk_user_id,
    brandName: rowParse.data.brand_name,
    brandDescription: rowParse.data.brand_description,
    personality: rowParse.data.personality,
    formality: rowParse.data.formality,
    targetAudience: rowParse.data.target_audience,
    painPoints: rowParse.data.pain_points,
    language: rowParse.data.language,
    tone: rowParse.data.tone,
    contentLength: rowParse.data.content_length,
    readingLevel: rowParse.data.reading_level,
    notes: rowParse.data.notes,
    isDefault: rowParse.data.is_default,
    createdAt: rowParse.data.created_at,
    updatedAt: rowParse.data.updated_at,
  } satisfies StyleGuideResponse;

  // Validate the response
  const parsed = StyleGuideResponseSchema.safeParse(mapped);

  if (!parsed.success) {
    return failure(
      500,
      styleGuideErrorCodes.validationError,
      'Style guide response failed validation.',
      parsed.error.format(),
    );
  }

  return success(parsed.data, 200);
};

/**
 * Updates a style guide for a user
 * Used when user edits their style guide after initial creation
 */
export const updateStyleGuide = async (
  client: SupabaseClient,
  guideId: string,
  clerkUserId: string,
  data: CreateStyleGuideRequest,
): Promise<HandlerResult<StyleGuideResponse, StyleGuideServiceError, unknown>> => {
  // Map camelCase TypeScript to snake_case database columns
  const dbRecord = {
    brand_name: data.brandName,
    brand_description: data.brandDescription,
    personality: data.personality,
    formality: data.formality,
    target_audience: data.targetAudience,
    pain_points: data.painPoints,
    language: data.language,
    tone: data.tone,
    content_length: data.contentLength,
    reading_level: data.readingLevel,
    notes: data.notes || null,
  };

  const { data: updatedData, error } = await client
    .from(STYLE_GUIDES_TABLE)
    .update(dbRecord)
    .eq('id', guideId)
    .eq('clerk_user_id', clerkUserId)
    .select('*')
    .single();

  if (error) {
    if (error.code === 'PGRST116') {
      return failure(404, styleGuideErrorCodes.notFound, 'Style guide not found');
    }
    return failure(
      500,
      styleGuideErrorCodes.upsertError,
      `Failed to update style guide: ${error.message}`,
    );
  }

  if (!updatedData) {
    return failure(404, styleGuideErrorCodes.notFound, 'Style guide not found');
  }

  // Validate the database row
  const rowParse = StyleGuideTableRowSchema.safeParse(updatedData);

  if (!rowParse.success) {
    return failure(
      500,
      styleGuideErrorCodes.validationError,
      'Style guide row failed validation.',
      rowParse.error.format(),
    );
  }

  // Map snake_case database columns to camelCase response
  const mapped = {
    id: rowParse.data.id,
    clerkUserId: rowParse.data.clerk_user_id,
    brandName: rowParse.data.brand_name,
    brandDescription: rowParse.data.brand_description,
    personality: rowParse.data.personality,
    formality: rowParse.data.formality,
    targetAudience: rowParse.data.target_audience,
    painPoints: rowParse.data.pain_points,
    language: rowParse.data.language,
    tone: rowParse.data.tone,
    contentLength: rowParse.data.content_length,
    readingLevel: rowParse.data.reading_level,
    notes: rowParse.data.notes,
    isDefault: rowParse.data.is_default,
    createdAt: rowParse.data.created_at,
    updatedAt: rowParse.data.updated_at,
  } satisfies StyleGuideResponse;

  // Validate the response
  const parsed = StyleGuideResponseSchema.safeParse(mapped);

  if (!parsed.success) {
    return failure(
      500,
      styleGuideErrorCodes.validationError,
      'Style guide response failed validation.',
      parsed.error.format(),
    );
  }

  return success(parsed.data, 200);
};

/**
 * Deletes a style guide
 * Only the owner can delete their guide
 */
export const deleteStyleGuide = async (
  client: SupabaseClient,
  guideId: string,
  clerkUserId: string,
): Promise<HandlerResult<{ success: boolean }, StyleGuideServiceError, unknown>> => {
  const { error } = await client
    .from(STYLE_GUIDES_TABLE)
    .delete()
    .eq('id', guideId)
    .eq('clerk_user_id', clerkUserId);

  if (error) {
    if (error.code === 'PGRST116') {
      return failure(404, styleGuideErrorCodes.notFound, 'Style guide not found');
    }
    return failure(
      500,
      styleGuideErrorCodes.upsertError,
      `Failed to delete style guide: ${error.message}`,
    );
  }

  return success({ success: true }, 200);
};

/**
 * Marks the onboarding as completed for a user
 * Updates the onboarding_completed flag in the style_guides table
 */
export const markOnboardingCompleted = async (
  client: SupabaseClient,
  clerkUserId: string,
): Promise<HandlerResult<{ success: boolean }, StyleGuideServiceError, unknown>> => {
  const { error } = await client
    .from(STYLE_GUIDES_TABLE)
    .update({ onboarding_completed: true })
    .eq('clerk_user_id', clerkUserId);

  if (error) {
    return failure(
      500,
      styleGuideErrorCodes.upsertError,
      `Failed to update onboarding status: ${error.message}`,
    );
  }

  return success({ success: true }, 200);
};
</file>

<file path="src/app/(protected)/dashboard/page.tsx">
"use client";

import { Suspense, useState, useEffect } from "react";
import { useSearchParams, useRouter } from "next/navigation";
import { useCurrentUser } from "@/features/auth/hooks/useCurrentUser";
import { WelcomeHeader } from "@/components/dashboard/welcome-header";
import { StatsCards } from "@/components/dashboard/stats-cards";
import { ActivityChart } from "@/components/dashboard/activity-chart";
import { RecentArticlesList } from "@/components/dashboard/recent-articles-list";
import { WelcomeBanner } from "@/components/dashboard/welcome-banner";

type DashboardPageProps = {
  params: Promise<Record<string, never>>;
};

const WELCOME_SHOWN_KEY = "onboarding_welcome_shown";

function DashboardContent() {
  const { user } = useCurrentUser();
  const searchParams = useSearchParams();
  const router = useRouter();
  const [showWelcomeBanner, setShowWelcomeBanner] = useState(false);

  console.log("[DASHBOARD] Component mounted, user:", user?.email);
  console.log("[DASHBOARD] Current URL:", window.location.href);
  console.log("[DASHBOARD] searchParams:", {
    welcome: searchParams.get("welcome"),
    onboarding_completed: searchParams.get("onboarding_completed"),
  });

  useEffect(() => {
    // Check if welcome parameter is present
    const welcomeParam = searchParams.get("welcome");
    const onboardingParam = searchParams.get("onboarding_completed");

    console.log("[DASHBOARD] useEffect triggered");
    console.log("[DASHBOARD] welcomeParam:", welcomeParam);
    console.log("[DASHBOARD] onboardingParam:", onboardingParam);

    if (welcomeParam === "true") {
      console.log("[DASHBOARD] Welcome param detected");

      // Check if banner has already been shown in this session
      const hasShownWelcome = sessionStorage.getItem(WELCOME_SHOWN_KEY);

      console.log("[DASHBOARD] hasShownWelcome:", hasShownWelcome);

      if (!hasShownWelcome) {
        // Show banner and mark as shown
        console.log("[DASHBOARD] Showing welcome banner");
        setShowWelcomeBanner(true);
        sessionStorage.setItem(WELCOME_SHOWN_KEY, "true");
      }

      // Clean URL by removing welcome parameter
      const newUrl = window.location.pathname;
      console.log("[DASHBOARD] Cleaning URL to:", newUrl);
      router.replace(newUrl);
    } else {
      console.log("[DASHBOARD] No welcome param, skipping cleanup");
    }
  }, [searchParams, router]);

  const getUserName = (email?: string) => {
    if (!email) return "Sam";
    return email.split("@")[0];
  };

  const handleDismissBanner = () => {
    setShowWelcomeBanner(false);
  };

  return (
    <div className="flex flex-col gap-8">
      {showWelcomeBanner && (
        <WelcomeBanner onDismiss={handleDismissBanner} />
      )}
      <WelcomeHeader userName={getUserName(user?.email)} />
      <StatsCards monthlyArticles={4} monthlyGoal={10} savedHours={8} />
      <ActivityChart />
      <RecentArticlesList />
    </div>
  );
}

export default function DashboardPage({ params }: DashboardPageProps) {
  void params;

  return (
    <Suspense fallback={<div className="flex flex-col gap-8">Loading...</div>}>
      <DashboardContent />
    </Suspense>
  );
}
</file>

<file path="src/middleware.ts">
import { clerkMiddleware, createRouteMatcher } from "@clerk/nextjs/server";
import { NextResponse } from "next/server";
import { createServiceClient } from "@/backend/supabase/client";

/**
 * Authentication and Onboarding Guard Middleware
 *
 * This middleware implements a three-stage routing guard system:
 *
 * STAGE 1: Onboarding Route Guard
 * - Route: /auth/onboarding
 * - Requires: User authentication
 * - Redirect: Unauthenticated users → /sign-in
 * - Reverse: Completed onboarding → /dashboard (prevents re-access)
 *
 * STAGE 2: Protected Routes Guard
 * - Routes: /dashboard, /new-article, /style-guide, /account, /editor, /settings
 * - Requires: User authentication + completed onboarding
 * - Redirect: Unauthenticated users → /sign-in (via auth.protect())
 * - Redirect: Authenticated users without onboarding → /auth/onboarding
 *
 * STAGE 3: Public Routes
 * - All other routes pass through without checks
 * - Includes: /sign-in, /sign-up, /auth/after, static assets
 *
 * ONBOARDING STATUS CHECK:
 * - Uses sessionClaims.publicMetadata.onboardingCompleted (boolean)
 * - No database calls (metadata-based for performance)
 * - Set during onboarding completion via updateUser()
 */

const isProtectedRoute = createRouteMatcher([
  "/dashboard(.*)",
  "/new-article(.*)",
  "/style-guide(.*)",
  "/account(.*)",
  "/editor(.*)",
  "/settings(.*)",
]);

const isOnboardingRoute = createRouteMatcher(["/auth/onboarding(.*)"]);

export default clerkMiddleware(async (auth, req) => {
  const { userId, sessionClaims } = await auth();
  const reqUrl = new URL(req.url);

  console.log("[MIDDLEWARE] ===== REQUEST START =====");
  console.log("[MIDDLEWARE] URL:", reqUrl.pathname + reqUrl.search);
  console.log("[MIDDLEWARE] userId:", userId);
  console.log("[MIDDLEWARE] sessionClaims.publicMetadata:", sessionClaims?.publicMetadata);

  // STAGE 1: Onboarding Route Guard
  if (isOnboardingRoute(req)) {
    console.log("[MIDDLEWARE] STAGE 1: Onboarding Route Guard");

    // Require authentication for onboarding page
    if (!userId) {
      console.log("[MIDDLEWARE] No userId, redirecting to /sign-in");
      const signInUrl = new URL("/sign-in", req.url);
      return NextResponse.redirect(signInUrl);
    }

    // Reverse redirect: If onboarding already completed, redirect to dashboard
    const metadata = sessionClaims?.publicMetadata as { onboardingCompleted?: boolean } | undefined;
    const onboardingCompleted = metadata?.onboardingCompleted === true;

    console.log("[MIDDLEWARE] onboardingCompleted:", onboardingCompleted);

    if (onboardingCompleted) {
      console.log("[MIDDLEWARE] User already completed onboarding, redirecting to /dashboard");
      const dashboardUrl = new URL("/dashboard", req.url);
      return NextResponse.redirect(dashboardUrl);
    }

    console.log("[MIDDLEWARE] Allowing access to onboarding route");
    return NextResponse.next();
  }

  // STAGE 2: Protected Routes Guard
  if (isProtectedRoute(req)) {
    console.log("[MIDDLEWARE] STAGE 2: Protected Routes Guard");

    // STAGE 2a: Require authentication
    if (!userId) {
      console.log("[MIDDLEWARE] No userId, calling auth.protect()");
      await auth.protect(); // Redirects to sign-in
      return;
    }

    // STAGE 2b: Require completed onboarding
    // Check from database instead of Clerk metadata to avoid session cache delays
    console.log("[MIDDLEWARE] STAGE 2b: Onboarding Check (from Supabase)");

    let onboardingCompleted = false;

    try {
      // Create Supabase service client to query database
      const supabaseUrl = process.env.SUPABASE_URL;
      const supabaseServiceRoleKey = process.env.SUPABASE_SERVICE_ROLE_KEY;

      if (!supabaseUrl || !supabaseServiceRoleKey) {
        console.warn("[MIDDLEWARE] Missing Supabase credentials, falling back to Clerk metadata");
        const metadata = sessionClaims?.publicMetadata as { onboardingCompleted?: boolean } | undefined;
        onboardingCompleted = metadata?.onboardingCompleted === true;
      } else {
        const supabase = createServiceClient({
          url: supabaseUrl,
          serviceRoleKey: supabaseServiceRoleKey,
        });

        // Query style_guides table to check if user has completed onboarding
        const { data, error } = await supabase
          .from("style_guides")
          .select("onboarding_completed")
          .eq("clerk_user_id", userId)
          .single();

        if (error) {
          console.warn("[MIDDLEWARE] Failed to query style_guides:", error);
          // Fall back to Clerk metadata if DB query fails
          const metadata = sessionClaims?.publicMetadata as { onboardingCompleted?: boolean } | undefined;
          onboardingCompleted = metadata?.onboardingCompleted === true;
        } else if (data) {
          onboardingCompleted = data.onboarding_completed === true;
          console.log("[MIDDLEWARE] DB check: onboarding_completed =", onboardingCompleted);
        }
      }
    } catch (error) {
      console.error("[MIDDLEWARE] Error checking onboarding status:", error);
      // Fall back to Clerk metadata if any error occurs
      const metadata = sessionClaims?.publicMetadata as { onboardingCompleted?: boolean } | undefined;
      onboardingCompleted = metadata?.onboardingCompleted === true;
    }

    const justCompletedOnboarding = new URL(req.url).searchParams.get("onboarding_completed") === "true";

    console.log("[MIDDLEWARE] onboardingCompleted (from DB):", onboardingCompleted);
    console.log("[MIDDLEWARE] justCompletedOnboarding (query param):", justCompletedOnboarding);

    if (!onboardingCompleted && !justCompletedOnboarding) {
      console.log("[MIDDLEWARE] User not onboarded and no bypass param, redirecting to /auth/onboarding");
      const onboardingUrl = new URL("/auth/onboarding", req.url);
      return NextResponse.redirect(onboardingUrl);
    }

    if (justCompletedOnboarding) {
      console.log("[MIDDLEWARE] Bypass active: allowing access despite onboardingCompleted=false");
    }

    console.log("[MIDDLEWARE] Allowing access to protected route");
  }

  // STAGE 3: Public routes pass through
  console.log("[MIDDLEWARE] STAGE 3: Public route, passing through");
  console.log("[MIDDLEWARE] ===== REQUEST END =====");
});

export const config = {
  matcher: [
    // Skip Next.js internals and all static files, unless found in search params
    "/((?!_next|[^?]*\\.(?:html?|css|js(?!on)|jpe?g|webp|png|gif|svg|ttf|woff2?|ico|csv|docx?|xlsx?|zip|webmanifest)).*)",
    // Always run for API routes
    "/(api|trpc)(.*)",
  ],
};
</file>

<file path="src/app/(protected)/new-article/page.tsx">
"use client";

import { useRouter } from "next/navigation";
import { Card } from "@/components/ui/card";
import { Button } from "@/components/ui/button";
import { useToast } from "@/hooks/use-toast";
import { ArrowLeft, LoaderCircle } from "lucide-react";
import { GenerationForm } from "@/features/articles/components/generation-form";
import { GenerationProgress } from "@/features/articles/components/generation-progress";
import { useGenerateArticle } from "@/features/articles/hooks/useGenerateArticle";
import { useStyleGuide } from "@/features/articles/hooks/useStyleGuide";
import { useState, useEffect } from "react";
import type { GenerationFormData } from "@/features/articles/components/generation-form";

type NewArticlePageProps = {
  params: Promise<Record<string, never>>;
};

export default function NewArticlePage({ params }: NewArticlePageProps) {
  void params;

  const router = useRouter();
  const { toast } = useToast();
  const [isGenerating, setIsGenerating] = useState(false);

  const {
    generateArticle,
    isLoading,
    error,
    completion,
  } = useGenerateArticle();

  const { data: styleGuideData, isLoading: isLoadingStyleGuide } =
    useStyleGuide();

  const styleGuides = styleGuideData
    ? [
        {
          id: styleGuideData.id,
          name: "내 스타일 가이드",
        },
      ]
    : [];

  const handleBack = () => {
    router.back();
  };

  const handleGenerateSubmit = async (data: GenerationFormData) => {
    setIsGenerating(true);

    try {
      const keywords = data.keywords
        ? data.keywords.split(",").map((k) => k.trim())
        : [];

      await generateArticle({
        topic: data.topic,
        styleGuideId: data.styleGuideId,
        keywords,
        additionalInstructions: undefined,
      });
    } catch (error) {
      console.error("Failed to generate article:", error);
      toast({
        title: "생성 실패",
        description:
          error instanceof Error
            ? error.message
            : "AI 글 생성 중 오류가 발생했습니다.",
        variant: "destructive",
      });
      setIsGenerating(false);
    }
  };

  // Monitor completion for article generation
  useEffect(() => {
    if (!isLoading && completion) {
      try {
        // Try to parse as JSON (structured content)
        const parsed = JSON.parse(completion);

        // If it looks like generated article content with title and content
        if (parsed.title && parsed.content) {
          // Extract title from the first line if it exists
          const titleMatch = parsed.content.match(/^#\s+(.+)\n/);
          const title = titleMatch ? titleMatch[1] : parsed.title;

          toast({
            title: "AI 글 생성 완료",
            description: `"${title}" 글이 생성되었습니다.`,
          });

          // For now, redirect to editor with the content in state
          // In a real app, you'd save to DB first
          router.push(`/articles/new/content`);
        }
      } catch {
        // Not JSON, might be plain text response
      }

      setIsGenerating(false);
    }
  }, [completion, isLoading, router, toast]);

  return (
    <div className="min-h-screen" style={{ backgroundColor: "#FCFCFD" }}>
      <div className="container mx-auto max-w-2xl px-4 py-8">
        {/* Header */}
        <div className="mb-8">
          <Button
            variant="ghost"
            onClick={handleBack}
            className="mb-4 -ml-2"
            style={{ color: "#6B7280" }}
          >
            <ArrowLeft className="mr-2 h-4 w-4" />
            뒤로 가기
          </Button>
        </div>

        {/* Main Card */}
        <Card
          className="p-8"
          style={{
            borderColor: "#E1E5EA",
            borderRadius: "12px",
          }}
        >
          {isGenerating || isLoading ? (
            <GenerationProgress
              isGenerating={true}
              error={error}
              onCancel={() => {
                setIsGenerating(false);
              }}
              onRetry={() => {
                setIsGenerating(false);
              }}
            />
          ) : (
            <GenerationForm
              styleGuides={styleGuides}
              onSubmit={handleGenerateSubmit}
              isLoading={isLoadingStyleGuide}
            />
          )}
        </Card>
      </div>
    </div>
  );
}
</file>

<file path="package.json">
{
  "name": "template",
  "version": "0.1.3",
  "private": true,
  "type": "module",
  "scripts": {
    "dev": "next dev --turbopack",
    "build": "next build",
    "start": "next start",
    "lint": "next lint",
    "test": "vitest run",
    "test:watch": "vitest",
    "test:ui": "vitest --ui",
    "test:coverage": "vitest run --coverage",
    "test:e2e": "playwright test",
    "test:e2e:watch": "playwright test --ui",
    "test:e2e:headed": "playwright test --headed",
    "test:all": "run-p test test:e2e",
    "typecheck": "tsc --noEmit",
    "env:check": "dotenv -e .env.local -- tsx scripts/check-env.ts"
  },
  "dependencies": {
    "@ai-sdk/google": "^2.0.29",
    "@clerk/nextjs": "^6.34.5",
    "@hookform/resolvers": "^4",
    "@radix-ui/react-accordion": "^1.2.3",
    "@radix-ui/react-avatar": "^1.1.2",
    "@radix-ui/react-checkbox": "^1.1.1",
    "@radix-ui/react-dialog": "^1.1.15",
    "@radix-ui/react-dropdown-menu": "^2.1.1",
    "@radix-ui/react-label": "^2.1.0",
    "@radix-ui/react-progress": "^1.1.8",
    "@radix-ui/react-select": "^2.1.4",
    "@radix-ui/react-separator": "^1.1.1",
    "@radix-ui/react-slot": "^1.1.0",
    "@radix-ui/react-tabs": "^1.1.13",
    "@radix-ui/react-toast": "^1.2.6",
    "@supabase/ssr": "^0.5.2",
    "@supabase/supabase-js": "^2.58.0",
    "@tanstack/react-query": "^5",
    "@uiw/react-md-editor": "^4.0.8",
    "ai": "^5.0.89",
    "axios": "^1.7.9",
    "class-variance-authority": "^0.7.0",
    "clsx": "^2.1.1",
    "date-fns": "^4",
    "es-toolkit": "^1",
    "framer-motion": "^11",
    "hono": "^4.9.9",
    "lucide-react": "^0.469.0",
    "next": "15.1.0",
    "next-themes": "^0.4.3",
    "react": "^19.0.0",
    "react-dom": "^19.0.0",
    "react-hook-form": "^7",
    "react-markdown": "^10.1.0",
    "react-use": "^17",
    "rehype-highlight": "^7.0.2",
    "rehype-sanitize": "^6.0.0",
    "remark-gfm": "^4.0.1",
    "server-only": "0.0.1",
    "sonner": "^2.0.7",
    "ts-pattern": "^5",
    "zod": "^3",
    "zustand": "^4"
  },
  "devDependencies": {
    "@eslint/eslintrc": "^3",
    "@playwright/test": "^1.56.0",
    "@tailwindcss/postcss": "^4.1.13",
    "@tailwindcss/typography": "^0.5.10",
    "@testing-library/dom": "^10.4.1",
    "@testing-library/jest-dom": "^6.9.1",
    "@testing-library/react": "^16.3.0",
    "@testing-library/user-event": "^14.6.1",
    "@types/node": "^20",
    "@types/react": "^19",
    "@types/react-dom": "^19",
    "@vitejs/plugin-react": "^5.0.4",
    "@vitest/coverage-v8": "^3.2.4",
    "@vitest/ui": "^3.2.4",
    "dotenv-cli": "^10.0.0",
    "eslint": "^9",
    "eslint-config-next": "15.1.0",
    "happy-dom": "^19.0.2",
    "npm-run-all": "^4.1.5",
    "postcss": "^8",
    "tailwind-merge": "^2.5.2",
    "tailwindcss": "^4.1.13",
    "tailwindcss-animate": "^1.0.7",
    "tsx": "^4.20.6",
    "typescript": "^5",
    "vitest": "^3.2.4"
  },
  "packageManager": "pnpm@9.12.2+sha512.22721b3a11f81661ae1ec68ce1a7b879425a1ca5b991c975b074ac220b187ce56c708fe5db69f4c962c989452eee76c82877f4ee80f474cebd61ee13461b6228"
}
</file>

</files>
